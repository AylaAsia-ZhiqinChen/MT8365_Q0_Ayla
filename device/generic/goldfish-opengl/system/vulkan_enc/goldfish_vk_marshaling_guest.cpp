// Copyright (C) 2018 The Android Open Source Project
// Copyright (C) 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Autogenerated module goldfish_vk_marshaling_guest
// (impl) generated by android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/genvk.py -registry android/android-emugl/host/libs/libOpenglRender/vulkan-registry/xml/vk.xml cereal -o android/android-emugl/host/libs/libOpenglRender/vulkan/cereal
// Please do not modify directly;
// re-run android/scripts/generate-vulkan-sources.sh,
// or directly from Python by defining:
// VULKAN_REGISTRY_XML_DIR : Directory containing genvk.py and vk.xml
// CEREAL_OUTPUT_DIR: Where to put the generated sources.
// python3 $VULKAN_REGISTRY_XML_DIR/genvk.py -registry $VULKAN_REGISTRY_XML_DIR/vk.xml cereal -o $CEREAL_OUTPUT_DIR

#include "goldfish_vk_marshaling_guest.h"


#include "goldfish_vk_extension_structs_guest.h"
#include "goldfish_vk_private_defs.h"


namespace goldfish_vk {

void marshal_extension_struct(
    VulkanStreamGuest* vkStream,
    const void* structExtension);

void unmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    void* structExtension_out);

#ifdef VK_VERSION_1_0
void marshal_VkApplicationInfo(
    VulkanStreamGuest* vkStream,
    const VkApplicationInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->putString(forMarshaling->pApplicationName);
    vkStream->write((uint32_t*)&forMarshaling->applicationVersion, sizeof(uint32_t));
    vkStream->putString(forMarshaling->pEngineName);
    vkStream->write((uint32_t*)&forMarshaling->engineVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
}

void unmarshal_VkApplicationInfo(
    VulkanStreamGuest* vkStream,
    VkApplicationInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pApplicationName);
    vkStream->read((uint32_t*)&forUnmarshaling->applicationVersion, sizeof(uint32_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pEngineName);
    vkStream->read((uint32_t*)&forUnmarshaling->engineVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
}

void marshal_VkInstanceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkInstanceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkInstanceCreateFlags*)&forMarshaling->flags, sizeof(VkInstanceCreateFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_0 = (uint64_t)(uintptr_t)forMarshaling->pApplicationInfo;
    vkStream->putBe64(cgen_var_0);
    if (forMarshaling->pApplicationInfo)
    {
        marshal_VkApplicationInfo(vkStream, (const VkApplicationInfo*)(forMarshaling->pApplicationInfo));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
}

void unmarshal_VkInstanceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkInstanceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkInstanceCreateFlags*)&forUnmarshaling->flags, sizeof(VkInstanceCreateFlags));
    // WARNING PTR CHECK
    const VkApplicationInfo* check_pApplicationInfo;
    check_pApplicationInfo = (const VkApplicationInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pApplicationInfo)
    {
        if (!(check_pApplicationInfo))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pApplicationInfo inconsistent between guest and host\n");
        }
        unmarshal_VkApplicationInfo(vkStream, (VkApplicationInfo*)(forUnmarshaling->pApplicationInfo));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
}

void marshal_VkAllocationCallbacks(
    VulkanStreamGuest* vkStream,
    const VkAllocationCallbacks* forMarshaling)
{
    // WARNING PTR CHECK
    uint64_t cgen_var_2 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_2);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
    uint64_t cgen_var_3 = (uint64_t)forMarshaling->pfnAllocation;
    vkStream->putBe64(cgen_var_3);
    uint64_t cgen_var_4 = (uint64_t)forMarshaling->pfnReallocation;
    vkStream->putBe64(cgen_var_4);
    uint64_t cgen_var_5 = (uint64_t)forMarshaling->pfnFree;
    vkStream->putBe64(cgen_var_5);
    uint64_t cgen_var_6 = (uint64_t)forMarshaling->pfnInternalAllocation;
    vkStream->putBe64(cgen_var_6);
    uint64_t cgen_var_7 = (uint64_t)forMarshaling->pfnInternalFree;
    vkStream->putBe64(cgen_var_7);
}

void unmarshal_VkAllocationCallbacks(
    VulkanStreamGuest* vkStream,
    VkAllocationCallbacks* forUnmarshaling)
{
    // WARNING PTR CHECK
    void* check_pUserData;
    check_pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        if (!(check_pUserData))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pUserData inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
    forUnmarshaling->pfnAllocation = (PFN_vkAllocationFunction)vkStream->getBe64();
    forUnmarshaling->pfnReallocation = (PFN_vkReallocationFunction)vkStream->getBe64();
    forUnmarshaling->pfnFree = (PFN_vkFreeFunction)vkStream->getBe64();
    forUnmarshaling->pfnInternalAllocation = (PFN_vkInternalAllocationNotification)vkStream->getBe64();
    forUnmarshaling->pfnInternalFree = (PFN_vkInternalFreeNotification)vkStream->getBe64();
}

void marshal_VkPhysicalDeviceFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceFeatures* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->independentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->geometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->logicOp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthBounds, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->wideLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->largePoints, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiViewport, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedQueries, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceFeatures* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullDrawIndexUint32, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->imageCubeArray, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->independentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->geometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->tessellationShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleRateShading, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dualSrcBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiDrawIndirect, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->drawIndirectFirstInstance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasClamp, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fillModeNonSolid, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBounds, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->wideLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->largePoints, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOne, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiViewport, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->samplerAnisotropy, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionETC2, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionASTC_LDR, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->textureCompressionBC, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryPrecise, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->pipelineStatisticsQuery, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->vertexPipelineStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fragmentStoresAndAtomics, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderTessellationAndGeometryPointSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderImageGatherExtended, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageExtendedFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageMultisample, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageReadWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageWriteWithoutFormat, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderClipDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderCullDistance, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderFloat64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt64, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInt16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceResidency, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderResourceMinLod, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseBinding, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage2D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyImage3D, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency2Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency4Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency8Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidency16Samples, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->sparseResidencyAliased, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variableMultisampleRate, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedQueries, sizeof(VkBool32));
}

void marshal_VkFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkFormatProperties* forMarshaling)
{
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void unmarshal_VkFormatProperties(
    VulkanStreamGuest* vkStream,
    VkFormatProperties* forUnmarshaling)
{
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->linearTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->optimalTilingFeatures, sizeof(VkFormatFeatureFlags));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->bufferFeatures, sizeof(VkFormatFeatureFlags));
}

void marshal_VkExtent3D(
    VulkanStreamGuest* vkStream,
    const VkExtent3D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->depth, sizeof(uint32_t));
}

void unmarshal_VkExtent3D(
    VulkanStreamGuest* vkStream,
    VkExtent3D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->depth, sizeof(uint32_t));
}

void marshal_VkImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkImageFormatProperties* forMarshaling)
{
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->maxExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

void unmarshal_VkImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkImageFormatProperties* forUnmarshaling)
{
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->maxExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxResourceSize, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDeviceLimits(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceLimits* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxViewports, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->viewportSubPixelBits, sizeof(uint32_t));
    uint64_t cgen_var_14 = (uint64_t)forMarshaling->minMemoryMapAlignment;
    vkStream->putBe64(cgen_var_14);
    vkStream->write((VkDeviceSize*)&forMarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((int32_t*)&forMarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->write((float*)&forMarshaling->minInterpolationOffset, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((VkSampleCountFlags*)&forMarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->timestampPeriod, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->write((float*)forMarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->write((float*)forMarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->write((float*)&forMarshaling->pointSizeGranularity, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidthGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->strictLines, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceLimits(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceLimits* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension1D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension2D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimension3D, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageDimensionCube, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelBufferElements, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUniformBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageBufferRange, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushConstantsSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMemoryAllocationCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSamplerAllocationCount, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferImageGranularity, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sparseAddressSpaceSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->maxBoundDescriptorSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributes, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindings, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputAttributeOffset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexInputBindingStride, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationGenerationLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationPatchSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerVertexOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlPerPatchOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationControlTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTessellationEvaluationOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryShaderInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryOutputVertices, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxGeometryTotalOutputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentInputComponents, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentOutputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentDualSrcAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFragmentCombinedOutputResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeSharedMemorySize, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxComputeWorkGroupInvocations, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->subTexelPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->mipmapPrecisionBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndexedIndexValue, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDrawIndirectCount, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->maxSamplerLodBias, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxSamplerAnisotropy, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxViewports, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->maxViewportDimensions, 2 * sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->viewportBoundsRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportSubPixelBits, sizeof(uint32_t));
    forUnmarshaling->minMemoryMapAlignment = (size_t)vkStream->getBe64();
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minTexelBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minUniformBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minStorageBufferOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelOffset, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->minTexelGatherOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxTexelGatherOffset, sizeof(uint32_t));
    vkStream->read((float*)&forUnmarshaling->minInterpolationOffset, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxInterpolationOffset, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->subPixelInterpolationOffsetBits, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferWidth, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferHeight, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxFramebufferLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->framebufferNoAttachmentsSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageColorSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageIntegerSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageDepthSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampledImageStencilSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->storageImageSampleCounts, sizeof(VkSampleCountFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSampleMaskWords, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->timestampComputeAndGraphics, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->timestampPeriod, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->maxClipDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxCombinedClipAndCullDistances, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->discreteQueuePriorities, sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->pointSizeRange, 2 * sizeof(float));
    vkStream->read((float*)forUnmarshaling->lineWidthRange, 2 * sizeof(float));
    vkStream->read((float*)&forUnmarshaling->pointSizeGranularity, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidthGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->strictLines, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->standardSampleLocations, sizeof(VkBool32));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyOffsetAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->optimalBufferCopyRowPitchAlignment, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->nonCoherentAtomSize, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDeviceSparseProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSparseProperties* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSparseProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSparseProperties* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard2DMultisampleBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyStandard3DBlockShape, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyAlignedMipSize, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->residencyNonResidentStrict, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->apiVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->driverVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vendorID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceID, sizeof(uint32_t));
    vkStream->write((VkPhysicalDeviceType*)&forMarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->write((char*)forMarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->write((uint8_t*)forMarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    marshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forMarshaling->limits));
    marshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forMarshaling->sparseProperties));
}

void unmarshal_VkPhysicalDeviceProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->apiVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->driverVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vendorID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceID, sizeof(uint32_t));
    vkStream->read((VkPhysicalDeviceType*)&forUnmarshaling->deviceType, sizeof(VkPhysicalDeviceType));
    vkStream->read((char*)forUnmarshaling->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    vkStream->read((uint8_t*)forUnmarshaling->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    unmarshal_VkPhysicalDeviceLimits(vkStream, (VkPhysicalDeviceLimits*)(&forUnmarshaling->limits));
    unmarshal_VkPhysicalDeviceSparseProperties(vkStream, (VkPhysicalDeviceSparseProperties*)(&forUnmarshaling->sparseProperties));
}

void marshal_VkQueueFamilyProperties(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyProperties* forMarshaling)
{
    vkStream->write((VkQueueFlags*)&forMarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->timestampValidBits, sizeof(uint32_t));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->minImageTransferGranularity));
}

void unmarshal_VkQueueFamilyProperties(
    VulkanStreamGuest* vkStream,
    VkQueueFamilyProperties* forUnmarshaling)
{
    vkStream->read((VkQueueFlags*)&forUnmarshaling->queueFlags, sizeof(VkQueueFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->timestampValidBits, sizeof(uint32_t));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->minImageTransferGranularity));
}

void marshal_VkMemoryType(
    VulkanStreamGuest* vkStream,
    const VkMemoryType* forMarshaling)
{
    vkStream->write((VkMemoryPropertyFlags*)&forMarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->write((uint32_t*)&forMarshaling->heapIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryType(
    VulkanStreamGuest* vkStream,
    VkMemoryType* forUnmarshaling)
{
    vkStream->read((VkMemoryPropertyFlags*)&forUnmarshaling->propertyFlags, sizeof(VkMemoryPropertyFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->heapIndex, sizeof(uint32_t));
}

void marshal_VkMemoryHeap(
    VulkanStreamGuest* vkStream,
    const VkMemoryHeap* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkMemoryHeapFlags*)&forMarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void unmarshal_VkMemoryHeap(
    VulkanStreamGuest* vkStream,
    VkMemoryHeap* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkMemoryHeapFlags*)&forUnmarshaling->flags, sizeof(VkMemoryHeapFlags));
}

void marshal_VkPhysicalDeviceMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMemoryProperties* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        marshal_VkMemoryType(vkStream, (VkMemoryType*)(forMarshaling->memoryTypes + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        marshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forMarshaling->memoryHeaps + i));
    }
}

void unmarshal_VkPhysicalDeviceMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMemoryProperties* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_TYPES; ++i)
    {
        unmarshal_VkMemoryType(vkStream, (VkMemoryType*)(forUnmarshaling->memoryTypes + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryHeapCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)VK_MAX_MEMORY_HEAPS; ++i)
    {
        unmarshal_VkMemoryHeap(vkStream, (VkMemoryHeap*)(forUnmarshaling->memoryHeaps + i));
    }
}

void marshal_VkDeviceQueueCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueCount, sizeof(uint32_t));
    vkStream->write((const float*)forMarshaling->pQueuePriorities, forMarshaling->queueCount * sizeof(const float));
}

void unmarshal_VkDeviceQueueCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceQueueCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCount, sizeof(uint32_t));
    vkStream->read((float*)forUnmarshaling->pQueuePriorities, forUnmarshaling->queueCount * sizeof(const float));
}

void marshal_VkDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueCreateInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueCreateInfoCount; ++i)
    {
        marshal_VkDeviceQueueCreateInfo(vkStream, (const VkDeviceQueueCreateInfo*)(forMarshaling->pQueueCreateInfos + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->enabledLayerCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledLayerNames, forMarshaling->enabledLayerCount);
    vkStream->write((uint32_t*)&forMarshaling->enabledExtensionCount, sizeof(uint32_t));
    saveStringArray(vkStream, forMarshaling->ppEnabledExtensionNames, forMarshaling->enabledExtensionCount);
    // WARNING PTR CHECK
    uint64_t cgen_var_16 = (uint64_t)(uintptr_t)forMarshaling->pEnabledFeatures;
    vkStream->putBe64(cgen_var_16);
    if (forMarshaling->pEnabledFeatures)
    {
        marshal_VkPhysicalDeviceFeatures(vkStream, (const VkPhysicalDeviceFeatures*)(forMarshaling->pEnabledFeatures));
    }
}

void unmarshal_VkDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueCreateInfoCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueCreateInfoCount; ++i)
    {
        unmarshal_VkDeviceQueueCreateInfo(vkStream, (VkDeviceQueueCreateInfo*)(forUnmarshaling->pQueueCreateInfos + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->enabledLayerCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledLayerNames);
    vkStream->read((uint32_t*)&forUnmarshaling->enabledExtensionCount, sizeof(uint32_t));
    vkStream->loadStringArrayInPlace((char***)&forUnmarshaling->ppEnabledExtensionNames);
    // WARNING PTR CHECK
    const VkPhysicalDeviceFeatures* check_pEnabledFeatures;
    check_pEnabledFeatures = (const VkPhysicalDeviceFeatures*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pEnabledFeatures)
    {
        if (!(check_pEnabledFeatures))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pEnabledFeatures inconsistent between guest and host\n");
        }
        unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(forUnmarshaling->pEnabledFeatures));
    }
}

void marshal_VkExtensionProperties(
    VulkanStreamGuest* vkStream,
    const VkExtensionProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
}

void unmarshal_VkExtensionProperties(
    VulkanStreamGuest* vkStream,
    VkExtensionProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->extensionName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
}

void marshal_VkLayerProperties(
    VulkanStreamGuest* vkStream,
    const VkLayerProperties* forMarshaling)
{
    vkStream->write((char*)forMarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->write((uint32_t*)&forMarshaling->specVersion, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->write((char*)forMarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void unmarshal_VkLayerProperties(
    VulkanStreamGuest* vkStream,
    VkLayerProperties* forUnmarshaling)
{
    vkStream->read((char*)forUnmarshaling->layerName, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    vkStream->read((uint32_t*)&forUnmarshaling->specVersion, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->implementationVersion, sizeof(uint32_t));
    vkStream->read((char*)forUnmarshaling->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

void marshal_VkSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_18;
        vkStream->alloc((void**)&cgen_var_18, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_18, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_18, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((const VkPipelineStageFlags*)forMarshaling->pWaitDstStageMask, forMarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    if (forMarshaling->commandBufferCount)
    {
        uint64_t* cgen_var_19;
        vkStream->alloc((void**)&cgen_var_19, forMarshaling->commandBufferCount * 8);
        vkStream->handleMapping()->mapHandles_VkCommandBuffer_u64(forMarshaling->pCommandBuffers, cgen_var_19, forMarshaling->commandBufferCount);
        vkStream->write((uint64_t*)cgen_var_19, forMarshaling->commandBufferCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_20;
        vkStream->alloc((void**)&cgen_var_20, forMarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pSignalSemaphores, cgen_var_20, forMarshaling->signalSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_20, forMarshaling->signalSemaphoreCount * 8);
    }
}

void unmarshal_VkSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_21;
        vkStream->alloc((void**)&cgen_var_21, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_21, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_21, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->read((VkPipelineStageFlags*)forUnmarshaling->pWaitDstStageMask, forUnmarshaling->waitSemaphoreCount * sizeof(const VkPipelineStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    if (forUnmarshaling->commandBufferCount)
    {
        uint64_t* cgen_var_22;
        vkStream->alloc((void**)&cgen_var_22, forUnmarshaling->commandBufferCount * 8);
        vkStream->read((uint64_t*)cgen_var_22, forUnmarshaling->commandBufferCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkCommandBuffer(cgen_var_22, (VkCommandBuffer*)forUnmarshaling->pCommandBuffers, forUnmarshaling->commandBufferCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_23;
        vkStream->alloc((void**)&cgen_var_23, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_23, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_23, (VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount);
    }
}

void marshal_VkMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeIndex, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeIndex, sizeof(uint32_t));
}

void marshal_VkMappedMemoryRange(
    VulkanStreamGuest* vkStream,
    const VkMappedMemoryRange* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_24;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_24, 1);
    vkStream->write((uint64_t*)&cgen_var_24, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkMappedMemoryRange(
    VulkanStreamGuest* vkStream,
    VkMappedMemoryRange* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_25;
    vkStream->read((uint64_t*)&cgen_var_25, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_25, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkMemoryRequirements(
    VulkanStreamGuest* vkStream,
    const VkMemoryRequirements* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryRequirements(
    VulkanStreamGuest* vkStream,
    VkMemoryRequirements* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->alignment, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkSparseImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkSparseImageFormatProperties* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageGranularity));
    vkStream->write((VkSparseImageFormatFlags*)&forMarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void unmarshal_VkSparseImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkSparseImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageGranularity));
    vkStream->read((VkSparseImageFormatFlags*)&forUnmarshaling->flags, sizeof(VkSparseImageFormatFlags));
}

void marshal_VkSparseImageMemoryRequirements(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryRequirements* forMarshaling)
{
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->formatProperties));
    vkStream->write((uint32_t*)&forMarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void unmarshal_VkSparseImageMemoryRequirements(
    VulkanStreamGuest* vkStream,
    VkSparseImageMemoryRequirements* forUnmarshaling)
{
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->formatProperties));
    vkStream->read((uint32_t*)&forUnmarshaling->imageMipTailFirstLod, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailSize, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->imageMipTailStride, sizeof(VkDeviceSize));
}

void marshal_VkSparseMemoryBind(
    VulkanStreamGuest* vkStream,
    const VkSparseMemoryBind* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    uint64_t cgen_var_26;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_26, 1);
    vkStream->write((uint64_t*)&cgen_var_26, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseMemoryBind(
    VulkanStreamGuest* vkStream,
    VkSparseMemoryBind* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->resourceOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    uint64_t cgen_var_27;
    vkStream->read((uint64_t*)&cgen_var_27, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_27, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseBufferMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseBufferMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_28;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_28, 1);
    vkStream->write((uint64_t*)&cgen_var_28, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseBufferMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkSparseBufferMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_29;
    vkStream->read((uint64_t*)&cgen_var_29, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_29, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseImageOpaqueMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_30;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_30, 1);
    vkStream->write((uint64_t*)&cgen_var_30, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseMemoryBind(vkStream, (const VkSparseMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageOpaqueMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkSparseImageOpaqueMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_31;
    vkStream->read((uint64_t*)&cgen_var_31, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_31, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseMemoryBind(vkStream, (VkSparseMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkImageSubresource(
    VulkanStreamGuest* vkStream,
    const VkImageSubresource* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayer, sizeof(uint32_t));
}

void unmarshal_VkImageSubresource(
    VulkanStreamGuest* vkStream,
    VkImageSubresource* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayer, sizeof(uint32_t));
}

void marshal_VkOffset3D(
    VulkanStreamGuest* vkStream,
    const VkOffset3D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->z, sizeof(int32_t));
}

void unmarshal_VkOffset3D(
    VulkanStreamGuest* vkStream,
    VkOffset3D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->z, sizeof(int32_t));
}

void marshal_VkSparseImageMemoryBind(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryBind* forMarshaling)
{
    marshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forMarshaling->subresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->offset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    uint64_t cgen_var_32;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_32, 1);
    vkStream->write((uint64_t*)&cgen_var_32, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->write((VkSparseMemoryBindFlags*)&forMarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void unmarshal_VkSparseImageMemoryBind(
    VulkanStreamGuest* vkStream,
    VkSparseImageMemoryBind* forUnmarshaling)
{
    unmarshal_VkImageSubresource(vkStream, (VkImageSubresource*)(&forUnmarshaling->subresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    uint64_t cgen_var_33;
    vkStream->read((uint64_t*)&cgen_var_33, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_33, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
    vkStream->read((VkSparseMemoryBindFlags*)&forUnmarshaling->flags, sizeof(VkSparseMemoryBindFlags));
}

void marshal_VkSparseImageMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryBindInfo* forMarshaling)
{
    uint64_t cgen_var_34;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_34, 1);
    vkStream->write((uint64_t*)&cgen_var_34, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindCount; ++i)
    {
        marshal_VkSparseImageMemoryBind(vkStream, (const VkSparseImageMemoryBind*)(forMarshaling->pBinds + i));
    }
}

void unmarshal_VkSparseImageMemoryBindInfo(
    VulkanStreamGuest* vkStream,
    VkSparseImageMemoryBindInfo* forUnmarshaling)
{
    uint64_t cgen_var_35;
    vkStream->read((uint64_t*)&cgen_var_35, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_35, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->bindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBind(vkStream, (VkSparseImageMemoryBind*)(forUnmarshaling->pBinds + i));
    }
}

void marshal_VkBindSparseInfo(
    VulkanStreamGuest* vkStream,
    const VkBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_36;
        vkStream->alloc((void**)&cgen_var_36, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_36, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_36, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->bufferBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bufferBindCount; ++i)
    {
        marshal_VkSparseBufferMemoryBindInfo(vkStream, (const VkSparseBufferMemoryBindInfo*)(forMarshaling->pBufferBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageOpaqueBindCount; ++i)
    {
        marshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (const VkSparseImageOpaqueMemoryBindInfo*)(forMarshaling->pImageOpaqueBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->imageBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->imageBindCount; ++i)
    {
        marshal_VkSparseImageMemoryBindInfo(vkStream, (const VkSparseImageMemoryBindInfo*)(forMarshaling->pImageBinds + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_37;
        vkStream->alloc((void**)&cgen_var_37, forMarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pSignalSemaphores, cgen_var_37, forMarshaling->signalSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_37, forMarshaling->signalSemaphoreCount * 8);
    }
}

void unmarshal_VkBindSparseInfo(
    VulkanStreamGuest* vkStream,
    VkBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_38;
        vkStream->alloc((void**)&cgen_var_38, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_38, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_38, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->bufferBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bufferBindCount; ++i)
    {
        unmarshal_VkSparseBufferMemoryBindInfo(vkStream, (VkSparseBufferMemoryBindInfo*)(forUnmarshaling->pBufferBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageOpaqueBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageOpaqueBindCount; ++i)
    {
        unmarshal_VkSparseImageOpaqueMemoryBindInfo(vkStream, (VkSparseImageOpaqueMemoryBindInfo*)(forUnmarshaling->pImageOpaqueBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->imageBindCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->imageBindCount; ++i)
    {
        unmarshal_VkSparseImageMemoryBindInfo(vkStream, (VkSparseImageMemoryBindInfo*)(forUnmarshaling->pImageBinds + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    if (forUnmarshaling->signalSemaphoreCount)
    {
        uint64_t* cgen_var_39;
        vkStream->alloc((void**)&cgen_var_39, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_39, forUnmarshaling->signalSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_39, (VkSemaphore*)forUnmarshaling->pSignalSemaphores, forUnmarshaling->signalSemaphoreCount);
    }
}

void marshal_VkFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFenceCreateFlags*)&forMarshaling->flags, sizeof(VkFenceCreateFlags));
}

void unmarshal_VkFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFenceCreateFlags*)&forUnmarshaling->flags, sizeof(VkFenceCreateFlags));
}

void marshal_VkSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSemaphoreCreateFlags*)&forMarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

void unmarshal_VkSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    VkSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSemaphoreCreateFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreCreateFlags));
}

void marshal_VkEventCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkEventCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkEventCreateFlags*)&forMarshaling->flags, sizeof(VkEventCreateFlags));
}

void unmarshal_VkEventCreateInfo(
    VulkanStreamGuest* vkStream,
    VkEventCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkEventCreateFlags*)&forUnmarshaling->flags, sizeof(VkEventCreateFlags));
}

void marshal_VkQueryPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkQueryPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkQueryPoolCreateFlags*)&forMarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->write((VkQueryType*)&forMarshaling->queryType, sizeof(VkQueryType));
    vkStream->write((uint32_t*)&forMarshaling->queryCount, sizeof(uint32_t));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkQueryPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkQueryPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkQueryPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkQueryPoolCreateFlags));
    vkStream->read((VkQueryType*)&forUnmarshaling->queryType, sizeof(VkQueryType));
    vkStream->read((uint32_t*)&forUnmarshaling->queryCount, sizeof(uint32_t));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void marshal_VkBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_40 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_40);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void unmarshal_VkBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const uint32_t* check_pQueueFamilyIndices;
    check_pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        if (!(check_pQueueFamilyIndices))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pQueueFamilyIndices inconsistent between guest and host\n");
        }
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
}

void marshal_VkBufferViewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkBufferViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBufferViewCreateFlags*)&forMarshaling->flags, sizeof(VkBufferViewCreateFlags));
    uint64_t cgen_var_42;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_42, 1);
    vkStream->write((uint64_t*)&cgen_var_42, 1 * 8);
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferViewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkBufferViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferViewCreateFlags));
    uint64_t cgen_var_43;
    vkStream->read((uint64_t*)&cgen_var_43, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_43, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

void marshal_VkImageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->write((VkImageType*)&forMarshaling->imageType, sizeof(VkImageType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->mipLevels, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_44 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_44);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
}

void unmarshal_VkImageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
    vkStream->read((VkImageType*)&forUnmarshaling->imageType, sizeof(VkImageType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevels, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->arrayLayers, sizeof(uint32_t));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->sharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const uint32_t* check_pQueueFamilyIndices;
    check_pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        if (!(check_pQueueFamilyIndices))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pQueueFamilyIndices inconsistent between guest and host\n");
        }
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
}

void marshal_VkSubresourceLayout(
    VulkanStreamGuest* vkStream,
    const VkSubresourceLayout* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->depthPitch, sizeof(VkDeviceSize));
}

void unmarshal_VkSubresourceLayout(
    VulkanStreamGuest* vkStream,
    VkSubresourceLayout* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->rowPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->arrayPitch, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->depthPitch, sizeof(VkDeviceSize));
}

void marshal_VkComponentMapping(
    VulkanStreamGuest* vkStream,
    const VkComponentMapping* forMarshaling)
{
    vkStream->write((VkComponentSwizzle*)&forMarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->write((VkComponentSwizzle*)&forMarshaling->a, sizeof(VkComponentSwizzle));
}

void unmarshal_VkComponentMapping(
    VulkanStreamGuest* vkStream,
    VkComponentMapping* forUnmarshaling)
{
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->r, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->g, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->b, sizeof(VkComponentSwizzle));
    vkStream->read((VkComponentSwizzle*)&forUnmarshaling->a, sizeof(VkComponentSwizzle));
}

void marshal_VkImageSubresourceRange(
    VulkanStreamGuest* vkStream,
    const VkImageSubresourceRange* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->levelCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceRange(
    VulkanStreamGuest* vkStream,
    VkImageSubresourceRange* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->baseMipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->levelCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageViewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageViewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageViewCreateFlags*)&forMarshaling->flags, sizeof(VkImageViewCreateFlags));
    uint64_t cgen_var_46;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_46, 1);
    vkStream->write((uint64_t*)&cgen_var_46, 1 * 8);
    vkStream->write((VkImageViewType*)&forMarshaling->viewType, sizeof(VkImageViewType));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageViewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkImageViewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageViewCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageViewCreateFlags));
    uint64_t cgen_var_47;
    vkStream->read((uint64_t*)&cgen_var_47, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_47, (VkImage*)&forUnmarshaling->image, 1);
    vkStream->read((VkImageViewType*)&forUnmarshaling->viewType, sizeof(VkImageViewType));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

void marshal_VkShaderModuleCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkShaderModuleCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkShaderModuleCreateFlags*)&forMarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    uint64_t cgen_var_48 = (uint64_t)forMarshaling->codeSize;
    vkStream->putBe64(cgen_var_48);
    vkStream->write((const uint32_t*)forMarshaling->pCode, (forMarshaling->codeSize / 4) * sizeof(const uint32_t));
}

void unmarshal_VkShaderModuleCreateInfo(
    VulkanStreamGuest* vkStream,
    VkShaderModuleCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkShaderModuleCreateFlags*)&forUnmarshaling->flags, sizeof(VkShaderModuleCreateFlags));
    forUnmarshaling->codeSize = (size_t)vkStream->getBe64();
    vkStream->read((uint32_t*)forUnmarshaling->pCode, (forUnmarshaling->codeSize / 4) * sizeof(const uint32_t));
}

void marshal_VkPipelineCacheCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineCacheCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineCacheCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    uint64_t cgen_var_50 = (uint64_t)forMarshaling->initialDataSize;
    vkStream->putBe64(cgen_var_50);
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkPipelineCacheCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineCacheCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCacheCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCacheCreateFlags));
    forUnmarshaling->initialDataSize = (size_t)vkStream->getBe64();
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

void marshal_VkSpecializationMapEntry(
    VulkanStreamGuest* vkStream,
    const VkSpecializationMapEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->constantID, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    uint64_t cgen_var_52 = (uint64_t)forMarshaling->size;
    vkStream->putBe64(cgen_var_52);
}

void unmarshal_VkSpecializationMapEntry(
    VulkanStreamGuest* vkStream,
    VkSpecializationMapEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->constantID, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    forUnmarshaling->size = (size_t)vkStream->getBe64();
}

void marshal_VkSpecializationInfo(
    VulkanStreamGuest* vkStream,
    const VkSpecializationInfo* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->mapEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->mapEntryCount; ++i)
    {
        marshal_VkSpecializationMapEntry(vkStream, (const VkSpecializationMapEntry*)(forMarshaling->pMapEntries + i));
    }
    uint64_t cgen_var_54 = (uint64_t)forMarshaling->dataSize;
    vkStream->putBe64(cgen_var_54);
    vkStream->write((const void*)forMarshaling->pData, forMarshaling->dataSize * sizeof(const uint8_t));
}

void unmarshal_VkSpecializationInfo(
    VulkanStreamGuest* vkStream,
    VkSpecializationInfo* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->mapEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->mapEntryCount; ++i)
    {
        unmarshal_VkSpecializationMapEntry(vkStream, (VkSpecializationMapEntry*)(forUnmarshaling->pMapEntries + i));
    }
    forUnmarshaling->dataSize = (size_t)vkStream->getBe64();
    vkStream->read((void*)forUnmarshaling->pData, forUnmarshaling->dataSize * sizeof(const uint8_t));
}

void marshal_VkPipelineShaderStageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineShaderStageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineShaderStageCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->write((VkShaderStageFlagBits*)&forMarshaling->stage, sizeof(VkShaderStageFlagBits));
    uint64_t cgen_var_56;
    vkStream->handleMapping()->mapHandles_VkShaderModule_u64(&forMarshaling->module, &cgen_var_56, 1);
    vkStream->write((uint64_t*)&cgen_var_56, 1 * 8);
    vkStream->putString(forMarshaling->pName);
    // WARNING PTR CHECK
    uint64_t cgen_var_57 = (uint64_t)(uintptr_t)forMarshaling->pSpecializationInfo;
    vkStream->putBe64(cgen_var_57);
    if (forMarshaling->pSpecializationInfo)
    {
        marshal_VkSpecializationInfo(vkStream, (const VkSpecializationInfo*)(forMarshaling->pSpecializationInfo));
    }
}

void unmarshal_VkPipelineShaderStageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineShaderStageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineShaderStageCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineShaderStageCreateFlags));
    vkStream->read((VkShaderStageFlagBits*)&forUnmarshaling->stage, sizeof(VkShaderStageFlagBits));
    uint64_t cgen_var_58;
    vkStream->read((uint64_t*)&cgen_var_58, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkShaderModule(&cgen_var_58, (VkShaderModule*)&forUnmarshaling->module, 1);
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pName);
    // WARNING PTR CHECK
    const VkSpecializationInfo* check_pSpecializationInfo;
    check_pSpecializationInfo = (const VkSpecializationInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSpecializationInfo)
    {
        if (!(check_pSpecializationInfo))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pSpecializationInfo inconsistent between guest and host\n");
        }
        unmarshal_VkSpecializationInfo(vkStream, (VkSpecializationInfo*)(forUnmarshaling->pSpecializationInfo));
    }
}

void marshal_VkVertexInputBindingDescription(
    VulkanStreamGuest* vkStream,
    const VkVertexInputBindingDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->stride, sizeof(uint32_t));
    vkStream->write((VkVertexInputRate*)&forMarshaling->inputRate, sizeof(VkVertexInputRate));
}

void unmarshal_VkVertexInputBindingDescription(
    VulkanStreamGuest* vkStream,
    VkVertexInputBindingDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->stride, sizeof(uint32_t));
    vkStream->read((VkVertexInputRate*)&forUnmarshaling->inputRate, sizeof(VkVertexInputRate));
}

void marshal_VkVertexInputAttributeDescription(
    VulkanStreamGuest* vkStream,
    const VkVertexInputAttributeDescription* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->location, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
}

void unmarshal_VkVertexInputAttributeDescription(
    VulkanStreamGuest* vkStream,
    VkVertexInputAttributeDescription* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->location, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineVertexInputStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineVertexInputStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDescriptionCount; ++i)
    {
        marshal_VkVertexInputBindingDescription(vkStream, (const VkVertexInputBindingDescription*)(forMarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexAttributeDescriptionCount; ++i)
    {
        marshal_VkVertexInputAttributeDescription(vkStream, (const VkVertexInputAttributeDescription*)(forMarshaling->pVertexAttributeDescriptions + i));
    }
}

void unmarshal_VkPipelineVertexInputStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineVertexInputStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineVertexInputStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineVertexInputStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputBindingDescription(vkStream, (VkVertexInputBindingDescription*)(forUnmarshaling->pVertexBindingDescriptions + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->vertexAttributeDescriptionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexAttributeDescriptionCount; ++i)
    {
        unmarshal_VkVertexInputAttributeDescription(vkStream, (VkVertexInputAttributeDescription*)(forUnmarshaling->pVertexAttributeDescriptions + i));
    }
}

void marshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineInputAssemblyStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineInputAssemblyStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->write((VkPrimitiveTopology*)&forMarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->write((VkBool32*)&forMarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineInputAssemblyStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineInputAssemblyStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineInputAssemblyStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineInputAssemblyStateCreateFlags));
    vkStream->read((VkPrimitiveTopology*)&forUnmarshaling->topology, sizeof(VkPrimitiveTopology));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveRestartEnable, sizeof(VkBool32));
}

void marshal_VkPipelineTessellationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineTessellationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineTessellationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->patchControlPoints, sizeof(uint32_t));
}

void unmarshal_VkPipelineTessellationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineTessellationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineTessellationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineTessellationStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->patchControlPoints, sizeof(uint32_t));
}

void marshal_VkViewport(
    VulkanStreamGuest* vkStream,
    const VkViewport* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
    vkStream->write((float*)&forMarshaling->width, sizeof(float));
    vkStream->write((float*)&forMarshaling->height, sizeof(float));
    vkStream->write((float*)&forMarshaling->minDepth, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepth, sizeof(float));
}

void unmarshal_VkViewport(
    VulkanStreamGuest* vkStream,
    VkViewport* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->width, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->height, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minDepth, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepth, sizeof(float));
}

void marshal_VkOffset2D(
    VulkanStreamGuest* vkStream,
    const VkOffset2D* forMarshaling)
{
    vkStream->write((int32_t*)&forMarshaling->x, sizeof(int32_t));
    vkStream->write((int32_t*)&forMarshaling->y, sizeof(int32_t));
}

void unmarshal_VkOffset2D(
    VulkanStreamGuest* vkStream,
    VkOffset2D* forUnmarshaling)
{
    vkStream->read((int32_t*)&forUnmarshaling->x, sizeof(int32_t));
    vkStream->read((int32_t*)&forUnmarshaling->y, sizeof(int32_t));
}

void marshal_VkExtent2D(
    VulkanStreamGuest* vkStream,
    const VkExtent2D* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
}

void unmarshal_VkExtent2D(
    VulkanStreamGuest* vkStream,
    VkExtent2D* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
}

void marshal_VkRect2D(
    VulkanStreamGuest* vkStream,
    const VkRect2D* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
}

void unmarshal_VkRect2D(
    VulkanStreamGuest* vkStream,
    VkRect2D* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
}

void marshal_VkPipelineViewportStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineViewportStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_60 = (uint64_t)(uintptr_t)forMarshaling->pViewports;
    vkStream->putBe64(cgen_var_60);
    if (forMarshaling->pViewports)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewport(vkStream, (const VkViewport*)(forMarshaling->pViewports + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->scissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_61 = (uint64_t)(uintptr_t)forMarshaling->pScissors;
    vkStream->putBe64(cgen_var_61);
    if (forMarshaling->pScissors)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->scissorCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pScissors + i));
        }
    }
}

void unmarshal_VkPipelineViewportStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineViewportStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineViewportStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineViewportStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkViewport* check_pViewports;
    check_pViewports = (const VkViewport*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewports)
    {
        if (!(check_pViewports))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pViewports inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewport(vkStream, (VkViewport*)(forUnmarshaling->pViewports + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->scissorCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkRect2D* check_pScissors;
    check_pScissors = (const VkRect2D*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pScissors)
    {
        if (!(check_pScissors))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pScissors inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->scissorCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pScissors + i));
        }
    }
}

void marshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineRasterizationStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->write((VkPolygonMode*)&forMarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->write((VkCullModeFlags*)&forMarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->write((VkFrontFace*)&forMarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->write((VkBool32*)&forMarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasClamp, sizeof(float));
    vkStream->write((float*)&forMarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->write((float*)&forMarshaling->lineWidth, sizeof(float));
}

void unmarshal_VkPipelineRasterizationStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineRasterizationStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthClampEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->rasterizerDiscardEnable, sizeof(VkBool32));
    vkStream->read((VkPolygonMode*)&forUnmarshaling->polygonMode, sizeof(VkPolygonMode));
    vkStream->read((VkCullModeFlags*)&forUnmarshaling->cullMode, sizeof(VkCullModeFlags));
    vkStream->read((VkFrontFace*)&forUnmarshaling->frontFace, sizeof(VkFrontFace));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBiasEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->depthBiasConstantFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasClamp, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->depthBiasSlopeFactor, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->lineWidth, sizeof(float));
}

void marshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineMultisampleStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineMultisampleStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkBool32*)&forMarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->minSampleShading, sizeof(float));
    // WARNING PTR CHECK
    uint64_t cgen_var_64 = (uint64_t)(uintptr_t)forMarshaling->pSampleMask;
    vkStream->putBe64(cgen_var_64);
    if (forMarshaling->pSampleMask)
    {
        vkStream->write((const VkSampleMask*)forMarshaling->pSampleMask, (((forMarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->write((VkBool32*)&forMarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void unmarshal_VkPipelineMultisampleStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineMultisampleStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineMultisampleStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineMultisampleStateCreateFlags));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->rasterizationSamples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkBool32*)&forUnmarshaling->sampleShadingEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->minSampleShading, sizeof(float));
    // WARNING PTR CHECK
    const VkSampleMask* check_pSampleMask;
    check_pSampleMask = (const VkSampleMask*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSampleMask)
    {
        if (!(check_pSampleMask))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pSampleMask inconsistent between guest and host\n");
        }
        vkStream->read((VkSampleMask*)forUnmarshaling->pSampleMask, (((forUnmarshaling->rasterizationSamples) + 31) / 32) * sizeof(const VkSampleMask));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToCoverageEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->alphaToOneEnable, sizeof(VkBool32));
}

void marshal_VkStencilOpState(
    VulkanStreamGuest* vkStream,
    const VkStencilOpState* forMarshaling)
{
    vkStream->write((VkStencilOp*)&forMarshaling->failOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->passOp, sizeof(VkStencilOp));
    vkStream->write((VkStencilOp*)&forMarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((uint32_t*)&forMarshaling->compareMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->writeMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->reference, sizeof(uint32_t));
}

void unmarshal_VkStencilOpState(
    VulkanStreamGuest* vkStream,
    VkStencilOpState* forUnmarshaling)
{
    vkStream->read((VkStencilOp*)&forUnmarshaling->failOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->passOp, sizeof(VkStencilOp));
    vkStream->read((VkStencilOp*)&forUnmarshaling->depthFailOp, sizeof(VkStencilOp));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((uint32_t*)&forUnmarshaling->compareMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->writeMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->reference, sizeof(uint32_t));
}

void marshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineDepthStencilStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineDepthStencilStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->write((VkBool32*)&forMarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->stencilTestEnable, sizeof(VkBool32));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->front));
    marshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forMarshaling->back));
    vkStream->write((float*)&forMarshaling->minDepthBounds, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxDepthBounds, sizeof(float));
}

void unmarshal_VkPipelineDepthStencilStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineDepthStencilStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDepthStencilStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDepthStencilStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->depthTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->depthWriteEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->depthCompareOp, sizeof(VkCompareOp));
    vkStream->read((VkBool32*)&forUnmarshaling->depthBoundsTestEnable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->stencilTestEnable, sizeof(VkBool32));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->front));
    unmarshal_VkStencilOpState(vkStream, (VkStencilOpState*)(&forUnmarshaling->back));
    vkStream->read((float*)&forUnmarshaling->minDepthBounds, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxDepthBounds, sizeof(float));
}

void marshal_VkPipelineColorBlendAttachmentState(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendAttachmentState* forMarshaling)
{
    vkStream->write((VkBool32*)&forMarshaling->blendEnable, sizeof(VkBool32));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkBlendFactor*)&forMarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendFactor*)&forMarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->write((VkBlendOp*)&forMarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->write((VkColorComponentFlags*)&forMarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void unmarshal_VkPipelineColorBlendAttachmentState(
    VulkanStreamGuest* vkStream,
    VkPipelineColorBlendAttachmentState* forUnmarshaling)
{
    vkStream->read((VkBool32*)&forUnmarshaling->blendEnable, sizeof(VkBool32));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstColorBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->colorBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->srcAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendFactor*)&forUnmarshaling->dstAlphaBlendFactor, sizeof(VkBlendFactor));
    vkStream->read((VkBlendOp*)&forUnmarshaling->alphaBlendOp, sizeof(VkBlendOp));
    vkStream->read((VkColorComponentFlags*)&forUnmarshaling->colorWriteMask, sizeof(VkColorComponentFlags));
}

void marshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineColorBlendStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->write((VkBool32*)&forMarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->write((VkLogicOp*)&forMarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkPipelineColorBlendAttachmentState(vkStream, (const VkPipelineColorBlendAttachmentState*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((float*)forMarshaling->blendConstants, 4 * sizeof(float));
}

void unmarshal_VkPipelineColorBlendStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineColorBlendStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineColorBlendStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineColorBlendStateCreateFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->logicOpEnable, sizeof(VkBool32));
    vkStream->read((VkLogicOp*)&forUnmarshaling->logicOp, sizeof(VkLogicOp));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkPipelineColorBlendAttachmentState(vkStream, (VkPipelineColorBlendAttachmentState*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((float*)forUnmarshaling->blendConstants, 4 * sizeof(float));
}

void marshal_VkPipelineDynamicStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineDynamicStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineDynamicStateCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->write((const VkDynamicState*)forMarshaling->pDynamicStates, forMarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void unmarshal_VkPipelineDynamicStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineDynamicStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDynamicStateCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineDynamicStateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->dynamicStateCount, sizeof(uint32_t));
    vkStream->read((VkDynamicState*)forUnmarshaling->pDynamicStates, forUnmarshaling->dynamicStateCount * sizeof(const VkDynamicState));
}

void marshal_VkGraphicsPipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkGraphicsPipelineCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->stageCount; ++i)
    {
        marshal_VkPipelineShaderStageCreateInfo(vkStream, (const VkPipelineShaderStageCreateInfo*)(forMarshaling->pStages + i));
    }
    marshal_VkPipelineVertexInputStateCreateInfo(vkStream, (const VkPipelineVertexInputStateCreateInfo*)(forMarshaling->pVertexInputState));
    marshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (const VkPipelineInputAssemblyStateCreateInfo*)(forMarshaling->pInputAssemblyState));
    // WARNING PTR CHECK
    uint64_t cgen_var_66 = (uint64_t)(uintptr_t)forMarshaling->pTessellationState;
    vkStream->putBe64(cgen_var_66);
    if (forMarshaling->pTessellationState)
    {
        marshal_VkPipelineTessellationStateCreateInfo(vkStream, (const VkPipelineTessellationStateCreateInfo*)(forMarshaling->pTessellationState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_67 = (uint64_t)(uintptr_t)forMarshaling->pViewportState;
    vkStream->putBe64(cgen_var_67);
    if (forMarshaling->pViewportState)
    {
        marshal_VkPipelineViewportStateCreateInfo(vkStream, (const VkPipelineViewportStateCreateInfo*)(forMarshaling->pViewportState));
    }
    marshal_VkPipelineRasterizationStateCreateInfo(vkStream, (const VkPipelineRasterizationStateCreateInfo*)(forMarshaling->pRasterizationState));
    // WARNING PTR CHECK
    uint64_t cgen_var_68 = (uint64_t)(uintptr_t)forMarshaling->pMultisampleState;
    vkStream->putBe64(cgen_var_68);
    if (forMarshaling->pMultisampleState)
    {
        marshal_VkPipelineMultisampleStateCreateInfo(vkStream, (const VkPipelineMultisampleStateCreateInfo*)(forMarshaling->pMultisampleState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_69 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilState;
    vkStream->putBe64(cgen_var_69);
    if (forMarshaling->pDepthStencilState)
    {
        marshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (const VkPipelineDepthStencilStateCreateInfo*)(forMarshaling->pDepthStencilState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_70 = (uint64_t)(uintptr_t)forMarshaling->pColorBlendState;
    vkStream->putBe64(cgen_var_70);
    if (forMarshaling->pColorBlendState)
    {
        marshal_VkPipelineColorBlendStateCreateInfo(vkStream, (const VkPipelineColorBlendStateCreateInfo*)(forMarshaling->pColorBlendState));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_71 = (uint64_t)(uintptr_t)forMarshaling->pDynamicState;
    vkStream->putBe64(cgen_var_71);
    if (forMarshaling->pDynamicState)
    {
        marshal_VkPipelineDynamicStateCreateInfo(vkStream, (const VkPipelineDynamicStateCreateInfo*)(forMarshaling->pDynamicState));
    }
    uint64_t cgen_var_72;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_72, 1);
    vkStream->write((uint64_t*)&cgen_var_72, 1 * 8);
    uint64_t cgen_var_73;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_73, 1);
    vkStream->write((uint64_t*)&cgen_var_73, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_74;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_74, 1);
    vkStream->write((uint64_t*)&cgen_var_74, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkGraphicsPipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    VkGraphicsPipelineCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->stageCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->stageCount; ++i)
    {
        unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(forUnmarshaling->pStages + i));
    }
    unmarshal_VkPipelineVertexInputStateCreateInfo(vkStream, (VkPipelineVertexInputStateCreateInfo*)(forUnmarshaling->pVertexInputState));
    unmarshal_VkPipelineInputAssemblyStateCreateInfo(vkStream, (VkPipelineInputAssemblyStateCreateInfo*)(forUnmarshaling->pInputAssemblyState));
    // WARNING PTR CHECK
    const VkPipelineTessellationStateCreateInfo* check_pTessellationState;
    check_pTessellationState = (const VkPipelineTessellationStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTessellationState)
    {
        if (!(check_pTessellationState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pTessellationState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineTessellationStateCreateInfo(vkStream, (VkPipelineTessellationStateCreateInfo*)(forUnmarshaling->pTessellationState));
    }
    // WARNING PTR CHECK
    const VkPipelineViewportStateCreateInfo* check_pViewportState;
    check_pViewportState = (const VkPipelineViewportStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportState)
    {
        if (!(check_pViewportState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pViewportState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineViewportStateCreateInfo(vkStream, (VkPipelineViewportStateCreateInfo*)(forUnmarshaling->pViewportState));
    }
    unmarshal_VkPipelineRasterizationStateCreateInfo(vkStream, (VkPipelineRasterizationStateCreateInfo*)(forUnmarshaling->pRasterizationState));
    // WARNING PTR CHECK
    const VkPipelineMultisampleStateCreateInfo* check_pMultisampleState;
    check_pMultisampleState = (const VkPipelineMultisampleStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pMultisampleState)
    {
        if (!(check_pMultisampleState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pMultisampleState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineMultisampleStateCreateInfo(vkStream, (VkPipelineMultisampleStateCreateInfo*)(forUnmarshaling->pMultisampleState));
    }
    // WARNING PTR CHECK
    const VkPipelineDepthStencilStateCreateInfo* check_pDepthStencilState;
    check_pDepthStencilState = (const VkPipelineDepthStencilStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilState)
    {
        if (!(check_pDepthStencilState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pDepthStencilState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineDepthStencilStateCreateInfo(vkStream, (VkPipelineDepthStencilStateCreateInfo*)(forUnmarshaling->pDepthStencilState));
    }
    // WARNING PTR CHECK
    const VkPipelineColorBlendStateCreateInfo* check_pColorBlendState;
    check_pColorBlendState = (const VkPipelineColorBlendStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pColorBlendState)
    {
        if (!(check_pColorBlendState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pColorBlendState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineColorBlendStateCreateInfo(vkStream, (VkPipelineColorBlendStateCreateInfo*)(forUnmarshaling->pColorBlendState));
    }
    // WARNING PTR CHECK
    const VkPipelineDynamicStateCreateInfo* check_pDynamicState;
    check_pDynamicState = (const VkPipelineDynamicStateCreateInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDynamicState)
    {
        if (!(check_pDynamicState))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pDynamicState inconsistent between guest and host\n");
        }
        unmarshal_VkPipelineDynamicStateCreateInfo(vkStream, (VkPipelineDynamicStateCreateInfo*)(forUnmarshaling->pDynamicState));
    }
    uint64_t cgen_var_81;
    vkStream->read((uint64_t*)&cgen_var_81, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_81, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_82;
    vkStream->read((uint64_t*)&cgen_var_82, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_82, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_83;
    vkStream->read((uint64_t*)&cgen_var_83, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_83, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkComputePipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkComputePipelineCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineCreateFlags));
    marshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forMarshaling->stage));
    uint64_t cgen_var_84;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->layout, &cgen_var_84, 1);
    vkStream->write((uint64_t*)&cgen_var_84, 1 * 8);
    uint64_t cgen_var_85;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->basePipelineHandle, &cgen_var_85, 1);
    vkStream->write((uint64_t*)&cgen_var_85, 1 * 8);
    vkStream->write((int32_t*)&forMarshaling->basePipelineIndex, sizeof(int32_t));
}

void unmarshal_VkComputePipelineCreateInfo(
    VulkanStreamGuest* vkStream,
    VkComputePipelineCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineCreateFlags));
    unmarshal_VkPipelineShaderStageCreateInfo(vkStream, (VkPipelineShaderStageCreateInfo*)(&forUnmarshaling->stage));
    uint64_t cgen_var_86;
    vkStream->read((uint64_t*)&cgen_var_86, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_86, (VkPipelineLayout*)&forUnmarshaling->layout, 1);
    uint64_t cgen_var_87;
    vkStream->read((uint64_t*)&cgen_var_87, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_87, (VkPipeline*)&forUnmarshaling->basePipelineHandle, 1);
    vkStream->read((int32_t*)&forUnmarshaling->basePipelineIndex, sizeof(int32_t));
}

void marshal_VkPushConstantRange(
    VulkanStreamGuest* vkStream,
    const VkPushConstantRange* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->write((uint32_t*)&forMarshaling->offset, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->size, sizeof(uint32_t));
}

void unmarshal_VkPushConstantRange(
    VulkanStreamGuest* vkStream,
    VkPushConstantRange* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->offset, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->size, sizeof(uint32_t));
}

void marshal_VkPipelineLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->setLayoutCount, sizeof(uint32_t));
    if (forMarshaling->setLayoutCount)
    {
        uint64_t* cgen_var_88;
        vkStream->alloc((void**)&cgen_var_88, forMarshaling->setLayoutCount * 8);
        vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(forMarshaling->pSetLayouts, cgen_var_88, forMarshaling->setLayoutCount);
        vkStream->write((uint64_t*)cgen_var_88, forMarshaling->setLayoutCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->pushConstantRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->pushConstantRangeCount; ++i)
    {
        marshal_VkPushConstantRange(vkStream, (const VkPushConstantRange*)(forMarshaling->pPushConstantRanges + i));
    }
}

void unmarshal_VkPipelineLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkPipelineLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->setLayoutCount, sizeof(uint32_t));
    if (forUnmarshaling->setLayoutCount)
    {
        uint64_t* cgen_var_89;
        vkStream->alloc((void**)&cgen_var_89, forUnmarshaling->setLayoutCount * 8);
        vkStream->read((uint64_t*)cgen_var_89, forUnmarshaling->setLayoutCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(cgen_var_89, (VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->setLayoutCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->pushConstantRangeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->pushConstantRangeCount; ++i)
    {
        unmarshal_VkPushConstantRange(vkStream, (VkPushConstantRange*)(forUnmarshaling->pPushConstantRanges + i));
    }
}

void marshal_VkSamplerCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSamplerCreateFlags*)&forMarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->write((VkFilter*)&forMarshaling->magFilter, sizeof(VkFilter));
    vkStream->write((VkFilter*)&forMarshaling->minFilter, sizeof(VkFilter));
    vkStream->write((VkSamplerMipmapMode*)&forMarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->write((VkSamplerAddressMode*)&forMarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->write((float*)&forMarshaling->mipLodBias, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->write((float*)&forMarshaling->maxAnisotropy, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->compareEnable, sizeof(VkBool32));
    vkStream->write((VkCompareOp*)&forMarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->write((float*)&forMarshaling->minLod, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxLod, sizeof(float));
    vkStream->write((VkBorderColor*)&forMarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->write((VkBool32*)&forMarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

void unmarshal_VkSamplerCreateInfo(
    VulkanStreamGuest* vkStream,
    VkSamplerCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSamplerCreateFlags*)&forUnmarshaling->flags, sizeof(VkSamplerCreateFlags));
    vkStream->read((VkFilter*)&forUnmarshaling->magFilter, sizeof(VkFilter));
    vkStream->read((VkFilter*)&forUnmarshaling->minFilter, sizeof(VkFilter));
    vkStream->read((VkSamplerMipmapMode*)&forUnmarshaling->mipmapMode, sizeof(VkSamplerMipmapMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeU, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeV, sizeof(VkSamplerAddressMode));
    vkStream->read((VkSamplerAddressMode*)&forUnmarshaling->addressModeW, sizeof(VkSamplerAddressMode));
    vkStream->read((float*)&forUnmarshaling->mipLodBias, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->anisotropyEnable, sizeof(VkBool32));
    vkStream->read((float*)&forUnmarshaling->maxAnisotropy, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->compareEnable, sizeof(VkBool32));
    vkStream->read((VkCompareOp*)&forUnmarshaling->compareOp, sizeof(VkCompareOp));
    vkStream->read((float*)&forUnmarshaling->minLod, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxLod, sizeof(float));
    vkStream->read((VkBorderColor*)&forUnmarshaling->borderColor, sizeof(VkBorderColor));
    vkStream->read((VkBool32*)&forUnmarshaling->unnormalizedCoordinates, sizeof(VkBool32));
}

void marshal_VkDescriptorSetLayoutBinding(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutBinding* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_90 = (uint64_t)(uintptr_t)forMarshaling->pImmutableSamplers;
    vkStream->putBe64(cgen_var_90);
    if (forMarshaling->pImmutableSamplers)
    {
        if (forMarshaling->descriptorCount)
        {
            uint64_t* cgen_var_91;
            vkStream->alloc((void**)&cgen_var_91, forMarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_VkSampler_u64(forMarshaling->pImmutableSamplers, cgen_var_91, forMarshaling->descriptorCount);
            vkStream->write((uint64_t*)cgen_var_91, forMarshaling->descriptorCount * 8);
        }
    }
}

void unmarshal_VkDescriptorSetLayoutBinding(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetLayoutBinding* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
    // WARNING PTR CHECK
    const VkSampler* check_pImmutableSamplers;
    check_pImmutableSamplers = (const VkSampler*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pImmutableSamplers)
    {
        if (!(check_pImmutableSamplers))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pImmutableSamplers inconsistent between guest and host\n");
        }
        if (forUnmarshaling->descriptorCount)
        {
            uint64_t* cgen_var_93;
            vkStream->alloc((void**)&cgen_var_93, forUnmarshaling->descriptorCount * 8);
            vkStream->read((uint64_t*)cgen_var_93, forUnmarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_u64_VkSampler(cgen_var_93, (VkSampler*)forUnmarshaling->pImmutableSamplers, forUnmarshaling->descriptorCount);
        }
    }
}

void marshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDescriptorSetLayoutCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->bindingCount; ++i)
    {
        marshal_VkDescriptorSetLayoutBinding(vkStream, (const VkDescriptorSetLayoutBinding*)(forMarshaling->pBindings + i));
    }
}

void unmarshal_VkDescriptorSetLayoutCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetLayoutCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorSetLayoutCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorSetLayoutCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->bindingCount; ++i)
    {
        unmarshal_VkDescriptorSetLayoutBinding(vkStream, (VkDescriptorSetLayoutBinding*)(forUnmarshaling->pBindings + i));
    }
}

void marshal_VkDescriptorPoolSize(
    VulkanStreamGuest* vkStream,
    const VkDescriptorPoolSize* forMarshaling)
{
    vkStream->write((VkDescriptorType*)&forMarshaling->type, sizeof(VkDescriptorType));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorPoolSize(
    VulkanStreamGuest* vkStream,
    VkDescriptorPoolSize* forUnmarshaling)
{
    vkStream->read((VkDescriptorType*)&forUnmarshaling->type, sizeof(VkDescriptorType));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDescriptorPoolCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->maxSets, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->poolSizeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->poolSizeCount; ++i)
    {
        marshal_VkDescriptorPoolSize(vkStream, (const VkDescriptorPoolSize*)(forMarshaling->pPoolSizes + i));
    }
}

void unmarshal_VkDescriptorPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSets, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->poolSizeCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->poolSizeCount; ++i)
    {
        unmarshal_VkDescriptorPoolSize(vkStream, (VkDescriptorPoolSize*)(forUnmarshaling->pPoolSizes + i));
    }
}

void marshal_VkDescriptorSetAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_94;
    vkStream->handleMapping()->mapHandles_VkDescriptorPool_u64(&forMarshaling->descriptorPool, &cgen_var_94, 1);
    vkStream->write((uint64_t*)&cgen_var_94, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    if (forMarshaling->descriptorSetCount)
    {
        uint64_t* cgen_var_95;
        vkStream->alloc((void**)&cgen_var_95, forMarshaling->descriptorSetCount * 8);
        vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(forMarshaling->pSetLayouts, cgen_var_95, forMarshaling->descriptorSetCount);
        vkStream->write((uint64_t*)cgen_var_95, forMarshaling->descriptorSetCount * 8);
    }
}

void unmarshal_VkDescriptorSetAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_96;
    vkStream->read((uint64_t*)&cgen_var_96, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorPool(&cgen_var_96, (VkDescriptorPool*)&forUnmarshaling->descriptorPool, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    if (forUnmarshaling->descriptorSetCount)
    {
        uint64_t* cgen_var_97;
        vkStream->alloc((void**)&cgen_var_97, forUnmarshaling->descriptorSetCount * 8);
        vkStream->read((uint64_t*)cgen_var_97, forUnmarshaling->descriptorSetCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(cgen_var_97, (VkDescriptorSetLayout*)forUnmarshaling->pSetLayouts, forUnmarshaling->descriptorSetCount);
    }
}

void marshal_VkDescriptorImageInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorImageInfo* forMarshaling)
{
    uint64_t cgen_var_98;
    vkStream->handleMapping()->mapHandles_VkSampler_u64(&forMarshaling->sampler, &cgen_var_98, 1);
    vkStream->write((uint64_t*)&cgen_var_98, 1 * 8);
    uint64_t cgen_var_99;
    vkStream->handleMapping()->mapHandles_VkImageView_u64(&forMarshaling->imageView, &cgen_var_99, 1);
    vkStream->write((uint64_t*)&cgen_var_99, 1 * 8);
    vkStream->write((VkImageLayout*)&forMarshaling->imageLayout, sizeof(VkImageLayout));
}

void unmarshal_VkDescriptorImageInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorImageInfo* forUnmarshaling)
{
    uint64_t cgen_var_100;
    vkStream->read((uint64_t*)&cgen_var_100, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSampler(&cgen_var_100, (VkSampler*)&forUnmarshaling->sampler, 1);
    uint64_t cgen_var_101;
    vkStream->read((uint64_t*)&cgen_var_101, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImageView(&cgen_var_101, (VkImageView*)&forUnmarshaling->imageView, 1);
    vkStream->read((VkImageLayout*)&forUnmarshaling->imageLayout, sizeof(VkImageLayout));
}

void marshal_VkDescriptorBufferInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorBufferInfo* forMarshaling)
{
    uint64_t cgen_var_102;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_102, 1);
    vkStream->write((uint64_t*)&cgen_var_102, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->range, sizeof(VkDeviceSize));
}

void unmarshal_VkDescriptorBufferInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorBufferInfo* forUnmarshaling)
{
    uint64_t cgen_var_103;
    vkStream->read((uint64_t*)&cgen_var_103, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_103, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->range, sizeof(VkDeviceSize));
}

void marshal_VkWriteDescriptorSet(
    VulkanStreamGuest* vkStream,
    const VkWriteDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_104;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->dstSet, &cgen_var_104, 1);
    vkStream->write((uint64_t*)&cgen_var_104, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    // WARNING PTR CHECK
    uint64_t cgen_var_105 = (uint64_t)(uintptr_t)forMarshaling->pImageInfo;
    vkStream->putBe64(cgen_var_105);
    if (forMarshaling->pImageInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
        {
            marshal_VkDescriptorImageInfo(vkStream, (const VkDescriptorImageInfo*)(forMarshaling->pImageInfo + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_106 = (uint64_t)(uintptr_t)forMarshaling->pBufferInfo;
    vkStream->putBe64(cgen_var_106);
    if (forMarshaling->pBufferInfo)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorCount; ++i)
        {
            marshal_VkDescriptorBufferInfo(vkStream, (const VkDescriptorBufferInfo*)(forMarshaling->pBufferInfo + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_107 = (uint64_t)(uintptr_t)forMarshaling->pTexelBufferView;
    vkStream->putBe64(cgen_var_107);
    if (forMarshaling->pTexelBufferView)
    {
        if (forMarshaling->descriptorCount)
        {
            uint64_t* cgen_var_108;
            vkStream->alloc((void**)&cgen_var_108, forMarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_VkBufferView_u64(forMarshaling->pTexelBufferView, cgen_var_108, forMarshaling->descriptorCount);
            vkStream->write((uint64_t*)cgen_var_108, forMarshaling->descriptorCount * 8);
        }
    }
}

void unmarshal_VkWriteDescriptorSet(
    VulkanStreamGuest* vkStream,
    VkWriteDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_109;
    vkStream->read((uint64_t*)&cgen_var_109, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_109, (VkDescriptorSet*)&forUnmarshaling->dstSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    // WARNING PTR CHECK
    const VkDescriptorImageInfo* check_pImageInfo;
    check_pImageInfo = (const VkDescriptorImageInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pImageInfo)
    {
        if (!(check_pImageInfo))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pImageInfo inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
        {
            unmarshal_VkDescriptorImageInfo(vkStream, (VkDescriptorImageInfo*)(forUnmarshaling->pImageInfo + i));
        }
    }
    // WARNING PTR CHECK
    const VkDescriptorBufferInfo* check_pBufferInfo;
    check_pBufferInfo = (const VkDescriptorBufferInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pBufferInfo)
    {
        if (!(check_pBufferInfo))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pBufferInfo inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorCount; ++i)
        {
            unmarshal_VkDescriptorBufferInfo(vkStream, (VkDescriptorBufferInfo*)(forUnmarshaling->pBufferInfo + i));
        }
    }
    // WARNING PTR CHECK
    const VkBufferView* check_pTexelBufferView;
    check_pTexelBufferView = (const VkBufferView*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTexelBufferView)
    {
        if (!(check_pTexelBufferView))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pTexelBufferView inconsistent between guest and host\n");
        }
        if (forUnmarshaling->descriptorCount)
        {
            uint64_t* cgen_var_113;
            vkStream->alloc((void**)&cgen_var_113, forUnmarshaling->descriptorCount * 8);
            vkStream->read((uint64_t*)cgen_var_113, forUnmarshaling->descriptorCount * 8);
            vkStream->handleMapping()->mapHandles_u64_VkBufferView(cgen_var_113, (VkBufferView*)forUnmarshaling->pTexelBufferView, forUnmarshaling->descriptorCount);
        }
    }
}

void marshal_VkCopyDescriptorSet(
    VulkanStreamGuest* vkStream,
    const VkCopyDescriptorSet* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_114;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->srcSet, &cgen_var_114, 1);
    vkStream->write((uint64_t*)&cgen_var_114, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->srcBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->srcArrayElement, sizeof(uint32_t));
    uint64_t cgen_var_115;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->dstSet, &cgen_var_115, 1);
    vkStream->write((uint64_t*)&cgen_var_115, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
}

void unmarshal_VkCopyDescriptorSet(
    VulkanStreamGuest* vkStream,
    VkCopyDescriptorSet* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_116;
    vkStream->read((uint64_t*)&cgen_var_116, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_116, (VkDescriptorSet*)&forUnmarshaling->srcSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->srcBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->srcArrayElement, sizeof(uint32_t));
    uint64_t cgen_var_117;
    vkStream->read((uint64_t*)&cgen_var_117, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_117, (VkDescriptorSet*)&forUnmarshaling->dstSet, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
}

void marshal_VkFramebufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkFramebufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFramebufferCreateFlags*)&forMarshaling->flags, sizeof(VkFramebufferCreateFlags));
    uint64_t cgen_var_118;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_118, 1);
    vkStream->write((uint64_t*)&cgen_var_118, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    if (forMarshaling->attachmentCount)
    {
        uint64_t* cgen_var_119;
        vkStream->alloc((void**)&cgen_var_119, forMarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_VkImageView_u64(forMarshaling->pAttachments, cgen_var_119, forMarshaling->attachmentCount);
        vkStream->write((uint64_t*)cgen_var_119, forMarshaling->attachmentCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->width, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->height, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layers, sizeof(uint32_t));
}

void unmarshal_VkFramebufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkFramebufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFramebufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkFramebufferCreateFlags));
    uint64_t cgen_var_120;
    vkStream->read((uint64_t*)&cgen_var_120, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_120, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    if (forUnmarshaling->attachmentCount)
    {
        uint64_t* cgen_var_121;
        vkStream->alloc((void**)&cgen_var_121, forUnmarshaling->attachmentCount * 8);
        vkStream->read((uint64_t*)cgen_var_121, forUnmarshaling->attachmentCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkImageView(cgen_var_121, (VkImageView*)forUnmarshaling->pAttachments, forUnmarshaling->attachmentCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->width, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->height, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layers, sizeof(uint32_t));
}

void marshal_VkAttachmentDescription(
    VulkanStreamGuest* vkStream,
    const VkAttachmentDescription* forMarshaling)
{
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription(
    VulkanStreamGuest* vkStream,
    VkAttachmentDescription* forUnmarshaling)
{
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference(
    VulkanStreamGuest* vkStream,
    const VkAttachmentReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentReference(
    VulkanStreamGuest* vkStream,
    VkAttachmentReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
}

void marshal_VkSubpassDescription(
    VulkanStreamGuest* vkStream,
    const VkSubpassDescription* forMarshaling)
{
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_122 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    vkStream->putBe64(cgen_var_122);
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_123 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    vkStream->putBe64(cgen_var_123);
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference(vkStream, (const VkAttachmentReference*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription(
    VulkanStreamGuest* vkStream,
    VkSubpassDescription* forUnmarshaling)
{
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    const VkAttachmentReference* check_pResolveAttachments;
    check_pResolveAttachments = (const VkAttachmentReference*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResolveAttachments)
    {
        if (!(check_pResolveAttachments))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pResolveAttachments inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    const VkAttachmentReference* check_pDepthStencilAttachment;
    check_pDepthStencilAttachment = (const VkAttachmentReference*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        if (!(check_pDepthStencilAttachment))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pDepthStencilAttachment inconsistent between guest and host\n");
        }
        unmarshal_VkAttachmentReference(vkStream, (VkAttachmentReference*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency(
    VulkanStreamGuest* vkStream,
    const VkSubpassDependency* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void unmarshal_VkSubpassDependency(
    VulkanStreamGuest* vkStream,
    VkSubpassDependency* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
}

void marshal_VkRenderPassCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription(vkStream, (const VkAttachmentDescription*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription(vkStream, (const VkSubpassDescription*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency(vkStream, (const VkSubpassDependency*)(forMarshaling->pDependencies + i));
    }
}

void unmarshal_VkRenderPassCreateInfo(
    VulkanStreamGuest* vkStream,
    VkRenderPassCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription(vkStream, (VkAttachmentDescription*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription(vkStream, (VkSubpassDescription*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency(vkStream, (VkSubpassDependency*)(forUnmarshaling->pDependencies + i));
    }
}

void marshal_VkCommandPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandPoolCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkCommandPoolCreateFlags*)&forMarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
}

void unmarshal_VkCommandPoolCreateInfo(
    VulkanStreamGuest* vkStream,
    VkCommandPoolCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCommandPoolCreateFlags*)&forUnmarshaling->flags, sizeof(VkCommandPoolCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
}

void marshal_VkCommandBufferAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_126;
    vkStream->handleMapping()->mapHandles_VkCommandPool_u64(&forMarshaling->commandPool, &cgen_var_126, 1);
    vkStream->write((uint64_t*)&cgen_var_126, 1 * 8);
    vkStream->write((VkCommandBufferLevel*)&forMarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
}

void unmarshal_VkCommandBufferAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkCommandBufferAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_127;
    vkStream->read((uint64_t*)&cgen_var_127, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkCommandPool(&cgen_var_127, (VkCommandPool*)&forUnmarshaling->commandPool, 1);
    vkStream->read((VkCommandBufferLevel*)&forUnmarshaling->level, sizeof(VkCommandBufferLevel));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
}

void marshal_VkCommandBufferInheritanceInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferInheritanceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_128;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_128, 1);
    vkStream->write((uint64_t*)&cgen_var_128, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_129;
    vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(&forMarshaling->framebuffer, &cgen_var_129, 1);
    vkStream->write((uint64_t*)&cgen_var_129, 1 * 8);
    vkStream->write((VkBool32*)&forMarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->write((VkQueryControlFlags*)&forMarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->write((VkQueryPipelineStatisticFlags*)&forMarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void unmarshal_VkCommandBufferInheritanceInfo(
    VulkanStreamGuest* vkStream,
    VkCommandBufferInheritanceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_130;
    vkStream->read((uint64_t*)&cgen_var_130, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_130, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    uint64_t cgen_var_131;
    vkStream->read((uint64_t*)&cgen_var_131, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_131, (VkFramebuffer*)&forUnmarshaling->framebuffer, 1);
    vkStream->read((VkBool32*)&forUnmarshaling->occlusionQueryEnable, sizeof(VkBool32));
    vkStream->read((VkQueryControlFlags*)&forUnmarshaling->queryFlags, sizeof(VkQueryControlFlags));
    vkStream->read((VkQueryPipelineStatisticFlags*)&forUnmarshaling->pipelineStatistics, sizeof(VkQueryPipelineStatisticFlags));
}

void marshal_VkCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkCommandBufferUsageFlags*)&forMarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    // WARNING PTR CHECK
    uint64_t cgen_var_132 = (uint64_t)(uintptr_t)forMarshaling->pInheritanceInfo;
    vkStream->putBe64(cgen_var_132);
    if (forMarshaling->pInheritanceInfo)
    {
        marshal_VkCommandBufferInheritanceInfo(vkStream, (const VkCommandBufferInheritanceInfo*)(forMarshaling->pInheritanceInfo));
    }
}

void unmarshal_VkCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    VkCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkCommandBufferUsageFlags*)&forUnmarshaling->flags, sizeof(VkCommandBufferUsageFlags));
    // WARNING PTR CHECK
    const VkCommandBufferInheritanceInfo* check_pInheritanceInfo;
    check_pInheritanceInfo = (const VkCommandBufferInheritanceInfo*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pInheritanceInfo)
    {
        if (!(check_pInheritanceInfo))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pInheritanceInfo inconsistent between guest and host\n");
        }
        unmarshal_VkCommandBufferInheritanceInfo(vkStream, (VkCommandBufferInheritanceInfo*)(forUnmarshaling->pInheritanceInfo));
    }
}

void marshal_VkBufferCopy(
    VulkanStreamGuest* vkStream,
    const VkBufferCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferCopy(
    VulkanStreamGuest* vkStream,
    VkBufferCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->srcOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->dstOffset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkImageSubresourceLayers(
    VulkanStreamGuest* vkStream,
    const VkImageSubresourceLayers* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->mipLevel, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkImageSubresourceLayers(
    VulkanStreamGuest* vkStream,
    VkImageSubresourceLayers* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->mipLevel, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageCopy(
    VulkanStreamGuest* vkStream,
    const VkImageCopy* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageCopy(
    VulkanStreamGuest* vkStream,
    VkImageCopy* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkImageBlit(
    VulkanStreamGuest* vkStream,
    const VkImageBlit* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->srcOffsets + i));
    }
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        marshal_VkOffset3D(vkStream, (VkOffset3D*)(forMarshaling->dstOffsets + i));
    }
}

void unmarshal_VkImageBlit(
    VulkanStreamGuest* vkStream,
    VkImageBlit* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->srcOffsets + i));
    }
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    for (uint32_t i = 0; i < (uint32_t)2; ++i)
    {
        unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(forUnmarshaling->dstOffsets + i));
    }
}

void marshal_VkBufferImageCopy(
    VulkanStreamGuest* vkStream,
    const VkBufferImageCopy* forMarshaling)
{
    vkStream->write((VkDeviceSize*)&forMarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->bufferImageHeight, sizeof(uint32_t));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->imageSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->imageOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkBufferImageCopy(
    VulkanStreamGuest* vkStream,
    VkBufferImageCopy* forUnmarshaling)
{
    vkStream->read((VkDeviceSize*)&forUnmarshaling->bufferOffset, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferRowLength, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->bufferImageHeight, sizeof(uint32_t));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->imageSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->imageOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->imageExtent));
}

void marshal_VkClearColorValue(
    VulkanStreamGuest* vkStream,
    const VkClearColorValue* forMarshaling)
{
    vkStream->write((float*)forMarshaling->float32, 4 * sizeof(float));
}

void unmarshal_VkClearColorValue(
    VulkanStreamGuest* vkStream,
    VkClearColorValue* forUnmarshaling)
{
    vkStream->read((float*)forUnmarshaling->float32, 4 * sizeof(float));
}

void marshal_VkClearDepthStencilValue(
    VulkanStreamGuest* vkStream,
    const VkClearDepthStencilValue* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->depth, sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->stencil, sizeof(uint32_t));
}

void unmarshal_VkClearDepthStencilValue(
    VulkanStreamGuest* vkStream,
    VkClearDepthStencilValue* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->depth, sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->stencil, sizeof(uint32_t));
}

void marshal_VkClearValue(
    VulkanStreamGuest* vkStream,
    const VkClearValue* forMarshaling)
{
    marshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forMarshaling->color));
}

void unmarshal_VkClearValue(
    VulkanStreamGuest* vkStream,
    VkClearValue* forUnmarshaling)
{
    unmarshal_VkClearColorValue(vkStream, (VkClearColorValue*)(&forUnmarshaling->color));
}

void marshal_VkClearAttachment(
    VulkanStreamGuest* vkStream,
    const VkClearAttachment* forMarshaling)
{
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->write((uint32_t*)&forMarshaling->colorAttachment, sizeof(uint32_t));
    marshal_VkClearValue(vkStream, (VkClearValue*)(&forMarshaling->clearValue));
}

void unmarshal_VkClearAttachment(
    VulkanStreamGuest* vkStream,
    VkClearAttachment* forUnmarshaling)
{
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachment, sizeof(uint32_t));
    unmarshal_VkClearValue(vkStream, (VkClearValue*)(&forUnmarshaling->clearValue));
}

void marshal_VkClearRect(
    VulkanStreamGuest* vkStream,
    const VkClearRect* forMarshaling)
{
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->rect));
    vkStream->write((uint32_t*)&forMarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->layerCount, sizeof(uint32_t));
}

void unmarshal_VkClearRect(
    VulkanStreamGuest* vkStream,
    VkClearRect* forUnmarshaling)
{
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->rect));
    vkStream->read((uint32_t*)&forUnmarshaling->baseArrayLayer, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->layerCount, sizeof(uint32_t));
}

void marshal_VkImageResolve(
    VulkanStreamGuest* vkStream,
    const VkImageResolve* forMarshaling)
{
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->srcSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->srcOffset));
    marshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forMarshaling->dstSubresource));
    marshal_VkOffset3D(vkStream, (VkOffset3D*)(&forMarshaling->dstOffset));
    marshal_VkExtent3D(vkStream, (VkExtent3D*)(&forMarshaling->extent));
}

void unmarshal_VkImageResolve(
    VulkanStreamGuest* vkStream,
    VkImageResolve* forUnmarshaling)
{
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->srcSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->srcOffset));
    unmarshal_VkImageSubresourceLayers(vkStream, (VkImageSubresourceLayers*)(&forUnmarshaling->dstSubresource));
    unmarshal_VkOffset3D(vkStream, (VkOffset3D*)(&forUnmarshaling->dstOffset));
    unmarshal_VkExtent3D(vkStream, (VkExtent3D*)(&forUnmarshaling->extent));
}

void marshal_VkMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void unmarshal_VkMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
}

void marshal_VkBufferMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkBufferMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_134;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_134, 1);
    vkStream->write((uint64_t*)&cgen_var_134, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
}

void unmarshal_VkBufferMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkBufferMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_135;
    vkStream->read((uint64_t*)&cgen_var_135, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_135, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
}

void marshal_VkImageMemoryBarrier(
    VulkanStreamGuest* vkStream,
    const VkImageMemoryBarrier* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkImageLayout*)&forMarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->write((uint32_t*)&forMarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_136;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_136, 1);
    vkStream->write((uint64_t*)&cgen_var_136, 1 * 8);
    marshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forMarshaling->subresourceRange));
}

void unmarshal_VkImageMemoryBarrier(
    VulkanStreamGuest* vkStream,
    VkImageMemoryBarrier* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkImageLayout*)&forUnmarshaling->oldLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->newLayout, sizeof(VkImageLayout));
    vkStream->read((uint32_t*)&forUnmarshaling->srcQueueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstQueueFamilyIndex, sizeof(uint32_t));
    uint64_t cgen_var_137;
    vkStream->read((uint64_t*)&cgen_var_137, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_137, (VkImage*)&forUnmarshaling->image, 1);
    unmarshal_VkImageSubresourceRange(vkStream, (VkImageSubresourceRange*)(&forUnmarshaling->subresourceRange));
}

void marshal_VkRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_138;
    vkStream->handleMapping()->mapHandles_VkRenderPass_u64(&forMarshaling->renderPass, &cgen_var_138, 1);
    vkStream->write((uint64_t*)&cgen_var_138, 1 * 8);
    uint64_t cgen_var_139;
    vkStream->handleMapping()->mapHandles_VkFramebuffer_u64(&forMarshaling->framebuffer, &cgen_var_139, 1);
    vkStream->write((uint64_t*)&cgen_var_139, 1 * 8);
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->renderArea));
    vkStream->write((uint32_t*)&forMarshaling->clearValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_140 = (uint64_t)(uintptr_t)forMarshaling->pClearValues;
    vkStream->putBe64(cgen_var_140);
    if (forMarshaling->pClearValues)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->clearValueCount; ++i)
        {
            marshal_VkClearValue(vkStream, (const VkClearValue*)(forMarshaling->pClearValues + i));
        }
    }
}

void unmarshal_VkRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    VkRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_141;
    vkStream->read((uint64_t*)&cgen_var_141, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkRenderPass(&cgen_var_141, (VkRenderPass*)&forUnmarshaling->renderPass, 1);
    uint64_t cgen_var_142;
    vkStream->read((uint64_t*)&cgen_var_142, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFramebuffer(&cgen_var_142, (VkFramebuffer*)&forUnmarshaling->framebuffer, 1);
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->renderArea));
    vkStream->read((uint32_t*)&forUnmarshaling->clearValueCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkClearValue* check_pClearValues;
    check_pClearValues = (const VkClearValue*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pClearValues)
    {
        if (!(check_pClearValues))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pClearValues inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->clearValueCount; ++i)
        {
            unmarshal_VkClearValue(vkStream, (VkClearValue*)(forUnmarshaling->pClearValues + i));
        }
    }
}

void marshal_VkDispatchIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDispatchIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->x, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->y, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->z, sizeof(uint32_t));
}

void unmarshal_VkDispatchIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkDispatchIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->x, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->y, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->z, sizeof(uint32_t));
}

void marshal_VkDrawIndexedIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDrawIndexedIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->indexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstIndex, sizeof(uint32_t));
    vkStream->write((int32_t*)&forMarshaling->vertexOffset, sizeof(int32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndexedIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkDrawIndexedIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->indexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstIndex, sizeof(uint32_t));
    vkStream->read((int32_t*)&forUnmarshaling->vertexOffset, sizeof(int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkDrawIndirectCommand(
    VulkanStreamGuest* vkStream,
    const VkDrawIndirectCommand* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->vertexCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->instanceCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstVertex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->firstInstance, sizeof(uint32_t));
}

void unmarshal_VkDrawIndirectCommand(
    VulkanStreamGuest* vkStream,
    VkDrawIndirectCommand* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->vertexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->instanceCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstVertex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->firstInstance, sizeof(uint32_t));
}

void marshal_VkBaseOutStructure(
    VulkanStreamGuest* vkStream,
    const VkBaseOutStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((VkBaseOutStructure*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
}

void unmarshal_VkBaseOutStructure(
    VulkanStreamGuest* vkStream,
    VkBaseOutStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((VkBaseOutStructure*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

void marshal_VkBaseInStructure(
    VulkanStreamGuest* vkStream,
    const VkBaseInStructure* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const VkBaseInStructure*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
}

void unmarshal_VkBaseInStructure(
    VulkanStreamGuest* vkStream,
    VkBaseInStructure* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((VkBaseInStructure*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

#endif
#ifdef VK_VERSION_1_1
void marshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSubgroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->write((VkShaderStageFlags*)&forMarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->write((VkSubgroupFeatureFlags*)&forMarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->write((VkBool32*)&forMarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSubgroupProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSubgroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subgroupSize, sizeof(uint32_t));
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->supportedStages, sizeof(VkShaderStageFlags));
    vkStream->read((VkSubgroupFeatureFlags*)&forUnmarshaling->supportedOperations, sizeof(VkSubgroupFeatureFlags));
    vkStream->read((VkBool32*)&forUnmarshaling->quadOperationsInAllStages, sizeof(VkBool32));
}

void marshal_VkBindBufferMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindBufferMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_144;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_144, 1);
    vkStream->write((uint64_t*)&cgen_var_144, 1 * 8);
    uint64_t cgen_var_145;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_145, 1);
    vkStream->write((uint64_t*)&cgen_var_145, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindBufferMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkBindBufferMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_146;
    vkStream->read((uint64_t*)&cgen_var_146, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_146, (VkBuffer*)&forUnmarshaling->buffer, 1);
    uint64_t cgen_var_147;
    vkStream->read((uint64_t*)&cgen_var_147, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_147, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void marshal_VkBindImageMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_148;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_148, 1);
    vkStream->write((uint64_t*)&cgen_var_148, 1 * 8);
    uint64_t cgen_var_149;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_149, 1);
    vkStream->write((uint64_t*)&cgen_var_149, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkBindImageMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkBindImageMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_150;
    vkStream->read((uint64_t*)&cgen_var_150, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_150, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_151;
    vkStream->read((uint64_t*)&cgen_var_151, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_151, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->memoryOffset, sizeof(VkDeviceSize));
}

void marshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevice16BitStorageFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storageInputOutput16, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice16BitStorageFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDevice16BitStorageFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer16BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant16, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storageInputOutput16, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedRequirements(
    VulkanStreamGuest* vkStream,
    const VkMemoryDedicatedRequirements* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkMemoryDedicatedRequirements(
    VulkanStreamGuest* vkStream,
    VkMemoryDedicatedRequirements* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->prefersDedicatedAllocation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->requiresDedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkMemoryDedicatedAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryDedicatedAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_152;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_152, 1);
    vkStream->write((uint64_t*)&cgen_var_152, 1 * 8);
    uint64_t cgen_var_153;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_153, 1);
    vkStream->write((uint64_t*)&cgen_var_153, 1 * 8);
}

void unmarshal_VkMemoryDedicatedAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkMemoryDedicatedAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_154;
    vkStream->read((uint64_t*)&cgen_var_154, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_154, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_155;
    vkStream->read((uint64_t*)&cgen_var_155, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_155, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkMemoryAllocateFlagsInfo(
    VulkanStreamGuest* vkStream,
    const VkMemoryAllocateFlagsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkMemoryAllocateFlags*)&forMarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkMemoryAllocateFlagsInfo(
    VulkanStreamGuest* vkStream,
    VkMemoryAllocateFlagsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMemoryAllocateFlags*)&forUnmarshaling->flags, sizeof(VkMemoryAllocateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupRenderPassBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->deviceRenderAreaCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDeviceRenderAreas + i));
    }
}

void unmarshal_VkDeviceGroupRenderPassBeginInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupRenderPassBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceRenderAreaCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->deviceRenderAreaCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDeviceRenderAreas + i));
    }
}

void marshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupCommandBufferBeginInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupCommandBufferBeginInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupCommandBufferBeginInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pWaitSemaphoreDeviceIndices, forMarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCommandBufferDeviceMasks, forMarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pSignalSemaphoreDeviceIndices, forMarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void unmarshal_VkDeviceGroupSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pWaitSemaphoreDeviceIndices, forUnmarshaling->waitSemaphoreCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->commandBufferCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCommandBufferDeviceMasks, forUnmarshaling->commandBufferCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pSignalSemaphoreDeviceIndices, forUnmarshaling->signalSemaphoreCount * sizeof(const uint32_t));
}

void marshal_VkDeviceGroupBindSparseInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupBindSparseInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceGroupBindSparseInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupBindSparseInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->resourceDeviceIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryDeviceIndex, sizeof(uint32_t));
}

void marshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    const VkBindBufferMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void unmarshal_VkBindBufferMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    VkBindBufferMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
}

void marshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemoryDeviceGroupInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceIndices, forMarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->splitInstanceBindRegionCount; ++i)
    {
        marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pSplitInstanceBindRegions + i));
    }
}

void unmarshal_VkBindImageMemoryDeviceGroupInfo(
    VulkanStreamGuest* vkStream,
    VkBindImageMemoryDeviceGroupInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->deviceIndexCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceIndices, forUnmarshaling->deviceIndexCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->splitInstanceBindRegionCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->splitInstanceBindRegionCount; ++i)
    {
        unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pSplitInstanceBindRegions + i));
    }
}

void marshal_VkPhysicalDeviceGroupProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceGroupProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->write((VkPhysicalDevice*)forMarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->write((VkBool32*)&forMarshaling->subsetAllocation, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceGroupProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceGroupProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    vkStream->read((VkPhysicalDevice*)forUnmarshaling->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE * sizeof(VkPhysicalDevice));
    vkStream->read((VkBool32*)&forUnmarshaling->subsetAllocation, sizeof(VkBool32));
}

void marshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupDeviceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->physicalDeviceCount, sizeof(uint32_t));
    if (forMarshaling->physicalDeviceCount)
    {
        uint64_t* cgen_var_156;
        vkStream->alloc((void**)&cgen_var_156, forMarshaling->physicalDeviceCount * 8);
        vkStream->handleMapping()->mapHandles_VkPhysicalDevice_u64(forMarshaling->pPhysicalDevices, cgen_var_156, forMarshaling->physicalDeviceCount);
        vkStream->write((uint64_t*)cgen_var_156, forMarshaling->physicalDeviceCount * 8);
    }
}

void unmarshal_VkDeviceGroupDeviceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupDeviceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->physicalDeviceCount, sizeof(uint32_t));
    if (forUnmarshaling->physicalDeviceCount)
    {
        uint64_t* cgen_var_157;
        vkStream->alloc((void**)&cgen_var_157, forUnmarshaling->physicalDeviceCount * 8);
        vkStream->read((uint64_t*)cgen_var_157, forUnmarshaling->physicalDeviceCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkPhysicalDevice(cgen_var_157, (VkPhysicalDevice*)forUnmarshaling->pPhysicalDevices, forUnmarshaling->physicalDeviceCount);
    }
}

void marshal_VkBufferMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkBufferMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_158;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_158, 1);
    vkStream->write((uint64_t*)&cgen_var_158, 1 * 8);
}

void unmarshal_VkBufferMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkBufferMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_159;
    vkStream->read((uint64_t*)&cgen_var_159, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_159, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkImageMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkImageMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_160;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_160, 1);
    vkStream->write((uint64_t*)&cgen_var_160, 1 * 8);
}

void unmarshal_VkImageMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkImageMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_161;
    vkStream->read((uint64_t*)&cgen_var_161, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_161, (VkImage*)&forUnmarshaling->image, 1);
}

void marshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    const VkImageSparseMemoryRequirementsInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_162;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_162, 1);
    vkStream->write((uint64_t*)&cgen_var_162, 1 * 8);
}

void unmarshal_VkImageSparseMemoryRequirementsInfo2(
    VulkanStreamGuest* vkStream,
    VkImageSparseMemoryRequirementsInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_163;
    vkStream->read((uint64_t*)&cgen_var_163, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_163, (VkImage*)&forUnmarshaling->image, 1);
}

void marshal_VkMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    const VkMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    VkMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkMemoryRequirements(vkStream, (VkMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_VkSparseImageMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    const VkSparseImageMemoryRequirements2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forMarshaling->memoryRequirements));
}

void unmarshal_VkSparseImageMemoryRequirements2(
    VulkanStreamGuest* vkStream,
    VkSparseImageMemoryRequirements2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSparseImageMemoryRequirements(vkStream, (VkSparseImageMemoryRequirements*)(&forUnmarshaling->memoryRequirements));
}

void marshal_VkPhysicalDeviceFeatures2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceFeatures2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forMarshaling->features));
}

void unmarshal_VkPhysicalDeviceFeatures2(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceFeatures2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceFeatures(vkStream, (VkPhysicalDeviceFeatures*)(&forUnmarshaling->features));
}

void marshal_VkPhysicalDeviceProperties2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forMarshaling->properties));
}

void unmarshal_VkPhysicalDeviceProperties2(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceProperties(vkStream, (VkPhysicalDeviceProperties*)(&forUnmarshaling->properties));
}

void marshal_VkFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forMarshaling->formatProperties));
}

void unmarshal_VkFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkFormatProperties(vkStream, (VkFormatProperties*)(&forUnmarshaling->formatProperties));
}

void marshal_VkImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
}

void unmarshal_VkImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
}

void marshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageCreateFlags*)&forMarshaling->flags, sizeof(VkImageCreateFlags));
}

void unmarshal_VkPhysicalDeviceImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageCreateFlags*)&forUnmarshaling->flags, sizeof(VkImageCreateFlags));
}

void marshal_VkQueueFamilyProperties2(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forMarshaling->queueFamilyProperties));
}

void unmarshal_VkQueueFamilyProperties2(
    VulkanStreamGuest* vkStream,
    VkQueueFamilyProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkQueueFamilyProperties(vkStream, (VkQueueFamilyProperties*)(&forUnmarshaling->queueFamilyProperties));
}

void marshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMemoryProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forMarshaling->memoryProperties));
}

void unmarshal_VkPhysicalDeviceMemoryProperties2(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMemoryProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkPhysicalDeviceMemoryProperties(vkStream, (VkPhysicalDeviceMemoryProperties*)(&forUnmarshaling->memoryProperties));
}

void marshal_VkSparseImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    const VkSparseImageFormatProperties2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forMarshaling->properties));
}

void unmarshal_VkSparseImageFormatProperties2(
    VulkanStreamGuest* vkStream,
    VkSparseImageFormatProperties2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSparseImageFormatProperties(vkStream, (VkSparseImageFormatProperties*)(&forUnmarshaling->properties));
}

void marshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSparseImageFormatInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageType*)&forMarshaling->type, sizeof(VkImageType));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
}

void unmarshal_VkPhysicalDeviceSparseImageFormatInfo2(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSparseImageFormatInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageType*)&forUnmarshaling->type, sizeof(VkImageType));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
}

void marshal_VkPhysicalDevicePointClippingProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevicePointClippingProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPointClippingBehavior*)&forMarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void unmarshal_VkPhysicalDevicePointClippingProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDevicePointClippingProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPointClippingBehavior*)&forUnmarshaling->pointClippingBehavior, sizeof(VkPointClippingBehavior));
}

void marshal_VkInputAttachmentAspectReference(
    VulkanStreamGuest* vkStream,
    const VkInputAttachmentAspectReference* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkInputAttachmentAspectReference(
    VulkanStreamGuest* vkStream,
    VkInputAttachmentAspectReference* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentIndex, sizeof(uint32_t));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassInputAttachmentAspectCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->aspectReferenceCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->aspectReferenceCount; ++i)
    {
        marshal_VkInputAttachmentAspectReference(vkStream, (const VkInputAttachmentAspectReference*)(forMarshaling->pAspectReferences + i));
    }
}

void unmarshal_VkRenderPassInputAttachmentAspectCreateInfo(
    VulkanStreamGuest* vkStream,
    VkRenderPassInputAttachmentAspectCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->aspectReferenceCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->aspectReferenceCount; ++i)
    {
        unmarshal_VkInputAttachmentAspectReference(vkStream, (VkInputAttachmentAspectReference*)(forUnmarshaling->pAspectReferences + i));
    }
}

void marshal_VkImageViewUsageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkImageViewUsageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageUsageFlags*)&forMarshaling->usage, sizeof(VkImageUsageFlags));
}

void unmarshal_VkImageViewUsageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkImageViewUsageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->usage, sizeof(VkImageUsageFlags));
}

void marshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkPipelineTessellationDomainOriginStateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkTessellationDomainOrigin*)&forMarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void unmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkPipelineTessellationDomainOriginStateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkTessellationDomainOrigin*)&forUnmarshaling->domainOrigin, sizeof(VkTessellationDomainOrigin));
}

void marshal_VkRenderPassMultiviewCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkRenderPassMultiviewCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pViewMasks, forMarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->write((const int32_t*)forMarshaling->pViewOffsets, forMarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->write((uint32_t*)&forMarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelationMasks, forMarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassMultiviewCreateInfo(
    VulkanStreamGuest* vkStream,
    VkRenderPassMultiviewCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pViewMasks, forUnmarshaling->subpassCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    vkStream->read((int32_t*)forUnmarshaling->pViewOffsets, forUnmarshaling->dependencyCount * sizeof(const int32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->correlationMaskCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelationMasks, forUnmarshaling->correlationMaskCount * sizeof(const uint32_t));
}

void marshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->multiview, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMultiviewFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->multiview, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewGeometryShader, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->multiviewTessellationShader, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceMultiviewProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMultiviewProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewViewCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxMultiviewInstanceIndex, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceVariablePointerFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->variablePointers, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceVariablePointerFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceVariablePointerFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointersStorageBuffer, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->variablePointers, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProtectedMemoryFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->protectedMemory, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceProtectedMemoryFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedMemory, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceProtectedMemoryProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->protectedNoFault, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceProtectedMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceProtectedMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedNoFault, sizeof(VkBool32));
}

void marshal_VkDeviceQueueInfo2(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueInfo2* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceQueueCreateFlags*)&forMarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->queueIndex, sizeof(uint32_t));
}

void unmarshal_VkDeviceQueueInfo2(
    VulkanStreamGuest* vkStream,
    VkDeviceQueueInfo2* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceQueueCreateFlags*)&forUnmarshaling->flags, sizeof(VkDeviceQueueCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->queueIndex, sizeof(uint32_t));
}

void marshal_VkProtectedSubmitInfo(
    VulkanStreamGuest* vkStream,
    const VkProtectedSubmitInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->protectedSubmit, sizeof(VkBool32));
}

void unmarshal_VkProtectedSubmitInfo(
    VulkanStreamGuest* vkStream,
    VkProtectedSubmitInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->protectedSubmit, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->components));
    vkStream->write((VkChromaLocation*)&forMarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkFilter*)&forMarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->write((VkBool32*)&forMarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void unmarshal_VkSamplerYcbcrConversionCreateInfo(
    VulkanStreamGuest* vkStream,
    VkSamplerYcbcrConversionCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->ycbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->ycbcrRange, sizeof(VkSamplerYcbcrRange));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->components));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->xChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->yChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkFilter*)&forUnmarshaling->chromaFilter, sizeof(VkFilter));
    vkStream->read((VkBool32*)&forUnmarshaling->forceExplicitReconstruction, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionInfo(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_164;
    vkStream->handleMapping()->mapHandles_VkSamplerYcbcrConversion_u64(&forMarshaling->conversion, &cgen_var_164, 1);
    vkStream->write((uint64_t*)&cgen_var_164, 1 * 8);
}

void unmarshal_VkSamplerYcbcrConversionInfo(
    VulkanStreamGuest* vkStream,
    VkSamplerYcbcrConversionInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_165;
    vkStream->read((uint64_t*)&cgen_var_165, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSamplerYcbcrConversion(&cgen_var_165, (VkSamplerYcbcrConversion*)&forUnmarshaling->conversion, 1);
}

void marshal_VkBindImagePlaneMemoryInfo(
    VulkanStreamGuest* vkStream,
    const VkBindImagePlaneMemoryInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkBindImagePlaneMemoryInfo(
    VulkanStreamGuest* vkStream,
    VkBindImagePlaneMemoryInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStreamGuest* vkStream,
    const VkImagePlaneMemoryRequirementsInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageAspectFlagBits*)&forMarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void unmarshal_VkImagePlaneMemoryRequirementsInfo(
    VulkanStreamGuest* vkStream,
    VkImagePlaneMemoryRequirementsInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageAspectFlagBits*)&forUnmarshaling->planeAspect, sizeof(VkImageAspectFlagBits));
}

void marshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSamplerYcbcrConversionFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->samplerYcbcrConversion, sizeof(VkBool32));
}

void marshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkSamplerYcbcrConversionImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkSamplerYcbcrConversionImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkSamplerYcbcrConversionImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->combinedImageSamplerDescriptorCount, sizeof(uint32_t));
}

void marshal_VkDescriptorUpdateTemplateEntry(
    VulkanStreamGuest* vkStream,
    const VkDescriptorUpdateTemplateEntry* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->dstBinding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->write((VkDescriptorType*)&forMarshaling->descriptorType, sizeof(VkDescriptorType));
    uint64_t cgen_var_166 = (uint64_t)forMarshaling->offset;
    vkStream->putBe64(cgen_var_166);
    uint64_t cgen_var_167 = (uint64_t)forMarshaling->stride;
    vkStream->putBe64(cgen_var_167);
}

void unmarshal_VkDescriptorUpdateTemplateEntry(
    VulkanStreamGuest* vkStream,
    VkDescriptorUpdateTemplateEntry* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->dstBinding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstArrayElement, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorType*)&forUnmarshaling->descriptorType, sizeof(VkDescriptorType));
    forUnmarshaling->offset = (size_t)vkStream->getBe64();
    forUnmarshaling->stride = (size_t)vkStream->getBe64();
}

void marshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkDescriptorUpdateTemplateCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDescriptorUpdateTemplateCreateFlags*)&forMarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->descriptorUpdateEntryCount; ++i)
    {
        marshal_VkDescriptorUpdateTemplateEntry(vkStream, (const VkDescriptorUpdateTemplateEntry*)(forMarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->write((VkDescriptorUpdateTemplateType*)&forMarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    uint64_t cgen_var_170;
    vkStream->handleMapping()->mapHandles_VkDescriptorSetLayout_u64(&forMarshaling->descriptorSetLayout, &cgen_var_170, 1);
    vkStream->write((uint64_t*)&cgen_var_170, 1 * 8);
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_171;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->pipelineLayout, &cgen_var_171, 1);
    vkStream->write((uint64_t*)&cgen_var_171, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->set, sizeof(uint32_t));
}

void unmarshal_VkDescriptorUpdateTemplateCreateInfo(
    VulkanStreamGuest* vkStream,
    VkDescriptorUpdateTemplateCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDescriptorUpdateTemplateCreateFlags*)&forUnmarshaling->flags, sizeof(VkDescriptorUpdateTemplateCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorUpdateEntryCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->descriptorUpdateEntryCount; ++i)
    {
        unmarshal_VkDescriptorUpdateTemplateEntry(vkStream, (VkDescriptorUpdateTemplateEntry*)(forUnmarshaling->pDescriptorUpdateEntries + i));
    }
    vkStream->read((VkDescriptorUpdateTemplateType*)&forUnmarshaling->templateType, sizeof(VkDescriptorUpdateTemplateType));
    uint64_t cgen_var_172;
    vkStream->read((uint64_t*)&cgen_var_172, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSetLayout(&cgen_var_172, (VkDescriptorSetLayout*)&forUnmarshaling->descriptorSetLayout, 1);
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    uint64_t cgen_var_173;
    vkStream->read((uint64_t*)&cgen_var_173, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_173, (VkPipelineLayout*)&forUnmarshaling->pipelineLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->set, sizeof(uint32_t));
}

void marshal_VkExternalMemoryProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryProperties* forMarshaling)
{
    vkStream->write((VkExternalMemoryFeatureFlags*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryProperties(
    VulkanStreamGuest* vkStream,
    VkExternalMemoryProperties* forUnmarshaling)
{
    vkStream->read((VkExternalMemoryFeatureFlags*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalImageFormatInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalImageFormatInfo(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceExternalImageFormatInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalImageFormatProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalImageFormatProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalImageFormatProperties(
    VulkanStreamGuest* vkStream,
    VkExternalImageFormatProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalBufferInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBufferCreateFlags*)&forMarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->write((VkBufferUsageFlags*)&forMarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalBufferInfo(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceExternalBufferInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBufferCreateFlags*)&forUnmarshaling->flags, sizeof(VkBufferCreateFlags));
    vkStream->read((VkBufferUsageFlags*)&forUnmarshaling->usage, sizeof(VkBufferUsageFlags));
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void marshal_VkExternalBufferProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalBufferProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forMarshaling->externalMemoryProperties));
}

void unmarshal_VkExternalBufferProperties(
    VulkanStreamGuest* vkStream,
    VkExternalBufferProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExternalMemoryProperties(vkStream, (VkExternalMemoryProperties*)(&forUnmarshaling->externalMemoryProperties));
}

void marshal_VkPhysicalDeviceIDProperties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceIDProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint8_t*)forMarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint8_t*)forMarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->write((uint32_t*)&forMarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceIDProperties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceIDProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint8_t*)forUnmarshaling->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint8_t*)forUnmarshaling->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
    vkStream->read((uint32_t*)&forUnmarshaling->deviceNodeMask, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->deviceLUIDValid, sizeof(VkBool32));
}

void marshal_VkExternalMemoryImageCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryImageCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryImageCreateInfo(
    VulkanStreamGuest* vkStream,
    VkExternalMemoryImageCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExternalMemoryBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryBufferCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExternalMemoryBufferCreateInfo(
    VulkanStreamGuest* vkStream,
    VkExternalMemoryBufferCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkExportMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryAllocateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void unmarshal_VkExportMemoryAllocateInfo(
    VulkanStreamGuest* vkStream,
    VkExportMemoryAllocateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalFenceInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalFenceInfo(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceExternalFenceInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void marshal_VkExternalFenceProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalFenceProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->write((VkExternalFenceFeatureFlags*)&forMarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void unmarshal_VkExternalFenceProperties(
    VulkanStreamGuest* vkStream,
    VkExternalFenceProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalFenceHandleTypeFlags));
    vkStream->read((VkExternalFenceFeatureFlags*)&forUnmarshaling->externalFenceFeatures, sizeof(VkExternalFenceFeatureFlags));
}

void marshal_VkExportFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportFenceCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalFenceHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void unmarshal_VkExportFenceCreateInfo(
    VulkanStreamGuest* vkStream,
    VkExportFenceCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalFenceHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalFenceHandleTypeFlags));
}

void marshal_VkExportSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    const VkExportSemaphoreCreateInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void unmarshal_VkExportSemaphoreCreateInfo(
    VulkanStreamGuest* vkStream,
    VkExportSemaphoreCreateInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->handleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
}

void marshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalSemaphoreInfo* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkPhysicalDeviceExternalSemaphoreInfo(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceExternalSemaphoreInfo* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void marshal_VkExternalSemaphoreProperties(
    VulkanStreamGuest* vkStream,
    const VkExternalSemaphoreProperties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlags*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->write((VkExternalSemaphoreFeatureFlags*)&forMarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void unmarshal_VkExternalSemaphoreProperties(
    VulkanStreamGuest* vkStream,
    VkExternalSemaphoreProperties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlags*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalSemaphoreHandleTypeFlags));
    vkStream->read((VkExternalSemaphoreFeatureFlags*)&forUnmarshaling->externalSemaphoreFeatures, sizeof(VkExternalSemaphoreFeatureFlags));
}

void marshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMaintenance3Properties* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceMaintenance3Properties(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMaintenance3Properties* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerSetDescriptors, sizeof(uint32_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->maxMemoryAllocationSize, sizeof(VkDeviceSize));
}

void marshal_VkDescriptorSetLayoutSupport(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutSupport* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->supported, sizeof(VkBool32));
}

void unmarshal_VkDescriptorSetLayoutSupport(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetLayoutSupport* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->supported, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceShaderDrawParameterFeatures* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->shaderDrawParameters, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceShaderDrawParameterFeatures* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderDrawParameters, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_surface
void marshal_VkSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
}

void marshal_VkSurfaceFormatKHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceFormatKHR* forMarshaling)
{
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

void unmarshal_VkSurfaceFormatKHR(
    VulkanStreamGuest* vkStream,
    VkSurfaceFormatKHR* forUnmarshaling)
{
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->colorSpace, sizeof(VkColorSpaceKHR));
}

#endif
#ifdef VK_KHR_swapchain
void marshal_VkSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSwapchainCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    uint64_t cgen_var_174;
    vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&forMarshaling->surface, &cgen_var_174, 1);
    vkStream->write((uint64_t*)&cgen_var_174, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((VkFormat*)&forMarshaling->imageFormat, sizeof(VkFormat));
    vkStream->write((VkColorSpaceKHR*)&forMarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
    vkStream->write((uint32_t*)&forMarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->write((VkSharingMode*)&forMarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->write((uint32_t*)&forMarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_175 = (uint64_t)(uintptr_t)forMarshaling->pQueueFamilyIndices;
    vkStream->putBe64(cgen_var_175);
    if (forMarshaling->pQueueFamilyIndices)
    {
        vkStream->write((const uint32_t*)forMarshaling->pQueueFamilyIndices, forMarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagBitsKHR*)&forMarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->write((VkPresentModeKHR*)&forMarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->write((VkBool32*)&forMarshaling->clipped, sizeof(VkBool32));
    uint64_t cgen_var_176;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->oldSwapchain, &cgen_var_176, 1);
    vkStream->write((uint64_t*)&cgen_var_176, 1 * 8);
}

void unmarshal_VkSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSwapchainCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkSwapchainCreateFlagsKHR));
    uint64_t cgen_var_177;
    vkStream->read((uint64_t*)&cgen_var_177, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_177, (VkSurfaceKHR*)&forUnmarshaling->surface, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((VkFormat*)&forUnmarshaling->imageFormat, sizeof(VkFormat));
    vkStream->read((VkColorSpaceKHR*)&forUnmarshaling->imageColorSpace, sizeof(VkColorSpaceKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->imageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->imageUsage, sizeof(VkImageUsageFlags));
    vkStream->read((VkSharingMode*)&forUnmarshaling->imageSharingMode, sizeof(VkSharingMode));
    vkStream->read((uint32_t*)&forUnmarshaling->queueFamilyIndexCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const uint32_t* check_pQueueFamilyIndices;
    check_pQueueFamilyIndices = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueFamilyIndices)
    {
        if (!(check_pQueueFamilyIndices))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pQueueFamilyIndices inconsistent between guest and host\n");
        }
        vkStream->read((uint32_t*)forUnmarshaling->pQueueFamilyIndices, forUnmarshaling->queueFamilyIndexCount * sizeof(const uint32_t));
    }
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->preTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagBitsKHR*)&forUnmarshaling->compositeAlpha, sizeof(VkCompositeAlphaFlagBitsKHR));
    vkStream->read((VkPresentModeKHR*)&forUnmarshaling->presentMode, sizeof(VkPresentModeKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->clipped, sizeof(VkBool32));
    uint64_t cgen_var_179;
    vkStream->read((uint64_t*)&cgen_var_179, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_179, (VkSwapchainKHR*)&forUnmarshaling->oldSwapchain, 1);
}

void marshal_VkPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forMarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_180;
        vkStream->alloc((void**)&cgen_var_180, forMarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_VkSemaphore_u64(forMarshaling->pWaitSemaphores, cgen_var_180, forMarshaling->waitSemaphoreCount);
        vkStream->write((uint64_t*)cgen_var_180, forMarshaling->waitSemaphoreCount * 8);
    }
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    if (forMarshaling->swapchainCount)
    {
        uint64_t* cgen_var_181;
        vkStream->alloc((void**)&cgen_var_181, forMarshaling->swapchainCount * 8);
        vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(forMarshaling->pSwapchains, cgen_var_181, forMarshaling->swapchainCount);
        vkStream->write((uint64_t*)cgen_var_181, forMarshaling->swapchainCount * 8);
    }
    vkStream->write((const uint32_t*)forMarshaling->pImageIndices, forMarshaling->swapchainCount * sizeof(const uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_182 = (uint64_t)(uintptr_t)forMarshaling->pResults;
    vkStream->putBe64(cgen_var_182);
    if (forMarshaling->pResults)
    {
        vkStream->write((VkResult*)forMarshaling->pResults, forMarshaling->swapchainCount * sizeof(VkResult));
    }
}

void unmarshal_VkPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreCount, sizeof(uint32_t));
    if (forUnmarshaling->waitSemaphoreCount)
    {
        uint64_t* cgen_var_183;
        vkStream->alloc((void**)&cgen_var_183, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->read((uint64_t*)cgen_var_183, forUnmarshaling->waitSemaphoreCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSemaphore(cgen_var_183, (VkSemaphore*)forUnmarshaling->pWaitSemaphores, forUnmarshaling->waitSemaphoreCount);
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    if (forUnmarshaling->swapchainCount)
    {
        uint64_t* cgen_var_184;
        vkStream->alloc((void**)&cgen_var_184, forUnmarshaling->swapchainCount * 8);
        vkStream->read((uint64_t*)cgen_var_184, forUnmarshaling->swapchainCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(cgen_var_184, (VkSwapchainKHR*)forUnmarshaling->pSwapchains, forUnmarshaling->swapchainCount);
    }
    vkStream->read((uint32_t*)forUnmarshaling->pImageIndices, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    // WARNING PTR CHECK
    VkResult* check_pResults;
    check_pResults = (VkResult*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResults)
    {
        if (!(check_pResults))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pResults inconsistent between guest and host\n");
        }
        vkStream->read((VkResult*)forUnmarshaling->pResults, forUnmarshaling->swapchainCount * sizeof(VkResult));
    }
}

void marshal_VkImageSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImageSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_186;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_186, 1);
    vkStream->write((uint64_t*)&cgen_var_186, 1 * 8);
}

void unmarshal_VkImageSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImageSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_187;
    vkStream->read((uint64_t*)&cgen_var_187, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_187, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
}

void marshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkBindImageMemorySwapchainInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_188;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_188, 1);
    vkStream->write((uint64_t*)&cgen_var_188, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->imageIndex, sizeof(uint32_t));
}

void unmarshal_VkBindImageMemorySwapchainInfoKHR(
    VulkanStreamGuest* vkStream,
    VkBindImageMemorySwapchainInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_189;
    vkStream->read((uint64_t*)&cgen_var_189, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_189, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->imageIndex, sizeof(uint32_t));
}

void marshal_VkAcquireNextImageInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkAcquireNextImageInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_190;
    vkStream->handleMapping()->mapHandles_VkSwapchainKHR_u64(&forMarshaling->swapchain, &cgen_var_190, 1);
    vkStream->write((uint64_t*)&cgen_var_190, 1 * 8);
    vkStream->write((uint64_t*)&forMarshaling->timeout, sizeof(uint64_t));
    uint64_t cgen_var_191;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_191, 1);
    vkStream->write((uint64_t*)&cgen_var_191, 1 * 8);
    uint64_t cgen_var_192;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_192, 1);
    vkStream->write((uint64_t*)&cgen_var_192, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->deviceMask, sizeof(uint32_t));
}

void unmarshal_VkAcquireNextImageInfoKHR(
    VulkanStreamGuest* vkStream,
    VkAcquireNextImageInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_193;
    vkStream->read((uint64_t*)&cgen_var_193, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSwapchainKHR(&cgen_var_193, (VkSwapchainKHR*)&forUnmarshaling->swapchain, 1);
    vkStream->read((uint64_t*)&forUnmarshaling->timeout, sizeof(uint64_t));
    uint64_t cgen_var_194;
    vkStream->read((uint64_t*)&cgen_var_194, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_194, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    uint64_t cgen_var_195;
    vkStream->read((uint64_t*)&cgen_var_195, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_195, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->deviceMask, sizeof(uint32_t));
}

void marshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupPresentCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)forMarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupPresentCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupPresentCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)forUnmarshaling->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void marshal_VkDeviceGroupPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDeviceMasks, forMarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->write((VkDeviceGroupPresentModeFlagBitsKHR*)&forMarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void unmarshal_VkDeviceGroupPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDeviceMasks, forUnmarshaling->swapchainCount * sizeof(const uint32_t));
    vkStream->read((VkDeviceGroupPresentModeFlagBitsKHR*)&forUnmarshaling->mode, sizeof(VkDeviceGroupPresentModeFlagBitsKHR));
}

void marshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDeviceGroupSwapchainCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceGroupPresentModeFlagsKHR*)&forMarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

void unmarshal_VkDeviceGroupSwapchainCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkDeviceGroupSwapchainCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceGroupPresentModeFlagsKHR*)&forUnmarshaling->modes, sizeof(VkDeviceGroupPresentModeFlagsKHR));
}

#endif
#ifdef VK_KHR_display
void marshal_VkDisplayPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_196;
    vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&forMarshaling->display, &cgen_var_196, 1);
    vkStream->write((uint64_t*)&cgen_var_196, 1 * 8);
    vkStream->putString(forMarshaling->displayName);
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalDimensions));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->physicalResolution));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkBool32*)&forMarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->persistentContent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_197;
    vkStream->read((uint64_t*)&cgen_var_197, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_197, (VkDisplayKHR*)&forUnmarshaling->display, 1);
    vkStream->loadStringInPlace((char**)&forUnmarshaling->displayName);
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalDimensions));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->physicalResolution));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkBool32*)&forUnmarshaling->planeReorderPossible, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->persistentContent, sizeof(VkBool32));
}

void marshal_VkDisplayModeParametersKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeParametersKHR* forMarshaling)
{
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->visibleRegion));
    vkStream->write((uint32_t*)&forMarshaling->refreshRate, sizeof(uint32_t));
}

void unmarshal_VkDisplayModeParametersKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayModeParametersKHR* forUnmarshaling)
{
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->visibleRegion));
    vkStream->read((uint32_t*)&forUnmarshaling->refreshRate, sizeof(uint32_t));
}

void marshal_VkDisplayModePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModePropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_198;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->displayMode, &cgen_var_198, 1);
    vkStream->write((uint64_t*)&cgen_var_198, 1 * 8);
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayModePropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_199;
    vkStream->read((uint64_t*)&cgen_var_199, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_199, (VkDisplayModeKHR*)&forUnmarshaling->displayMode, 1);
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayModeCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDisplayModeCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    marshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forMarshaling->parameters));
}

void unmarshal_VkDisplayModeCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayModeCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayModeCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplayModeCreateFlagsKHR));
    unmarshal_VkDisplayModeParametersKHR(vkStream, (VkDisplayModeParametersKHR*)(&forUnmarshaling->parameters));
}

void marshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkDisplayPlaneAlphaFlagsKHR*)&forMarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minSrcPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxSrcPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minSrcExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSrcExtent));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->minDstPosition));
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->maxDstPosition));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minDstExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxDstExtent));
}

void unmarshal_VkDisplayPlaneCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPlaneCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkDisplayPlaneAlphaFlagsKHR*)&forUnmarshaling->supportedAlpha, sizeof(VkDisplayPlaneAlphaFlagsKHR));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minSrcPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxSrcPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minSrcExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSrcExtent));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->minDstPosition));
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->maxDstPosition));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minDstExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxDstExtent));
}

void marshal_VkDisplayPlanePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlanePropertiesKHR* forMarshaling)
{
    uint64_t cgen_var_200;
    vkStream->handleMapping()->mapHandles_VkDisplayKHR_u64(&forMarshaling->currentDisplay, &cgen_var_200, 1);
    vkStream->write((uint64_t*)&cgen_var_200, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->currentStackIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlanePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPlanePropertiesKHR* forUnmarshaling)
{
    uint64_t cgen_var_201;
    vkStream->read((uint64_t*)&cgen_var_201, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayKHR(&cgen_var_201, (VkDisplayKHR*)&forUnmarshaling->currentDisplay, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->currentStackIndex, sizeof(uint32_t));
}

void marshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplaySurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDisplaySurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    uint64_t cgen_var_202;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->displayMode, &cgen_var_202, 1);
    vkStream->write((uint64_t*)&cgen_var_202, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((float*)&forMarshaling->globalAlpha, sizeof(float));
    vkStream->write((VkDisplayPlaneAlphaFlagBitsKHR*)&forMarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->imageExtent));
}

void unmarshal_VkDisplaySurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkDisplaySurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplaySurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkDisplaySurfaceCreateFlagsKHR));
    uint64_t cgen_var_203;
    vkStream->read((uint64_t*)&cgen_var_203, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_203, (VkDisplayModeKHR*)&forUnmarshaling->displayMode, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->planeStackIndex, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->transform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((float*)&forUnmarshaling->globalAlpha, sizeof(float));
    vkStream->read((VkDisplayPlaneAlphaFlagBitsKHR*)&forUnmarshaling->alphaMode, sizeof(VkDisplayPlaneAlphaFlagBitsKHR));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->imageExtent));
}

#endif
#ifdef VK_KHR_display_swapchain
void marshal_VkDisplayPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPresentInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->srcRect));
    marshal_VkRect2D(vkStream, (VkRect2D*)(&forMarshaling->dstRect));
    vkStream->write((VkBool32*)&forMarshaling->persistent, sizeof(VkBool32));
}

void unmarshal_VkDisplayPresentInfoKHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPresentInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->srcRect));
    unmarshal_VkRect2D(vkStream, (VkRect2D*)(&forUnmarshaling->dstRect));
    vkStream->read((VkBool32*)&forUnmarshaling->persistent, sizeof(VkBool32));
}

#endif
#ifdef VK_KHR_xlib_surface
void marshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkXlibSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkXlibSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_204 = (uint64_t)(uintptr_t)forMarshaling->dpy;
    vkStream->putBe64(cgen_var_204);
    if (forMarshaling->dpy)
    {
        vkStream->write((Display*)forMarshaling->dpy, sizeof(Display));
    }
    vkStream->write((Window*)&forMarshaling->window, sizeof(Window));
}

void unmarshal_VkXlibSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkXlibSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkXlibSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXlibSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    Display* check_dpy;
    check_dpy = (Display*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->dpy)
    {
        if (!(check_dpy))
        {
            fprintf(stderr, "fatal: forUnmarshaling->dpy inconsistent between guest and host\n");
        }
        vkStream->read((Display*)forUnmarshaling->dpy, sizeof(Display));
    }
    vkStream->read((Window*)&forUnmarshaling->window, sizeof(Window));
}

#endif
#ifdef VK_KHR_xcb_surface
void marshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkXcbSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkXcbSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_206 = (uint64_t)(uintptr_t)forMarshaling->connection;
    vkStream->putBe64(cgen_var_206);
    if (forMarshaling->connection)
    {
        vkStream->write((xcb_connection_t*)forMarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->write((xcb_window_t*)&forMarshaling->window, sizeof(xcb_window_t));
}

void unmarshal_VkXcbSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkXcbSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkXcbSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkXcbSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    xcb_connection_t* check_connection;
    check_connection = (xcb_connection_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->connection)
    {
        if (!(check_connection))
        {
            fprintf(stderr, "fatal: forUnmarshaling->connection inconsistent between guest and host\n");
        }
        vkStream->read((xcb_connection_t*)forUnmarshaling->connection, sizeof(xcb_connection_t));
    }
    vkStream->read((xcb_window_t*)&forUnmarshaling->window, sizeof(xcb_window_t));
}

#endif
#ifdef VK_KHR_wayland_surface
void marshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWaylandSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkWaylandSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_208 = (uint64_t)(uintptr_t)forMarshaling->display;
    vkStream->putBe64(cgen_var_208);
    if (forMarshaling->display)
    {
        vkStream->write((wl_display*)forMarshaling->display, sizeof(wl_display));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_209 = (uint64_t)(uintptr_t)forMarshaling->surface;
    vkStream->putBe64(cgen_var_209);
    if (forMarshaling->surface)
    {
        vkStream->write((wl_surface*)forMarshaling->surface, sizeof(wl_surface));
    }
}

void unmarshal_VkWaylandSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkWaylandSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkWaylandSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWaylandSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    wl_display* check_display;
    check_display = (wl_display*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->display)
    {
        if (!(check_display))
        {
            fprintf(stderr, "fatal: forUnmarshaling->display inconsistent between guest and host\n");
        }
        vkStream->read((wl_display*)forUnmarshaling->display, sizeof(wl_display));
    }
    // WARNING PTR CHECK
    wl_surface* check_surface;
    check_surface = (wl_surface*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->surface)
    {
        if (!(check_surface))
        {
            fprintf(stderr, "fatal: forUnmarshaling->surface inconsistent between guest and host\n");
        }
        vkStream->read((wl_surface*)forUnmarshaling->surface, sizeof(wl_surface));
    }
}

#endif
#ifdef VK_KHR_mir_surface
void marshal_VkMirSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMirSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkMirSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkMirSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_212 = (uint64_t)(uintptr_t)forMarshaling->connection;
    vkStream->putBe64(cgen_var_212);
    if (forMarshaling->connection)
    {
        vkStream->write((MirConnection*)forMarshaling->connection, sizeof(MirConnection));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_213 = (uint64_t)(uintptr_t)forMarshaling->mirSurface;
    vkStream->putBe64(cgen_var_213);
    if (forMarshaling->mirSurface)
    {
        vkStream->write((MirSurface*)forMarshaling->mirSurface, sizeof(MirSurface));
    }
}

void unmarshal_VkMirSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkMirSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMirSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkMirSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    MirConnection* check_connection;
    check_connection = (MirConnection*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->connection)
    {
        if (!(check_connection))
        {
            fprintf(stderr, "fatal: forUnmarshaling->connection inconsistent between guest and host\n");
        }
        vkStream->read((MirConnection*)forUnmarshaling->connection, sizeof(MirConnection));
    }
    // WARNING PTR CHECK
    MirSurface* check_mirSurface;
    check_mirSurface = (MirSurface*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->mirSurface)
    {
        if (!(check_mirSurface))
        {
            fprintf(stderr, "fatal: forUnmarshaling->mirSurface inconsistent between guest and host\n");
        }
        vkStream->read((MirSurface*)forUnmarshaling->mirSurface, sizeof(MirSurface));
    }
}

#endif
#ifdef VK_KHR_android_surface
void marshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkAndroidSurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkAndroidSurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    uint64_t cgen_var_216 = (uint64_t)(uintptr_t)forMarshaling->window;
    vkStream->putBe64(cgen_var_216);
    if (forMarshaling->window)
    {
        vkStream->write((ANativeWindow*)forMarshaling->window, sizeof(ANativeWindow));
    }
}

void unmarshal_VkAndroidSurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkAndroidSurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAndroidSurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkAndroidSurfaceCreateFlagsKHR));
    // WARNING PTR CHECK
    ANativeWindow* check_window;
    check_window = (ANativeWindow*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->window)
    {
        if (!(check_window))
        {
            fprintf(stderr, "fatal: forUnmarshaling->window inconsistent between guest and host\n");
        }
        vkStream->read((ANativeWindow*)forUnmarshaling->window, sizeof(ANativeWindow));
    }
}

#endif
#ifdef VK_KHR_win32_surface
void marshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWin32SurfaceCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkWin32SurfaceCreateFlagsKHR*)&forMarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->write((HINSTANCE*)&forMarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->write((HWND*)&forMarshaling->hwnd, sizeof(HWND));
}

void unmarshal_VkWin32SurfaceCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkWin32SurfaceCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkWin32SurfaceCreateFlagsKHR*)&forUnmarshaling->flags, sizeof(VkWin32SurfaceCreateFlagsKHR));
    vkStream->read((HINSTANCE*)&forUnmarshaling->hinstance, sizeof(HINSTANCE));
    vkStream->read((HWND*)&forUnmarshaling->hwnd, sizeof(HWND));
}

#endif
#ifdef VK_KHR_sampler_mirror_clamp_to_edge
#endif
#ifdef VK_KHR_multiview
#endif
#ifdef VK_KHR_get_physical_device_properties2
#endif
#ifdef VK_KHR_device_group
#endif
#ifdef VK_KHR_shader_draw_parameters
#endif
#ifdef VK_KHR_maintenance1
#endif
#ifdef VK_KHR_device_group_creation
#endif
#ifdef VK_KHR_external_memory_capabilities
#endif
#ifdef VK_KHR_external_memory
#endif
#ifdef VK_KHR_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_218 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_218);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportMemoryWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkExportMemoryWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    const SECURITY_ATTRIBUTES* check_pAttributes;
    check_pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        if (!(check_pAttributes))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pAttributes inconsistent between guest and host\n");
        }
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryWin32HandlePropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryWin32HandlePropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkMemoryWin32HandlePropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_220;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_220, 1);
    vkStream->write((uint64_t*)&cgen_var_220, 1 * 8);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkMemoryGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_221;
    vkStream->read((uint64_t*)&cgen_var_221, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_221, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_memory_fd
void marshal_VkImportMemoryFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportMemoryFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportMemoryFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkMemoryFdPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryFdPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryFdPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkMemoryFdPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkMemoryGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_222;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_222, 1);
    vkStream->write((uint64_t*)&cgen_var_222, 1 * 8);
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

void unmarshal_VkMemoryGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkMemoryGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_223;
    vkStream->read((uint64_t*)&cgen_var_223, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_223, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    if (forMarshaling->acquireCount)
    {
        uint64_t* cgen_var_224;
        vkStream->alloc((void**)&cgen_var_224, forMarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pAcquireSyncs, cgen_var_224, forMarshaling->acquireCount);
        vkStream->write((uint64_t*)cgen_var_224, forMarshaling->acquireCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeouts, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    if (forMarshaling->releaseCount)
    {
        uint64_t* cgen_var_225;
        vkStream->alloc((void**)&cgen_var_225, forMarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pReleaseSyncs, cgen_var_225, forMarshaling->releaseCount);
        vkStream->write((uint64_t*)cgen_var_225, forMarshaling->releaseCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(
    VulkanStreamGuest* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    if (forUnmarshaling->acquireCount)
    {
        uint64_t* cgen_var_226;
        vkStream->alloc((void**)&cgen_var_226, forUnmarshaling->acquireCount * 8);
        vkStream->read((uint64_t*)cgen_var_226, forUnmarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_226, (VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount);
    }
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeouts, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    if (forUnmarshaling->releaseCount)
    {
        uint64_t* cgen_var_227;
        vkStream->alloc((void**)&cgen_var_227, forUnmarshaling->releaseCount * 8);
        vkStream->read((uint64_t*)cgen_var_227, forUnmarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_227, (VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount);
    }
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_KHR_external_semaphore_capabilities
#endif
#ifdef VK_KHR_external_semaphore
#endif
#ifdef VK_KHR_external_semaphore_win32
void marshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_228;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_228, 1);
    vkStream->write((uint64_t*)&cgen_var_228, 1 * 8);
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_229;
    vkStream->read((uint64_t*)&cgen_var_229, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_229, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportSemaphoreWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_230 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_230);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportSemaphoreWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkExportSemaphoreWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    const SECURITY_ATTRIBUTES* check_pAttributes;
    check_pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        if (!(check_pAttributes))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pAttributes inconsistent between guest and host\n");
        }
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkD3D12FenceSubmitInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_232 = (uint64_t)(uintptr_t)forMarshaling->pWaitSemaphoreValues;
    vkStream->putBe64(cgen_var_232);
    if (forMarshaling->pWaitSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pWaitSemaphoreValues, forMarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->write((uint32_t*)&forMarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_233 = (uint64_t)(uintptr_t)forMarshaling->pSignalSemaphoreValues;
    vkStream->putBe64(cgen_var_233);
    if (forMarshaling->pSignalSemaphoreValues)
    {
        vkStream->write((const uint64_t*)forMarshaling->pSignalSemaphoreValues, forMarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void unmarshal_VkD3D12FenceSubmitInfoKHR(
    VulkanStreamGuest* vkStream,
    VkD3D12FenceSubmitInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->waitSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const uint64_t* check_pWaitSemaphoreValues;
    check_pWaitSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pWaitSemaphoreValues)
    {
        if (!(check_pWaitSemaphoreValues))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pWaitSemaphoreValues inconsistent between guest and host\n");
        }
        vkStream->read((uint64_t*)forUnmarshaling->pWaitSemaphoreValues, forUnmarshaling->waitSemaphoreValuesCount * sizeof(const uint64_t));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->signalSemaphoreValuesCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const uint64_t* check_pSignalSemaphoreValues;
    check_pSignalSemaphoreValues = (const uint64_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pSignalSemaphoreValues)
    {
        if (!(check_pSignalSemaphoreValues))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pSignalSemaphoreValues inconsistent between guest and host\n");
        }
        vkStream->read((uint64_t*)forUnmarshaling->pSignalSemaphoreValues, forUnmarshaling->signalSemaphoreValuesCount * sizeof(const uint64_t));
    }
}

void marshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_236;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_236, 1);
    vkStream->write((uint64_t*)&cgen_var_236, 1 * 8);
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkSemaphoreGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_237;
    vkStream->read((uint64_t*)&cgen_var_237, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_237, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_semaphore_fd
void marshal_VkImportSemaphoreFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportSemaphoreFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_238;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_238, 1);
    vkStream->write((uint64_t*)&cgen_var_238, 1 * 8);
    vkStream->write((VkSemaphoreImportFlags*)&forMarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportSemaphoreFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportSemaphoreFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_239;
    vkStream->read((uint64_t*)&cgen_var_239, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_239, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkSemaphoreImportFlags*)&forUnmarshaling->flags, sizeof(VkSemaphoreImportFlags));
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkSemaphoreGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSemaphoreGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_240;
    vkStream->handleMapping()->mapHandles_VkSemaphore_u64(&forMarshaling->semaphore, &cgen_var_240, 1);
    vkStream->write((uint64_t*)&cgen_var_240, 1 * 8);
    vkStream->write((VkExternalSemaphoreHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

void unmarshal_VkSemaphoreGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkSemaphoreGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_241;
    vkStream->read((uint64_t*)&cgen_var_241, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSemaphore(&cgen_var_241, (VkSemaphore*)&forUnmarshaling->semaphore, 1);
    vkStream->read((VkExternalSemaphoreHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalSemaphoreHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_push_descriptor
void marshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevicePushDescriptorPropertiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxPushDescriptors, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(
    VulkanStreamGuest* vkStream,
    VkPhysicalDevicePushDescriptorPropertiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxPushDescriptors, sizeof(uint32_t));
}

#endif
#ifdef VK_KHR_16bit_storage
#endif
#ifdef VK_KHR_incremental_present
void marshal_VkRectLayerKHR(
    VulkanStreamGuest* vkStream,
    const VkRectLayerKHR* forMarshaling)
{
    marshal_VkOffset2D(vkStream, (VkOffset2D*)(&forMarshaling->offset));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->extent));
    vkStream->write((uint32_t*)&forMarshaling->layer, sizeof(uint32_t));
}

void unmarshal_VkRectLayerKHR(
    VulkanStreamGuest* vkStream,
    VkRectLayerKHR* forUnmarshaling)
{
    unmarshal_VkOffset2D(vkStream, (VkOffset2D*)(&forUnmarshaling->offset));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->extent));
    vkStream->read((uint32_t*)&forUnmarshaling->layer, sizeof(uint32_t));
}

void marshal_VkPresentRegionKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentRegionKHR* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->rectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_242 = (uint64_t)(uintptr_t)forMarshaling->pRectangles;
    vkStream->putBe64(cgen_var_242);
    if (forMarshaling->pRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->rectangleCount; ++i)
        {
            marshal_VkRectLayerKHR(vkStream, (const VkRectLayerKHR*)(forMarshaling->pRectangles + i));
        }
    }
}

void unmarshal_VkPresentRegionKHR(
    VulkanStreamGuest* vkStream,
    VkPresentRegionKHR* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->rectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkRectLayerKHR* check_pRectangles;
    check_pRectangles = (const VkRectLayerKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pRectangles)
    {
        if (!(check_pRectangles))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pRectangles inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->rectangleCount; ++i)
        {
            unmarshal_VkRectLayerKHR(vkStream, (VkRectLayerKHR*)(forUnmarshaling->pRectangles + i));
        }
    }
}

void marshal_VkPresentRegionsKHR(
    VulkanStreamGuest* vkStream,
    const VkPresentRegionsKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_244 = (uint64_t)(uintptr_t)forMarshaling->pRegions;
    vkStream->putBe64(cgen_var_244);
    if (forMarshaling->pRegions)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentRegionKHR(vkStream, (const VkPresentRegionKHR*)(forMarshaling->pRegions + i));
        }
    }
}

void unmarshal_VkPresentRegionsKHR(
    VulkanStreamGuest* vkStream,
    VkPresentRegionsKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkPresentRegionKHR* check_pRegions;
    check_pRegions = (const VkPresentRegionKHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pRegions)
    {
        if (!(check_pRegions))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pRegions inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentRegionKHR(vkStream, (VkPresentRegionKHR*)(forUnmarshaling->pRegions + i));
        }
    }
}

#endif
#ifdef VK_KHR_descriptor_update_template
#endif
#ifdef VK_KHR_create_renderpass2
void marshal_VkAttachmentDescription2KHR(
    VulkanStreamGuest* vkStream,
    const VkAttachmentDescription2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkAttachmentDescriptionFlags*)&forMarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkAttachmentLoadOp*)&forMarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->write((VkAttachmentStoreOp*)&forMarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->write((VkImageLayout*)&forMarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->write((VkImageLayout*)&forMarshaling->finalLayout, sizeof(VkImageLayout));
}

void unmarshal_VkAttachmentDescription2KHR(
    VulkanStreamGuest* vkStream,
    VkAttachmentDescription2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkAttachmentDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkAttachmentDescriptionFlags));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->samples, sizeof(VkSampleCountFlagBits));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->loadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->storeOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkAttachmentLoadOp*)&forUnmarshaling->stencilLoadOp, sizeof(VkAttachmentLoadOp));
    vkStream->read((VkAttachmentStoreOp*)&forUnmarshaling->stencilStoreOp, sizeof(VkAttachmentStoreOp));
    vkStream->read((VkImageLayout*)&forUnmarshaling->initialLayout, sizeof(VkImageLayout));
    vkStream->read((VkImageLayout*)&forUnmarshaling->finalLayout, sizeof(VkImageLayout));
}

void marshal_VkAttachmentReference2KHR(
    VulkanStreamGuest* vkStream,
    const VkAttachmentReference2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->attachment, sizeof(uint32_t));
    vkStream->write((VkImageLayout*)&forMarshaling->layout, sizeof(VkImageLayout));
    vkStream->write((VkImageAspectFlags*)&forMarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void unmarshal_VkAttachmentReference2KHR(
    VulkanStreamGuest* vkStream,
    VkAttachmentReference2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachment, sizeof(uint32_t));
    vkStream->read((VkImageLayout*)&forUnmarshaling->layout, sizeof(VkImageLayout));
    vkStream->read((VkImageAspectFlags*)&forUnmarshaling->aspectMask, sizeof(VkImageAspectFlags));
}

void marshal_VkSubpassDescription2KHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassDescription2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSubpassDescriptionFlags*)&forMarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((uint32_t*)&forMarshaling->viewMask, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->inputAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pInputAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_246 = (uint64_t)(uintptr_t)forMarshaling->pResolveAttachments;
    vkStream->putBe64(cgen_var_246);
    if (forMarshaling->pResolveAttachments)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->colorAttachmentCount; ++i)
        {
            marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_247 = (uint64_t)(uintptr_t)forMarshaling->pDepthStencilAttachment;
    vkStream->putBe64(cgen_var_247);
    if (forMarshaling->pDepthStencilAttachment)
    {
        marshal_VkAttachmentReference2KHR(vkStream, (const VkAttachmentReference2KHR*)(forMarshaling->pDepthStencilAttachment));
    }
    vkStream->write((uint32_t*)&forMarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pPreserveAttachments, forMarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void unmarshal_VkSubpassDescription2KHR(
    VulkanStreamGuest* vkStream,
    VkSubpassDescription2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSubpassDescriptionFlags*)&forUnmarshaling->flags, sizeof(VkSubpassDescriptionFlags));
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((uint32_t*)&forUnmarshaling->viewMask, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->inputAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->inputAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pInputAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorAttachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
    {
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pColorAttachments + i));
    }
    // WARNING PTR CHECK
    const VkAttachmentReference2KHR* check_pResolveAttachments;
    check_pResolveAttachments = (const VkAttachmentReference2KHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pResolveAttachments)
    {
        if (!(check_pResolveAttachments))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pResolveAttachments inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->colorAttachmentCount; ++i)
        {
            unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pResolveAttachments + i));
        }
    }
    // WARNING PTR CHECK
    const VkAttachmentReference2KHR* check_pDepthStencilAttachment;
    check_pDepthStencilAttachment = (const VkAttachmentReference2KHR*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDepthStencilAttachment)
    {
        if (!(check_pDepthStencilAttachment))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pDepthStencilAttachment inconsistent between guest and host\n");
        }
        unmarshal_VkAttachmentReference2KHR(vkStream, (VkAttachmentReference2KHR*)(forUnmarshaling->pDepthStencilAttachment));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->preserveAttachmentCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pPreserveAttachments, forUnmarshaling->preserveAttachmentCount * sizeof(const uint32_t));
}

void marshal_VkSubpassDependency2KHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassDependency2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkAccessFlags*)&forMarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->write((VkDependencyFlags*)&forMarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->write((int32_t*)&forMarshaling->viewOffset, sizeof(int32_t));
}

void unmarshal_VkSubpassDependency2KHR(
    VulkanStreamGuest* vkStream,
    VkSubpassDependency2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->srcSubpass, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dstSubpass, sizeof(uint32_t));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->srcStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->dstStageMask, sizeof(VkPipelineStageFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->srcAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkAccessFlags*)&forUnmarshaling->dstAccessMask, sizeof(VkAccessFlags));
    vkStream->read((VkDependencyFlags*)&forUnmarshaling->dependencyFlags, sizeof(VkDependencyFlags));
    vkStream->read((int32_t*)&forUnmarshaling->viewOffset, sizeof(int32_t));
}

void marshal_VkRenderPassCreateInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkRenderPassCreateInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkRenderPassCreateFlags*)&forMarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->write((uint32_t*)&forMarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentCount; ++i)
    {
        marshal_VkAttachmentDescription2KHR(vkStream, (const VkAttachmentDescription2KHR*)(forMarshaling->pAttachments + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->subpassCount; ++i)
    {
        marshal_VkSubpassDescription2KHR(vkStream, (const VkSubpassDescription2KHR*)(forMarshaling->pSubpasses + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->dependencyCount; ++i)
    {
        marshal_VkSubpassDependency2KHR(vkStream, (const VkSubpassDependency2KHR*)(forMarshaling->pDependencies + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pCorrelatedViewMasks, forMarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

void unmarshal_VkRenderPassCreateInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkRenderPassCreateInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRenderPassCreateFlags*)&forUnmarshaling->flags, sizeof(VkRenderPassCreateFlags));
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentCount; ++i)
    {
        unmarshal_VkAttachmentDescription2KHR(vkStream, (VkAttachmentDescription2KHR*)(forUnmarshaling->pAttachments + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->subpassCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->subpassCount; ++i)
    {
        unmarshal_VkSubpassDescription2KHR(vkStream, (VkSubpassDescription2KHR*)(forUnmarshaling->pSubpasses + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->dependencyCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->dependencyCount; ++i)
    {
        unmarshal_VkSubpassDependency2KHR(vkStream, (VkSubpassDependency2KHR*)(forUnmarshaling->pDependencies + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->correlatedViewMaskCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pCorrelatedViewMasks, forUnmarshaling->correlatedViewMaskCount * sizeof(const uint32_t));
}

void marshal_VkSubpassBeginInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassBeginInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSubpassContents*)&forMarshaling->contents, sizeof(VkSubpassContents));
}

void unmarshal_VkSubpassBeginInfoKHR(
    VulkanStreamGuest* vkStream,
    VkSubpassBeginInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSubpassContents*)&forUnmarshaling->contents, sizeof(VkSubpassContents));
}

void marshal_VkSubpassEndInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkSubpassEndInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
}

void unmarshal_VkSubpassEndInfoKHR(
    VulkanStreamGuest* vkStream,
    VkSubpassEndInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
}

#endif
#ifdef VK_KHR_shared_presentable_image
void marshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    const VkSharedPresentSurfaceCapabilitiesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkImageUsageFlags*)&forMarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

void unmarshal_VkSharedPresentSurfaceCapabilitiesKHR(
    VulkanStreamGuest* vkStream,
    VkSharedPresentSurfaceCapabilitiesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->sharedPresentSupportedUsageFlags, sizeof(VkImageUsageFlags));
}

#endif
#ifdef VK_KHR_external_fence_capabilities
#endif
#ifdef VK_KHR_external_fence
#endif
#ifdef VK_KHR_external_fence_win32
void marshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_250;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_250, 1);
    vkStream->write((uint64_t*)&cgen_var_250, 1 * 8);
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkImportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_251;
    vkStream->read((uint64_t*)&cgen_var_251, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_251, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkExportFenceWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_252 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_252);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
    vkStream->write((LPCWSTR*)&forMarshaling->name, sizeof(LPCWSTR));
}

void unmarshal_VkExportFenceWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkExportFenceWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    const SECURITY_ATTRIBUTES* check_pAttributes;
    check_pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        if (!(check_pAttributes))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pAttributes inconsistent between guest and host\n");
        }
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
    vkStream->read((LPCWSTR*)&forUnmarshaling->name, sizeof(LPCWSTR));
}

void marshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkFenceGetWin32HandleInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_254;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_254, 1);
    vkStream->write((uint64_t*)&cgen_var_254, 1 * 8);
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetWin32HandleInfoKHR(
    VulkanStreamGuest* vkStream,
    VkFenceGetWin32HandleInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_255;
    vkStream->read((uint64_t*)&cgen_var_255, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_255, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_external_fence_fd
void marshal_VkImportFenceFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImportFenceFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_256;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_256, 1);
    vkStream->write((uint64_t*)&cgen_var_256, 1 * 8);
    vkStream->write((VkFenceImportFlags*)&forMarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->write((int*)&forMarshaling->fd, sizeof(int));
}

void unmarshal_VkImportFenceFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImportFenceFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_257;
    vkStream->read((uint64_t*)&cgen_var_257, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_257, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkFenceImportFlags*)&forUnmarshaling->flags, sizeof(VkFenceImportFlags));
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
    vkStream->read((int*)&forUnmarshaling->fd, sizeof(int));
}

void marshal_VkFenceGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkFenceGetFdInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_258;
    vkStream->handleMapping()->mapHandles_VkFence_u64(&forMarshaling->fence, &cgen_var_258, 1);
    vkStream->write((uint64_t*)&cgen_var_258, 1 * 8);
    vkStream->write((VkExternalFenceHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

void unmarshal_VkFenceGetFdInfoKHR(
    VulkanStreamGuest* vkStream,
    VkFenceGetFdInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_259;
    vkStream->read((uint64_t*)&cgen_var_259, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkFence(&cgen_var_259, (VkFence*)&forUnmarshaling->fence, 1);
    vkStream->read((VkExternalFenceHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalFenceHandleTypeFlagBits));
}

#endif
#ifdef VK_KHR_maintenance2
#endif
#ifdef VK_KHR_get_surface_capabilities2
void marshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSurfaceInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_260;
    vkStream->handleMapping()->mapHandles_VkSurfaceKHR_u64(&forMarshaling->surface, &cgen_var_260, 1);
    vkStream->write((uint64_t*)&cgen_var_260, 1 * 8);
}

void unmarshal_VkPhysicalDeviceSurfaceInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSurfaceInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_261;
    vkStream->read((uint64_t*)&cgen_var_261, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkSurfaceKHR(&cgen_var_261, (VkSurfaceKHR*)&forUnmarshaling->surface, 1);
}

void marshal_VkSurfaceCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forMarshaling->surfaceCapabilities));
}

void unmarshal_VkSurfaceCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    VkSurfaceCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSurfaceCapabilitiesKHR(vkStream, (VkSurfaceCapabilitiesKHR*)(&forUnmarshaling->surfaceCapabilities));
}

void marshal_VkSurfaceFormat2KHR(
    VulkanStreamGuest* vkStream,
    const VkSurfaceFormat2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forMarshaling->surfaceFormat));
}

void unmarshal_VkSurfaceFormat2KHR(
    VulkanStreamGuest* vkStream,
    VkSurfaceFormat2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkSurfaceFormatKHR(vkStream, (VkSurfaceFormatKHR*)(&forUnmarshaling->surfaceFormat));
}

#endif
#ifdef VK_KHR_variable_pointers
#endif
#ifdef VK_KHR_get_display_properties2
void marshal_VkDisplayProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forMarshaling->displayProperties));
}

void unmarshal_VkDisplayProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkDisplayProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPropertiesKHR(vkStream, (VkDisplayPropertiesKHR*)(&forUnmarshaling->displayProperties));
}

void marshal_VkDisplayPlaneProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forMarshaling->displayPlaneProperties));
}

void unmarshal_VkDisplayPlaneProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPlaneProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPlanePropertiesKHR(vkStream, (VkDisplayPlanePropertiesKHR*)(&forUnmarshaling->displayPlaneProperties));
}

void marshal_VkDisplayModeProperties2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayModeProperties2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forMarshaling->displayModeProperties));
}

void unmarshal_VkDisplayModeProperties2KHR(
    VulkanStreamGuest* vkStream,
    VkDisplayModeProperties2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayModePropertiesKHR(vkStream, (VkDisplayModePropertiesKHR*)(&forUnmarshaling->displayModeProperties));
}

void marshal_VkDisplayPlaneInfo2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneInfo2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_262;
    vkStream->handleMapping()->mapHandles_VkDisplayModeKHR_u64(&forMarshaling->mode, &cgen_var_262, 1);
    vkStream->write((uint64_t*)&cgen_var_262, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->planeIndex, sizeof(uint32_t));
}

void unmarshal_VkDisplayPlaneInfo2KHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPlaneInfo2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_263;
    vkStream->read((uint64_t*)&cgen_var_263, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDisplayModeKHR(&cgen_var_263, (VkDisplayModeKHR*)&forUnmarshaling->mode, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->planeIndex, sizeof(uint32_t));
}

void marshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    const VkDisplayPlaneCapabilities2KHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forMarshaling->capabilities));
}

void unmarshal_VkDisplayPlaneCapabilities2KHR(
    VulkanStreamGuest* vkStream,
    VkDisplayPlaneCapabilities2KHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkDisplayPlaneCapabilitiesKHR(vkStream, (VkDisplayPlaneCapabilitiesKHR*)(&forUnmarshaling->capabilities));
}

#endif
#ifdef VK_KHR_dedicated_allocation
#endif
#ifdef VK_KHR_storage_buffer_storage_class
#endif
#ifdef VK_KHR_relaxed_block_layout
#endif
#ifdef VK_KHR_get_memory_requirements2
#endif
#ifdef VK_KHR_image_format_list
void marshal_VkImageFormatListCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    const VkImageFormatListCreateInfoKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->write((const VkFormat*)forMarshaling->pViewFormats, forMarshaling->viewFormatCount * sizeof(const VkFormat));
}

void unmarshal_VkImageFormatListCreateInfoKHR(
    VulkanStreamGuest* vkStream,
    VkImageFormatListCreateInfoKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->viewFormatCount, sizeof(uint32_t));
    vkStream->read((VkFormat*)forUnmarshaling->pViewFormats, forUnmarshaling->viewFormatCount * sizeof(const VkFormat));
}

#endif
#ifdef VK_KHR_sampler_ycbcr_conversion
#endif
#ifdef VK_KHR_bind_memory2
#endif
#ifdef VK_KHR_maintenance3
#endif
#ifdef VK_KHR_draw_indirect_count
#endif
#ifdef VK_KHR_8bit_storage
void marshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDevice8BitStorageFeaturesKHR* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->storagePushConstant8, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(
    VulkanStreamGuest* vkStream,
    VkPhysicalDevice8BitStorageFeaturesKHR* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->storageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->uniformAndStorageBuffer8BitAccess, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->storagePushConstant8, sizeof(VkBool32));
}

#endif
#ifdef VK_ANDROID_native_buffer
void marshal_VkNativeBufferANDROID(
    VulkanStreamGuest* vkStream,
    const VkNativeBufferANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_264 = (uint64_t)(uintptr_t)forMarshaling->handle;
    vkStream->putBe64(cgen_var_264);
    if (forMarshaling->handle)
    {
        vkStream->write((const uint32_t*)forMarshaling->handle, sizeof(const uint32_t));
    }
    vkStream->write((int*)&forMarshaling->stride, sizeof(int));
    vkStream->write((int*)&forMarshaling->format, sizeof(int));
    vkStream->write((int*)&forMarshaling->usage, sizeof(int));
    vkStream->write((uint64_t*)&forMarshaling->consumer, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->producer, sizeof(uint64_t));
}

void unmarshal_VkNativeBufferANDROID(
    VulkanStreamGuest* vkStream,
    VkNativeBufferANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    const uint32_t* check_handle;
    check_handle = (const uint32_t*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->handle)
    {
        if (!(check_handle))
        {
            fprintf(stderr, "fatal: forUnmarshaling->handle inconsistent between guest and host\n");
        }
        vkStream->read((uint32_t*)forUnmarshaling->handle, sizeof(const uint32_t));
    }
    vkStream->read((int*)&forUnmarshaling->stride, sizeof(int));
    vkStream->read((int*)&forUnmarshaling->format, sizeof(int));
    vkStream->read((int*)&forUnmarshaling->usage, sizeof(int));
    vkStream->read((uint64_t*)&forUnmarshaling->consumer, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->producer, sizeof(uint64_t));
}

#endif
#ifdef VK_EXT_debug_report
void marshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugReportCallbackCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDebugReportFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    uint64_t cgen_var_266 = (uint64_t)forMarshaling->pfnCallback;
    vkStream->putBe64(cgen_var_266);
    // WARNING PTR CHECK
    uint64_t cgen_var_267 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_267);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugReportCallbackCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugReportCallbackCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugReportFlagsEXT));
    forUnmarshaling->pfnCallback = (PFN_vkDebugReportCallbackEXT)vkStream->getBe64();
    // WARNING PTR CHECK
    void* check_pUserData;
    check_pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        if (!(check_pUserData))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pUserData inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_NV_glsl_shader
#endif
#ifdef VK_EXT_depth_range_unrestricted
#endif
#ifdef VK_IMG_filter_cubic
#endif
#ifdef VK_AMD_rasterization_order
void marshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationStateRasterizationOrderAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkRasterizationOrderAMD*)&forMarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

void unmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(
    VulkanStreamGuest* vkStream,
    VkPipelineRasterizationStateRasterizationOrderAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkRasterizationOrderAMD*)&forUnmarshaling->rasterizationOrder, sizeof(VkRasterizationOrderAMD));
}

#endif
#ifdef VK_AMD_shader_trinary_minmax
#endif
#ifdef VK_AMD_shader_explicit_vertex_parameter
#endif
#ifdef VK_EXT_debug_marker
void marshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->putString(forMarshaling->pObjectName);
}

void unmarshal_VkDebugMarkerObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugMarkerObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
}

void marshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDebugReportObjectTypeEXT*)&forMarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->write((uint64_t*)&forMarshaling->object, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    uint64_t cgen_var_270 = (uint64_t)forMarshaling->tagSize;
    vkStream->putBe64(cgen_var_270);
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugMarkerObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugMarkerObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugReportObjectTypeEXT*)&forUnmarshaling->objectType, sizeof(VkDebugReportObjectTypeEXT));
    vkStream->read((uint64_t*)&forUnmarshaling->object, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    forUnmarshaling->tagSize = (size_t)vkStream->getBe64();
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

void marshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugMarkerMarkerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->putString(forMarshaling->pMarkerName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugMarkerMarkerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugMarkerMarkerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMarkerName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

#endif
#ifdef VK_AMD_gcn_shader
#endif
#ifdef VK_NV_dedicated_allocation
void marshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkDedicatedAllocationImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationBufferCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void unmarshal_VkDedicatedAllocationBufferCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkDedicatedAllocationBufferCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->dedicatedAllocation, sizeof(VkBool32));
}

void marshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkDedicatedAllocationMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_272;
    vkStream->handleMapping()->mapHandles_VkImage_u64(&forMarshaling->image, &cgen_var_272, 1);
    vkStream->write((uint64_t*)&cgen_var_272, 1 * 8);
    uint64_t cgen_var_273;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_273, 1);
    vkStream->write((uint64_t*)&cgen_var_273, 1 * 8);
}

void unmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    VkDedicatedAllocationMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_274;
    vkStream->read((uint64_t*)&cgen_var_274, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkImage(&cgen_var_274, (VkImage*)&forUnmarshaling->image, 1);
    uint64_t cgen_var_275;
    vkStream->read((uint64_t*)&cgen_var_275, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_275, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

#endif
#ifdef VK_AMD_draw_indirect_count
#endif
#ifdef VK_AMD_negative_viewport_height
#endif
#ifdef VK_AMD_gpu_shader_half_float
#endif
#ifdef VK_AMD_shader_ballot
#endif
#ifdef VK_AMD_texture_gather_bias_lod
void marshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStreamGuest* vkStream,
    const VkTextureLODGatherFormatPropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

void unmarshal_VkTextureLODGatherFormatPropertiesAMD(
    VulkanStreamGuest* vkStream,
    VkTextureLODGatherFormatPropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->supportsTextureGatherLODBiasAMD, sizeof(VkBool32));
}

#endif
#ifdef VK_AMD_shader_info
void marshal_VkShaderResourceUsageAMD(
    VulkanStreamGuest* vkStream,
    const VkShaderResourceUsageAMD* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    uint64_t cgen_var_276 = (uint64_t)forMarshaling->ldsUsageSizeInBytes;
    vkStream->putBe64(cgen_var_276);
    uint64_t cgen_var_277 = (uint64_t)forMarshaling->scratchMemUsageInBytes;
    vkStream->putBe64(cgen_var_277);
}

void unmarshal_VkShaderResourceUsageAMD(
    VulkanStreamGuest* vkStream,
    VkShaderResourceUsageAMD* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numUsedSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->ldsSizePerLocalWorkGroup, sizeof(uint32_t));
    forUnmarshaling->ldsUsageSizeInBytes = (size_t)vkStream->getBe64();
    forUnmarshaling->scratchMemUsageInBytes = (size_t)vkStream->getBe64();
}

void marshal_VkShaderStatisticsInfoAMD(
    VulkanStreamGuest* vkStream,
    const VkShaderStatisticsInfoAMD* forMarshaling)
{
    vkStream->write((VkShaderStageFlags*)&forMarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    marshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forMarshaling->resourceUsage));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->write((uint32_t*)forMarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

void unmarshal_VkShaderStatisticsInfoAMD(
    VulkanStreamGuest* vkStream,
    VkShaderStatisticsInfoAMD* forUnmarshaling)
{
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->shaderStageMask, sizeof(VkShaderStageFlags));
    unmarshal_VkShaderResourceUsageAMD(vkStream, (VkShaderResourceUsageAMD*)(&forUnmarshaling->resourceUsage));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numPhysicalSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableVgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->numAvailableSgprs, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->computeWorkGroupSize, 3 * sizeof(uint32_t));
}

#endif
#ifdef VK_AMD_shader_image_load_store_lod
#endif
#ifdef VK_IMG_format_pvrtc
#endif
#ifdef VK_NV_external_memory_capabilities
void marshal_VkExternalImageFormatPropertiesNV(
    VulkanStreamGuest* vkStream,
    const VkExternalImageFormatPropertiesNV* forMarshaling)
{
    marshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forMarshaling->imageFormatProperties));
    vkStream->write((VkExternalMemoryFeatureFlagsNV*)&forMarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalImageFormatPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkExternalImageFormatPropertiesNV* forUnmarshaling)
{
    unmarshal_VkImageFormatProperties(vkStream, (VkImageFormatProperties*)(&forUnmarshaling->imageFormatProperties));
    vkStream->read((VkExternalMemoryFeatureFlagsNV*)&forUnmarshaling->externalMemoryFeatures, sizeof(VkExternalMemoryFeatureFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->exportFromImportedHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->compatibleHandleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

#endif
#ifdef VK_NV_external_memory
void marshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExternalMemoryImageCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExternalMemoryImageCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkExternalMemoryImageCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void marshal_VkExportMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryAllocateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

void unmarshal_VkExportMemoryAllocateInfoNV(
    VulkanStreamGuest* vkStream,
    VkExportMemoryAllocateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleTypes, sizeof(VkExternalMemoryHandleTypeFlagsNV));
}

#endif
#ifdef VK_NV_external_memory_win32
void marshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagsNV*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->write((HANDLE*)&forMarshaling->handle, sizeof(HANDLE));
}

void unmarshal_VkImportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    VkImportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagsNV*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagsNV));
    vkStream->read((HANDLE*)&forUnmarshaling->handle, sizeof(HANDLE));
}

void marshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    const VkExportMemoryWin32HandleInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    // WARNING PTR CHECK
    uint64_t cgen_var_280 = (uint64_t)(uintptr_t)forMarshaling->pAttributes;
    vkStream->putBe64(cgen_var_280);
    if (forMarshaling->pAttributes)
    {
        vkStream->write((const SECURITY_ATTRIBUTES*)forMarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->write((DWORD*)&forMarshaling->dwAccess, sizeof(DWORD));
}

void unmarshal_VkExportMemoryWin32HandleInfoNV(
    VulkanStreamGuest* vkStream,
    VkExportMemoryWin32HandleInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    // WARNING PTR CHECK
    const SECURITY_ATTRIBUTES* check_pAttributes;
    check_pAttributes = (const SECURITY_ATTRIBUTES*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pAttributes)
    {
        if (!(check_pAttributes))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pAttributes inconsistent between guest and host\n");
        }
        vkStream->read((SECURITY_ATTRIBUTES*)forUnmarshaling->pAttributes, sizeof(const SECURITY_ATTRIBUTES));
    }
    vkStream->read((DWORD*)&forUnmarshaling->dwAccess, sizeof(DWORD));
}

#endif
#ifdef VK_NV_win32_keyed_mutex
void marshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStreamGuest* vkStream,
    const VkWin32KeyedMutexAcquireReleaseInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->acquireCount, sizeof(uint32_t));
    if (forMarshaling->acquireCount)
    {
        uint64_t* cgen_var_282;
        vkStream->alloc((void**)&cgen_var_282, forMarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pAcquireSyncs, cgen_var_282, forMarshaling->acquireCount);
        vkStream->write((uint64_t*)cgen_var_282, forMarshaling->acquireCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pAcquireKeys, forMarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->write((const uint32_t*)forMarshaling->pAcquireTimeoutMilliseconds, forMarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->releaseCount, sizeof(uint32_t));
    if (forMarshaling->releaseCount)
    {
        uint64_t* cgen_var_283;
        vkStream->alloc((void**)&cgen_var_283, forMarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(forMarshaling->pReleaseSyncs, cgen_var_283, forMarshaling->releaseCount);
        vkStream->write((uint64_t*)cgen_var_283, forMarshaling->releaseCount * 8);
    }
    vkStream->write((const uint64_t*)forMarshaling->pReleaseKeys, forMarshaling->releaseCount * sizeof(const uint64_t));
}

void unmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(
    VulkanStreamGuest* vkStream,
    VkWin32KeyedMutexAcquireReleaseInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->acquireCount, sizeof(uint32_t));
    if (forUnmarshaling->acquireCount)
    {
        uint64_t* cgen_var_284;
        vkStream->alloc((void**)&cgen_var_284, forUnmarshaling->acquireCount * 8);
        vkStream->read((uint64_t*)cgen_var_284, forUnmarshaling->acquireCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_284, (VkDeviceMemory*)forUnmarshaling->pAcquireSyncs, forUnmarshaling->acquireCount);
    }
    vkStream->read((uint64_t*)forUnmarshaling->pAcquireKeys, forUnmarshaling->acquireCount * sizeof(const uint64_t));
    vkStream->read((uint32_t*)forUnmarshaling->pAcquireTimeoutMilliseconds, forUnmarshaling->acquireCount * sizeof(const uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->releaseCount, sizeof(uint32_t));
    if (forUnmarshaling->releaseCount)
    {
        uint64_t* cgen_var_285;
        vkStream->alloc((void**)&cgen_var_285, forUnmarshaling->releaseCount * 8);
        vkStream->read((uint64_t*)cgen_var_285, forUnmarshaling->releaseCount * 8);
        vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(cgen_var_285, (VkDeviceMemory*)forUnmarshaling->pReleaseSyncs, forUnmarshaling->releaseCount);
    }
    vkStream->read((uint64_t*)forUnmarshaling->pReleaseKeys, forUnmarshaling->releaseCount * sizeof(const uint64_t));
}

#endif
#ifdef VK_EXT_validation_flags
void marshal_VkValidationFlagsEXT(
    VulkanStreamGuest* vkStream,
    const VkValidationFlagsEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->write((const VkValidationCheckEXT*)forMarshaling->pDisabledValidationChecks, forMarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

void unmarshal_VkValidationFlagsEXT(
    VulkanStreamGuest* vkStream,
    VkValidationFlagsEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->disabledValidationCheckCount, sizeof(uint32_t));
    vkStream->read((VkValidationCheckEXT*)forUnmarshaling->pDisabledValidationChecks, forUnmarshaling->disabledValidationCheckCount * sizeof(const VkValidationCheckEXT));
}

#endif
#ifdef VK_NN_vi_surface
void marshal_VkViSurfaceCreateInfoNN(
    VulkanStreamGuest* vkStream,
    const VkViSurfaceCreateInfoNN* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkViSurfaceCreateFlagsNN*)&forMarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    // WARNING PTR CHECK
    uint64_t cgen_var_286 = (uint64_t)(uintptr_t)forMarshaling->window;
    vkStream->putBe64(cgen_var_286);
    if (forMarshaling->window)
    {
        vkStream->write((void*)forMarshaling->window, sizeof(uint8_t));
    }
}

void unmarshal_VkViSurfaceCreateInfoNN(
    VulkanStreamGuest* vkStream,
    VkViSurfaceCreateInfoNN* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkViSurfaceCreateFlagsNN*)&forUnmarshaling->flags, sizeof(VkViSurfaceCreateFlagsNN));
    // WARNING PTR CHECK
    void* check_window;
    check_window = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->window)
    {
        if (!(check_window))
        {
            fprintf(stderr, "fatal: forUnmarshaling->window inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->window, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_EXT_shader_subgroup_ballot
#endif
#ifdef VK_EXT_shader_subgroup_vote
#endif
#ifdef VK_EXT_conditional_rendering
void marshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkConditionalRenderingBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_288;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_288, 1);
    vkStream->write((uint64_t*)&cgen_var_288, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
    vkStream->write((VkConditionalRenderingFlagsEXT*)&forMarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void unmarshal_VkConditionalRenderingBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    VkConditionalRenderingBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_289;
    vkStream->read((uint64_t*)&cgen_var_289, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_289, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
    vkStream->read((VkConditionalRenderingFlagsEXT*)&forUnmarshaling->flags, sizeof(VkConditionalRenderingFlagsEXT));
}

void marshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceConditionalRenderingFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRendering, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->inheritedConditionalRendering, sizeof(VkBool32));
}

void marshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

void unmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(
    VulkanStreamGuest* vkStream,
    VkCommandBufferInheritanceConditionalRenderingInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->conditionalRenderingEnable, sizeof(VkBool32));
}

#endif
#ifdef VK_NVX_device_generated_commands
void marshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStreamGuest* vkStream,
    const VkDeviceGeneratedCommandsFeaturesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->computeBindingPointSupport, sizeof(VkBool32));
}

void unmarshal_VkDeviceGeneratedCommandsFeaturesNVX(
    VulkanStreamGuest* vkStream,
    VkDeviceGeneratedCommandsFeaturesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->computeBindingPointSupport, sizeof(VkBool32));
}

void marshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStreamGuest* vkStream,
    const VkDeviceGeneratedCommandsLimitsNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxIndirectCommandsLayoutTokenCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxObjectEntryCounts, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequenceCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSequenceIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minCommandsTokenBufferOffsetAlignment, sizeof(uint32_t));
}

void unmarshal_VkDeviceGeneratedCommandsLimitsNVX(
    VulkanStreamGuest* vkStream,
    VkDeviceGeneratedCommandsLimitsNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxIndirectCommandsLayoutTokenCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxObjectEntryCounts, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequenceCountBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSequenceIndexBufferOffsetAlignment, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minCommandsTokenBufferOffsetAlignment, sizeof(uint32_t));
}

void marshal_VkIndirectCommandsTokenNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsTokenNVX* forMarshaling)
{
    vkStream->write((VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    uint64_t cgen_var_290;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_290, 1);
    vkStream->write((uint64_t*)&cgen_var_290, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->offset, sizeof(VkDeviceSize));
}

void unmarshal_VkIndirectCommandsTokenNVX(
    VulkanStreamGuest* vkStream,
    VkIndirectCommandsTokenNVX* forUnmarshaling)
{
    vkStream->read((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    uint64_t cgen_var_291;
    vkStream->read((uint64_t*)&cgen_var_291, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_291, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->offset, sizeof(VkDeviceSize));
}

void marshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsLayoutTokenNVX* forMarshaling)
{
    vkStream->write((VkIndirectCommandsTokenTypeNVX*)&forMarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->write((uint32_t*)&forMarshaling->bindingUnit, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->dynamicCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
}

void unmarshal_VkIndirectCommandsLayoutTokenNVX(
    VulkanStreamGuest* vkStream,
    VkIndirectCommandsLayoutTokenNVX* forUnmarshaling)
{
    vkStream->read((VkIndirectCommandsTokenTypeNVX*)&forUnmarshaling->tokenType, sizeof(VkIndirectCommandsTokenTypeNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->bindingUnit, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->dynamicCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->divisor, sizeof(uint32_t));
}

void marshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkIndirectCommandsLayoutCreateInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineBindPoint*)&forMarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->write((VkIndirectCommandsLayoutUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    vkStream->write((uint32_t*)&forMarshaling->tokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->tokenCount; ++i)
    {
        marshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (const VkIndirectCommandsLayoutTokenNVX*)(forMarshaling->pTokens + i));
    }
}

void unmarshal_VkIndirectCommandsLayoutCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    VkIndirectCommandsLayoutCreateInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineBindPoint*)&forUnmarshaling->pipelineBindPoint, sizeof(VkPipelineBindPoint));
    vkStream->read((VkIndirectCommandsLayoutUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkIndirectCommandsLayoutUsageFlagsNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->tokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->tokenCount; ++i)
    {
        unmarshal_VkIndirectCommandsLayoutTokenNVX(vkStream, (VkIndirectCommandsLayoutTokenNVX*)(forUnmarshaling->pTokens + i));
    }
}

void marshal_VkCmdProcessCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkCmdProcessCommandsInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_292;
    vkStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&forMarshaling->objectTable, &cgen_var_292, 1);
    vkStream->write((uint64_t*)&cgen_var_292, 1 * 8);
    uint64_t cgen_var_293;
    vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&forMarshaling->indirectCommandsLayout, &cgen_var_293, 1);
    vkStream->write((uint64_t*)&cgen_var_293, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->indirectCommandsTokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->indirectCommandsTokenCount; ++i)
    {
        marshal_VkIndirectCommandsTokenNVX(vkStream, (const VkIndirectCommandsTokenNVX*)(forMarshaling->pIndirectCommandsTokens + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
    uint64_t cgen_var_294;
    vkStream->handleMapping()->mapHandles_VkCommandBuffer_u64(&forMarshaling->targetCommandBuffer, &cgen_var_294, 1);
    vkStream->write((uint64_t*)&cgen_var_294, 1 * 8);
    uint64_t cgen_var_295;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->sequencesCountBuffer, &cgen_var_295, 1);
    vkStream->write((uint64_t*)&cgen_var_295, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    uint64_t cgen_var_296;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->sequencesIndexBuffer, &cgen_var_296, 1);
    vkStream->write((uint64_t*)&cgen_var_296, 1 * 8);
    vkStream->write((VkDeviceSize*)&forMarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void unmarshal_VkCmdProcessCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    VkCmdProcessCommandsInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_297;
    vkStream->read((uint64_t*)&cgen_var_297, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_297, (VkObjectTableNVX*)&forUnmarshaling->objectTable, 1);
    uint64_t cgen_var_298;
    vkStream->read((uint64_t*)&cgen_var_298, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_298, (VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->indirectCommandsTokenCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->indirectCommandsTokenCount; ++i)
    {
        unmarshal_VkIndirectCommandsTokenNVX(vkStream, (VkIndirectCommandsTokenNVX*)(forUnmarshaling->pIndirectCommandsTokens + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxSequencesCount, sizeof(uint32_t));
    uint64_t cgen_var_299;
    vkStream->read((uint64_t*)&cgen_var_299, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkCommandBuffer(&cgen_var_299, (VkCommandBuffer*)&forUnmarshaling->targetCommandBuffer, 1);
    uint64_t cgen_var_300;
    vkStream->read((uint64_t*)&cgen_var_300, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_300, (VkBuffer*)&forUnmarshaling->sequencesCountBuffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesCountOffset, sizeof(VkDeviceSize));
    uint64_t cgen_var_301;
    vkStream->read((uint64_t*)&cgen_var_301, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_301, (VkBuffer*)&forUnmarshaling->sequencesIndexBuffer, 1);
    vkStream->read((VkDeviceSize*)&forUnmarshaling->sequencesIndexOffset, sizeof(VkDeviceSize));
}

void marshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkCmdReserveSpaceForCommandsInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_302;
    vkStream->handleMapping()->mapHandles_VkObjectTableNVX_u64(&forMarshaling->objectTable, &cgen_var_302, 1);
    vkStream->write((uint64_t*)&cgen_var_302, 1 * 8);
    uint64_t cgen_var_303;
    vkStream->handleMapping()->mapHandles_VkIndirectCommandsLayoutNVX_u64(&forMarshaling->indirectCommandsLayout, &cgen_var_303, 1);
    vkStream->write((uint64_t*)&cgen_var_303, 1 * 8);
    vkStream->write((uint32_t*)&forMarshaling->maxSequencesCount, sizeof(uint32_t));
}

void unmarshal_VkCmdReserveSpaceForCommandsInfoNVX(
    VulkanStreamGuest* vkStream,
    VkCmdReserveSpaceForCommandsInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_304;
    vkStream->read((uint64_t*)&cgen_var_304, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkObjectTableNVX(&cgen_var_304, (VkObjectTableNVX*)&forUnmarshaling->objectTable, 1);
    uint64_t cgen_var_305;
    vkStream->read((uint64_t*)&cgen_var_305, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkIndirectCommandsLayoutNVX(&cgen_var_305, (VkIndirectCommandsLayoutNVX*)&forUnmarshaling->indirectCommandsLayout, 1);
    vkStream->read((uint32_t*)&forUnmarshaling->maxSequencesCount, sizeof(uint32_t));
}

void marshal_VkObjectTableCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableCreateInfoNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    vkStream->write((const VkObjectEntryTypeNVX*)forMarshaling->pObjectEntryTypes, forMarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    vkStream->write((const uint32_t*)forMarshaling->pObjectEntryCounts, forMarshaling->objectCount * sizeof(const uint32_t));
    vkStream->write((const VkObjectEntryUsageFlagsNVX*)forMarshaling->pObjectEntryUsageFlags, forMarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    vkStream->write((uint32_t*)&forMarshaling->maxUniformBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxStorageImagesPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSampledImagesPerDescriptor, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPipelineLayouts, sizeof(uint32_t));
}

void unmarshal_VkObjectTableCreateInfoNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTableCreateInfoNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->objectCount, sizeof(uint32_t));
    vkStream->read((VkObjectEntryTypeNVX*)forUnmarshaling->pObjectEntryTypes, forUnmarshaling->objectCount * sizeof(const VkObjectEntryTypeNVX));
    vkStream->read((uint32_t*)forUnmarshaling->pObjectEntryCounts, forUnmarshaling->objectCount * sizeof(const uint32_t));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)forUnmarshaling->pObjectEntryUsageFlags, forUnmarshaling->objectCount * sizeof(const VkObjectEntryUsageFlagsNVX));
    vkStream->read((uint32_t*)&forUnmarshaling->maxUniformBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageBuffersPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxStorageImagesPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSampledImagesPerDescriptor, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPipelineLayouts, sizeof(uint32_t));
}

void marshal_VkObjectTableEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
}

void unmarshal_VkObjectTableEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTableEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
}

void marshal_VkObjectTablePipelineEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTablePipelineEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_306;
    vkStream->handleMapping()->mapHandles_VkPipeline_u64(&forMarshaling->pipeline, &cgen_var_306, 1);
    vkStream->write((uint64_t*)&cgen_var_306, 1 * 8);
}

void unmarshal_VkObjectTablePipelineEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTablePipelineEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_307;
    vkStream->read((uint64_t*)&cgen_var_307, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipeline(&cgen_var_307, (VkPipeline*)&forUnmarshaling->pipeline, 1);
}

void marshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableDescriptorSetEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_308;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->pipelineLayout, &cgen_var_308, 1);
    vkStream->write((uint64_t*)&cgen_var_308, 1 * 8);
    uint64_t cgen_var_309;
    vkStream->handleMapping()->mapHandles_VkDescriptorSet_u64(&forMarshaling->descriptorSet, &cgen_var_309, 1);
    vkStream->write((uint64_t*)&cgen_var_309, 1 * 8);
}

void unmarshal_VkObjectTableDescriptorSetEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTableDescriptorSetEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_310;
    vkStream->read((uint64_t*)&cgen_var_310, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_310, (VkPipelineLayout*)&forUnmarshaling->pipelineLayout, 1);
    uint64_t cgen_var_311;
    vkStream->read((uint64_t*)&cgen_var_311, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDescriptorSet(&cgen_var_311, (VkDescriptorSet*)&forUnmarshaling->descriptorSet, 1);
}

void marshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableVertexBufferEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_312;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_312, 1);
    vkStream->write((uint64_t*)&cgen_var_312, 1 * 8);
}

void unmarshal_VkObjectTableVertexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTableVertexBufferEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_313;
    vkStream->read((uint64_t*)&cgen_var_313, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_313, (VkBuffer*)&forUnmarshaling->buffer, 1);
}

void marshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTableIndexBufferEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_314;
    vkStream->handleMapping()->mapHandles_VkBuffer_u64(&forMarshaling->buffer, &cgen_var_314, 1);
    vkStream->write((uint64_t*)&cgen_var_314, 1 * 8);
    vkStream->write((VkIndexType*)&forMarshaling->indexType, sizeof(VkIndexType));
}

void unmarshal_VkObjectTableIndexBufferEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTableIndexBufferEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_315;
    vkStream->read((uint64_t*)&cgen_var_315, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkBuffer(&cgen_var_315, (VkBuffer*)&forUnmarshaling->buffer, 1);
    vkStream->read((VkIndexType*)&forUnmarshaling->indexType, sizeof(VkIndexType));
}

void marshal_VkObjectTablePushConstantEntryNVX(
    VulkanStreamGuest* vkStream,
    const VkObjectTablePushConstantEntryNVX* forMarshaling)
{
    vkStream->write((VkObjectEntryTypeNVX*)&forMarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->write((VkObjectEntryUsageFlagsNVX*)&forMarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_316;
    vkStream->handleMapping()->mapHandles_VkPipelineLayout_u64(&forMarshaling->pipelineLayout, &cgen_var_316, 1);
    vkStream->write((uint64_t*)&cgen_var_316, 1 * 8);
    vkStream->write((VkShaderStageFlags*)&forMarshaling->stageFlags, sizeof(VkShaderStageFlags));
}

void unmarshal_VkObjectTablePushConstantEntryNVX(
    VulkanStreamGuest* vkStream,
    VkObjectTablePushConstantEntryNVX* forUnmarshaling)
{
    vkStream->read((VkObjectEntryTypeNVX*)&forUnmarshaling->type, sizeof(VkObjectEntryTypeNVX));
    vkStream->read((VkObjectEntryUsageFlagsNVX*)&forUnmarshaling->flags, sizeof(VkObjectEntryUsageFlagsNVX));
    uint64_t cgen_var_317;
    vkStream->read((uint64_t*)&cgen_var_317, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkPipelineLayout(&cgen_var_317, (VkPipelineLayout*)&forUnmarshaling->pipelineLayout, 1);
    vkStream->read((VkShaderStageFlags*)&forUnmarshaling->stageFlags, sizeof(VkShaderStageFlags));
}

#endif
#ifdef VK_NV_clip_space_w_scaling
void marshal_VkViewportWScalingNV(
    VulkanStreamGuest* vkStream,
    const VkViewportWScalingNV* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->xcoeff, sizeof(float));
    vkStream->write((float*)&forMarshaling->ycoeff, sizeof(float));
}

void unmarshal_VkViewportWScalingNV(
    VulkanStreamGuest* vkStream,
    VkViewportWScalingNV* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->xcoeff, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->ycoeff, sizeof(float));
}

void marshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportWScalingStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_318 = (uint64_t)(uintptr_t)forMarshaling->pViewportWScalings;
    vkStream->putBe64(cgen_var_318);
    if (forMarshaling->pViewportWScalings)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportWScalingNV(vkStream, (const VkViewportWScalingNV*)(forMarshaling->pViewportWScalings + i));
        }
    }
}

void unmarshal_VkPipelineViewportWScalingStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkPipelineViewportWScalingStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->viewportWScalingEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkViewportWScalingNV* check_pViewportWScalings;
    check_pViewportWScalings = (const VkViewportWScalingNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportWScalings)
    {
        if (!(check_pViewportWScalings))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pViewportWScalings inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportWScalingNV(vkStream, (VkViewportWScalingNV*)(forUnmarshaling->pViewportWScalings + i));
        }
    }
}

#endif
#ifdef VK_EXT_direct_mode_display
#endif
#ifdef VK_EXT_acquire_xlib_display
#endif
#ifdef VK_EXT_display_surface_counter
void marshal_VkSurfaceCapabilities2EXT(
    VulkanStreamGuest* vkStream,
    const VkSurfaceCapabilities2EXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->minImageCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxImageCount, sizeof(uint32_t));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->currentExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->minImageExtent));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxImageExtent));
    vkStream->write((uint32_t*)&forMarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->write((VkSurfaceTransformFlagsKHR*)&forMarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->write((VkSurfaceTransformFlagBitsKHR*)&forMarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->write((VkCompositeAlphaFlagsKHR*)&forMarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->write((VkImageUsageFlags*)&forMarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSurfaceCapabilities2EXT(
    VulkanStreamGuest* vkStream,
    VkSurfaceCapabilities2EXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->minImageCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageCount, sizeof(uint32_t));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->currentExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->minImageExtent));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxImageExtent));
    vkStream->read((uint32_t*)&forUnmarshaling->maxImageArrayLayers, sizeof(uint32_t));
    vkStream->read((VkSurfaceTransformFlagsKHR*)&forUnmarshaling->supportedTransforms, sizeof(VkSurfaceTransformFlagsKHR));
    vkStream->read((VkSurfaceTransformFlagBitsKHR*)&forUnmarshaling->currentTransform, sizeof(VkSurfaceTransformFlagBitsKHR));
    vkStream->read((VkCompositeAlphaFlagsKHR*)&forUnmarshaling->supportedCompositeAlpha, sizeof(VkCompositeAlphaFlagsKHR));
    vkStream->read((VkImageUsageFlags*)&forUnmarshaling->supportedUsageFlags, sizeof(VkImageUsageFlags));
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->supportedSurfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

#endif
#ifdef VK_EXT_display_control
void marshal_VkDisplayPowerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDisplayPowerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDisplayPowerStateEXT*)&forMarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void unmarshal_VkDisplayPowerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDisplayPowerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayPowerStateEXT*)&forUnmarshaling->powerState, sizeof(VkDisplayPowerStateEXT));
}

void marshal_VkDeviceEventInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDeviceEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceEventTypeEXT*)&forMarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void unmarshal_VkDeviceEventInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDeviceEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceEventTypeEXT*)&forUnmarshaling->deviceEvent, sizeof(VkDeviceEventTypeEXT));
}

void marshal_VkDisplayEventInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDisplayEventInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDisplayEventTypeEXT*)&forMarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void unmarshal_VkDisplayEventInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDisplayEventInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDisplayEventTypeEXT*)&forUnmarshaling->displayEvent, sizeof(VkDisplayEventTypeEXT));
}

void marshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSwapchainCounterCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSurfaceCounterFlagsEXT*)&forMarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

void unmarshal_VkSwapchainCounterCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkSwapchainCounterCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSurfaceCounterFlagsEXT*)&forUnmarshaling->surfaceCounters, sizeof(VkSurfaceCounterFlagsEXT));
}

#endif
#ifdef VK_GOOGLE_display_timing
void marshal_VkRefreshCycleDurationGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkRefreshCycleDurationGOOGLE* forMarshaling)
{
    vkStream->write((uint64_t*)&forMarshaling->refreshDuration, sizeof(uint64_t));
}

void unmarshal_VkRefreshCycleDurationGOOGLE(
    VulkanStreamGuest* vkStream,
    VkRefreshCycleDurationGOOGLE* forUnmarshaling)
{
    vkStream->read((uint64_t*)&forUnmarshaling->refreshDuration, sizeof(uint64_t));
}

void marshal_VkPastPresentationTimingGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPastPresentationTimingGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->presentMargin, sizeof(uint64_t));
}

void unmarshal_VkPastPresentationTimingGOOGLE(
    VulkanStreamGuest* vkStream,
    VkPastPresentationTimingGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->actualPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->earliestPresentTime, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->presentMargin, sizeof(uint64_t));
}

void marshal_VkPresentTimeGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPresentTimeGOOGLE* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->presentID, sizeof(uint32_t));
    vkStream->write((uint64_t*)&forMarshaling->desiredPresentTime, sizeof(uint64_t));
}

void unmarshal_VkPresentTimeGOOGLE(
    VulkanStreamGuest* vkStream,
    VkPresentTimeGOOGLE* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->presentID, sizeof(uint32_t));
    vkStream->read((uint64_t*)&forUnmarshaling->desiredPresentTime, sizeof(uint64_t));
}

void marshal_VkPresentTimesInfoGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkPresentTimesInfoGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_320 = (uint64_t)(uintptr_t)forMarshaling->pTimes;
    vkStream->putBe64(cgen_var_320);
    if (forMarshaling->pTimes)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->swapchainCount; ++i)
        {
            marshal_VkPresentTimeGOOGLE(vkStream, (const VkPresentTimeGOOGLE*)(forMarshaling->pTimes + i));
        }
    }
}

void unmarshal_VkPresentTimesInfoGOOGLE(
    VulkanStreamGuest* vkStream,
    VkPresentTimesInfoGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->swapchainCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkPresentTimeGOOGLE* check_pTimes;
    check_pTimes = (const VkPresentTimeGOOGLE*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pTimes)
    {
        if (!(check_pTimes))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pTimes inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->swapchainCount; ++i)
        {
            unmarshal_VkPresentTimeGOOGLE(vkStream, (VkPresentTimeGOOGLE*)(forUnmarshaling->pTimes + i));
        }
    }
}

#endif
#ifdef VK_NV_sample_mask_override_coverage
#endif
#ifdef VK_NV_geometry_shader_passthrough
#endif
#ifdef VK_NV_viewport_array2
#endif
#ifdef VK_NVX_multiview_per_view_attributes
void marshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->perViewPositionAllComponents, sizeof(VkBool32));
}

#endif
#ifdef VK_NV_viewport_swizzle
void marshal_VkViewportSwizzleNV(
    VulkanStreamGuest* vkStream,
    const VkViewportSwizzleNV* forMarshaling)
{
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->write((VkViewportCoordinateSwizzleNV*)&forMarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void unmarshal_VkViewportSwizzleNV(
    VulkanStreamGuest* vkStream,
    VkViewportSwizzleNV* forUnmarshaling)
{
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->x, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->y, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->z, sizeof(VkViewportCoordinateSwizzleNV));
    vkStream->read((VkViewportCoordinateSwizzleNV*)&forUnmarshaling->w, sizeof(VkViewportCoordinateSwizzleNV));
}

void marshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineViewportSwizzleStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->write((uint32_t*)&forMarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_322 = (uint64_t)(uintptr_t)forMarshaling->pViewportSwizzles;
    vkStream->putBe64(cgen_var_322);
    if (forMarshaling->pViewportSwizzles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->viewportCount; ++i)
        {
            marshal_VkViewportSwizzleNV(vkStream, (const VkViewportSwizzleNV*)(forMarshaling->pViewportSwizzles + i));
        }
    }
}

void unmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkPipelineViewportSwizzleStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineViewportSwizzleStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineViewportSwizzleStateCreateFlagsNV));
    vkStream->read((uint32_t*)&forUnmarshaling->viewportCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkViewportSwizzleNV* check_pViewportSwizzles;
    check_pViewportSwizzles = (const VkViewportSwizzleNV*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pViewportSwizzles)
    {
        if (!(check_pViewportSwizzles))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pViewportSwizzles inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->viewportCount; ++i)
        {
            unmarshal_VkViewportSwizzleNV(vkStream, (VkViewportSwizzleNV*)(forUnmarshaling->pViewportSwizzles + i));
        }
    }
}

#endif
#ifdef VK_EXT_discard_rectangles
void marshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceDiscardRectanglePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxDiscardRectangles, sizeof(uint32_t));
}

void marshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineDiscardRectangleStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->write((VkDiscardRectangleModeEXT*)&forMarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->write((uint32_t*)&forMarshaling->discardRectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_324 = (uint64_t)(uintptr_t)forMarshaling->pDiscardRectangles;
    vkStream->putBe64(cgen_var_324);
    if (forMarshaling->pDiscardRectangles)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->discardRectangleCount; ++i)
        {
            marshal_VkRect2D(vkStream, (const VkRect2D*)(forMarshaling->pDiscardRectangles + i));
        }
    }
}

void unmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkPipelineDiscardRectangleStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineDiscardRectangleStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineDiscardRectangleStateCreateFlagsEXT));
    vkStream->read((VkDiscardRectangleModeEXT*)&forUnmarshaling->discardRectangleMode, sizeof(VkDiscardRectangleModeEXT));
    vkStream->read((uint32_t*)&forUnmarshaling->discardRectangleCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const VkRect2D* check_pDiscardRectangles;
    check_pDiscardRectangles = (const VkRect2D*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pDiscardRectangles)
    {
        if (!(check_pDiscardRectangles))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pDiscardRectangles inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->discardRectangleCount; ++i)
        {
            unmarshal_VkRect2D(vkStream, (VkRect2D*)(forUnmarshaling->pDiscardRectangles + i));
        }
    }
}

#endif
#ifdef VK_EXT_conservative_rasterization
void marshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((float*)&forMarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->write((VkBool32*)&forMarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((float*)&forUnmarshaling->primitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxExtraPrimitiveOverestimationSize, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSizeGranularity, sizeof(float));
    vkStream->read((VkBool32*)&forUnmarshaling->primitiveUnderestimation, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativePointAndLineRasterization, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateTrianglesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->degenerateLinesRasterized, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->fullyCoveredFragmentShaderInputVariable, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->conservativeRasterizationPostDepthCoverage, sizeof(VkBool32));
}

void marshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->write((VkConservativeRasterizationModeEXT*)&forMarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->write((float*)&forMarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

void unmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkPipelineRasterizationConservativeStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineRasterizationConservativeStateCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkPipelineRasterizationConservativeStateCreateFlagsEXT));
    vkStream->read((VkConservativeRasterizationModeEXT*)&forUnmarshaling->conservativeRasterizationMode, sizeof(VkConservativeRasterizationModeEXT));
    vkStream->read((float*)&forUnmarshaling->extraPrimitiveOverestimationSize, sizeof(float));
}

#endif
#ifdef VK_EXT_swapchain_colorspace
#endif
#ifdef VK_EXT_hdr_metadata
void marshal_VkXYColorEXT(
    VulkanStreamGuest* vkStream,
    const VkXYColorEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkXYColorEXT(
    VulkanStreamGuest* vkStream,
    VkXYColorEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkHdrMetadataEXT(
    VulkanStreamGuest* vkStream,
    const VkHdrMetadataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryRed));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryGreen));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->displayPrimaryBlue));
    marshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forMarshaling->whitePoint));
    vkStream->write((float*)&forMarshaling->maxLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->minLuminance, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxContentLightLevel, sizeof(float));
    vkStream->write((float*)&forMarshaling->maxFrameAverageLightLevel, sizeof(float));
}

void unmarshal_VkHdrMetadataEXT(
    VulkanStreamGuest* vkStream,
    VkHdrMetadataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryRed));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryGreen));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->displayPrimaryBlue));
    unmarshal_VkXYColorEXT(vkStream, (VkXYColorEXT*)(&forUnmarshaling->whitePoint));
    vkStream->read((float*)&forUnmarshaling->maxLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->minLuminance, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxContentLightLevel, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->maxFrameAverageLightLevel, sizeof(float));
}

#endif
#ifdef VK_MVK_ios_surface
void marshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    const VkIOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkIOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    uint64_t cgen_var_326 = (uint64_t)(uintptr_t)forMarshaling->pView;
    vkStream->putBe64(cgen_var_326);
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkIOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    VkIOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkIOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkIOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    const void* check_pView;
    check_pView = (const void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pView)
    {
        if (!(check_pView))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pView inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_MVK_macos_surface
void marshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    const VkMacOSSurfaceCreateInfoMVK* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkMacOSSurfaceCreateFlagsMVK*)&forMarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    uint64_t cgen_var_328 = (uint64_t)(uintptr_t)forMarshaling->pView;
    vkStream->putBe64(cgen_var_328);
    if (forMarshaling->pView)
    {
        vkStream->write((const void*)forMarshaling->pView, sizeof(const uint8_t));
    }
}

void unmarshal_VkMacOSSurfaceCreateInfoMVK(
    VulkanStreamGuest* vkStream,
    VkMacOSSurfaceCreateInfoMVK* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkMacOSSurfaceCreateFlagsMVK*)&forUnmarshaling->flags, sizeof(VkMacOSSurfaceCreateFlagsMVK));
    // WARNING PTR CHECK
    const void* check_pView;
    check_pView = (const void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pView)
    {
        if (!(check_pView))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pView inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pView, sizeof(const uint8_t));
    }
}

#endif
#ifdef VK_EXT_external_memory_dma_buf
#endif
#ifdef VK_EXT_queue_family_foreign
#endif
#ifdef VK_EXT_debug_utils
void marshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsObjectNameInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->putString(forMarshaling->pObjectName);
}

void unmarshal_VkDebugUtilsObjectNameInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugUtilsObjectNameInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pObjectName);
}

void marshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsObjectTagInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkObjectType*)&forMarshaling->objectType, sizeof(VkObjectType));
    vkStream->write((uint64_t*)&forMarshaling->objectHandle, sizeof(uint64_t));
    vkStream->write((uint64_t*)&forMarshaling->tagName, sizeof(uint64_t));
    uint64_t cgen_var_330 = (uint64_t)forMarshaling->tagSize;
    vkStream->putBe64(cgen_var_330);
    vkStream->write((const void*)forMarshaling->pTag, forMarshaling->tagSize * sizeof(const uint8_t));
}

void unmarshal_VkDebugUtilsObjectTagInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugUtilsObjectTagInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkObjectType*)&forUnmarshaling->objectType, sizeof(VkObjectType));
    vkStream->read((uint64_t*)&forUnmarshaling->objectHandle, sizeof(uint64_t));
    vkStream->read((uint64_t*)&forUnmarshaling->tagName, sizeof(uint64_t));
    forUnmarshaling->tagSize = (size_t)vkStream->getBe64();
    vkStream->read((void*)forUnmarshaling->pTag, forUnmarshaling->tagSize * sizeof(const uint8_t));
}

void marshal_VkDebugUtilsLabelEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsLabelEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->putString(forMarshaling->pLabelName);
    vkStream->write((float*)forMarshaling->color, 4 * sizeof(float));
}

void unmarshal_VkDebugUtilsLabelEXT(
    VulkanStreamGuest* vkStream,
    VkDebugUtilsLabelEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pLabelName);
    vkStream->read((float*)forUnmarshaling->color, 4 * sizeof(float));
}

void marshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsMessengerCallbackDataEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    vkStream->putString(forMarshaling->pMessageIdName);
    vkStream->write((int32_t*)&forMarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->putString(forMarshaling->pMessage);
    vkStream->write((uint32_t*)&forMarshaling->queueLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_332 = (uint64_t)(uintptr_t)forMarshaling->pQueueLabels;
    vkStream->putBe64(cgen_var_332);
    if (forMarshaling->pQueueLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->queueLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pQueueLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->cmdBufLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_333 = (uint64_t)(uintptr_t)forMarshaling->pCmdBufLabels;
    vkStream->putBe64(cgen_var_333);
    if (forMarshaling->pCmdBufLabels)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->cmdBufLabelCount; ++i)
        {
            marshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forMarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->write((uint32_t*)&forMarshaling->objectCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_334 = (uint64_t)(uintptr_t)forMarshaling->pObjects;
    vkStream->putBe64(cgen_var_334);
    if (forMarshaling->pObjects)
    {
        for (uint32_t i = 0; i < (uint32_t)forMarshaling->objectCount; ++i)
        {
            marshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forMarshaling->pObjects + i));
        }
    }
}

void unmarshal_VkDebugUtilsMessengerCallbackDataEXT(
    VulkanStreamGuest* vkStream,
    VkDebugUtilsMessengerCallbackDataEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugUtilsMessengerCallbackDataFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCallbackDataFlagsEXT));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessageIdName);
    vkStream->read((int32_t*)&forUnmarshaling->messageIdNumber, sizeof(int32_t));
    vkStream->loadStringInPlace((char**)&forUnmarshaling->pMessage);
    vkStream->read((uint32_t*)&forUnmarshaling->queueLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    VkDebugUtilsLabelEXT* check_pQueueLabels;
    check_pQueueLabels = (VkDebugUtilsLabelEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pQueueLabels)
    {
        if (!(check_pQueueLabels))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pQueueLabels inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->queueLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pQueueLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->cmdBufLabelCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    VkDebugUtilsLabelEXT* check_pCmdBufLabels;
    check_pCmdBufLabels = (VkDebugUtilsLabelEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCmdBufLabels)
    {
        if (!(check_pCmdBufLabels))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pCmdBufLabels inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->cmdBufLabelCount; ++i)
        {
            unmarshal_VkDebugUtilsLabelEXT(vkStream, (VkDebugUtilsLabelEXT*)(forUnmarshaling->pCmdBufLabels + i));
        }
    }
    vkStream->read((uint32_t*)&forUnmarshaling->objectCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    VkDebugUtilsObjectNameInfoEXT* check_pObjects;
    check_pObjects = (VkDebugUtilsObjectNameInfoEXT*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pObjects)
    {
        if (!(check_pObjects))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pObjects inconsistent between guest and host\n");
        }
        for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->objectCount; ++i)
        {
            unmarshal_VkDebugUtilsObjectNameInfoEXT(vkStream, (VkDebugUtilsObjectNameInfoEXT*)(forUnmarshaling->pObjects + i));
        }
    }
}

void marshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDebugUtilsMessengerCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDebugUtilsMessengerCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->write((VkDebugUtilsMessageSeverityFlagsEXT*)&forMarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->write((VkDebugUtilsMessageTypeFlagsEXT*)&forMarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    uint64_t cgen_var_338 = (uint64_t)forMarshaling->pfnUserCallback;
    vkStream->putBe64(cgen_var_338);
    // WARNING PTR CHECK
    uint64_t cgen_var_339 = (uint64_t)(uintptr_t)forMarshaling->pUserData;
    vkStream->putBe64(cgen_var_339);
    if (forMarshaling->pUserData)
    {
        vkStream->write((void*)forMarshaling->pUserData, sizeof(uint8_t));
    }
}

void unmarshal_VkDebugUtilsMessengerCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDebugUtilsMessengerCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDebugUtilsMessengerCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkDebugUtilsMessengerCreateFlagsEXT));
    vkStream->read((VkDebugUtilsMessageSeverityFlagsEXT*)&forUnmarshaling->messageSeverity, sizeof(VkDebugUtilsMessageSeverityFlagsEXT));
    vkStream->read((VkDebugUtilsMessageTypeFlagsEXT*)&forUnmarshaling->messageType, sizeof(VkDebugUtilsMessageTypeFlagsEXT));
    forUnmarshaling->pfnUserCallback = (PFN_vkDebugUtilsMessengerCallbackEXT)vkStream->getBe64();
    // WARNING PTR CHECK
    void* check_pUserData;
    check_pUserData = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pUserData)
    {
        if (!(check_pUserData))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pUserData inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pUserData, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
void marshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferUsageANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint64_t*)&forMarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void unmarshal_VkAndroidHardwareBufferUsageANDROID(
    VulkanStreamGuest* vkStream,
    VkAndroidHardwareBufferUsageANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->androidHardwareBufferUsage, sizeof(uint64_t));
}

void marshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceSize*)&forMarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkAndroidHardwareBufferPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    VkAndroidHardwareBufferPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->allocationSize, sizeof(VkDeviceSize));
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    const VkAndroidHardwareBufferFormatPropertiesANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
    vkStream->write((VkFormatFeatureFlags*)&forMarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    marshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forMarshaling->samplerYcbcrConversionComponents));
    vkStream->write((VkSamplerYcbcrModelConversion*)&forMarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->write((VkSamplerYcbcrRange*)&forMarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->write((VkChromaLocation*)&forMarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void unmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(
    VulkanStreamGuest* vkStream,
    VkAndroidHardwareBufferFormatPropertiesANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
    vkStream->read((VkFormatFeatureFlags*)&forUnmarshaling->formatFeatures, sizeof(VkFormatFeatureFlags));
    unmarshal_VkComponentMapping(vkStream, (VkComponentMapping*)(&forUnmarshaling->samplerYcbcrConversionComponents));
    vkStream->read((VkSamplerYcbcrModelConversion*)&forUnmarshaling->suggestedYcbcrModel, sizeof(VkSamplerYcbcrModelConversion));
    vkStream->read((VkSamplerYcbcrRange*)&forUnmarshaling->suggestedYcbcrRange, sizeof(VkSamplerYcbcrRange));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedXChromaOffset, sizeof(VkChromaLocation));
    vkStream->read((VkChromaLocation*)&forUnmarshaling->suggestedYChromaOffset, sizeof(VkChromaLocation));
}

void marshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    const VkImportAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((AHardwareBuffer*)forMarshaling->buffer, sizeof(AHardwareBuffer));
}

void unmarshal_VkImportAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    VkImportAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((AHardwareBuffer*)forUnmarshaling->buffer, sizeof(AHardwareBuffer));
}

void marshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_342;
    vkStream->handleMapping()->mapHandles_VkDeviceMemory_u64(&forMarshaling->memory, &cgen_var_342, 1);
    vkStream->write((uint64_t*)&cgen_var_342, 1 * 8);
}

void unmarshal_VkMemoryGetAndroidHardwareBufferInfoANDROID(
    VulkanStreamGuest* vkStream,
    VkMemoryGetAndroidHardwareBufferInfoANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_343;
    vkStream->read((uint64_t*)&cgen_var_343, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkDeviceMemory(&cgen_var_343, (VkDeviceMemory*)&forUnmarshaling->memory, 1);
}

void marshal_VkExternalFormatANDROID(
    VulkanStreamGuest* vkStream,
    const VkExternalFormatANDROID* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint64_t*)&forMarshaling->externalFormat, sizeof(uint64_t));
}

void unmarshal_VkExternalFormatANDROID(
    VulkanStreamGuest* vkStream,
    VkExternalFormatANDROID* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->externalFormat, sizeof(uint64_t));
}

#endif
#ifdef VK_EXT_sampler_filter_minmax
void marshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSamplerReductionModeCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSamplerReductionModeEXT*)&forMarshaling->reductionMode, sizeof(VkSamplerReductionModeEXT));
}

void unmarshal_VkSamplerReductionModeCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkSamplerReductionModeCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSamplerReductionModeEXT*)&forUnmarshaling->reductionMode, sizeof(VkSamplerReductionModeEXT));
}

void marshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxSingleComponentFormats, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->filterMinmaxImageComponentMapping, sizeof(VkBool32));
}

#endif
#ifdef VK_AMD_gpu_shader_int16
#endif
#ifdef VK_AMD_mixed_attachment_samples
#endif
#ifdef VK_AMD_shader_fragment_mask
#endif
#ifdef VK_EXT_shader_stencil_export
#endif
#ifdef VK_EXT_sample_locations
void marshal_VkSampleLocationEXT(
    VulkanStreamGuest* vkStream,
    const VkSampleLocationEXT* forMarshaling)
{
    vkStream->write((float*)&forMarshaling->x, sizeof(float));
    vkStream->write((float*)&forMarshaling->y, sizeof(float));
}

void unmarshal_VkSampleLocationEXT(
    VulkanStreamGuest* vkStream,
    VkSampleLocationEXT* forUnmarshaling)
{
    vkStream->read((float*)&forUnmarshaling->x, sizeof(float));
    vkStream->read((float*)&forUnmarshaling->y, sizeof(float));
}

void marshal_VkSampleLocationsInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkSampleLocationsInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSampleCountFlagBits*)&forMarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->sampleLocationGridSize));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->sampleLocationsCount; ++i)
    {
        marshal_VkSampleLocationEXT(vkStream, (const VkSampleLocationEXT*)(forMarshaling->pSampleLocations + i));
    }
}

void unmarshal_VkSampleLocationsInfoEXT(
    VulkanStreamGuest* vkStream,
    VkSampleLocationsInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlagBits*)&forUnmarshaling->sampleLocationsPerPixel, sizeof(VkSampleCountFlagBits));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->sampleLocationGridSize));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->sampleLocationsCount; ++i)
    {
        unmarshal_VkSampleLocationEXT(vkStream, (VkSampleLocationEXT*)(forUnmarshaling->pSampleLocations + i));
    }
}

void marshal_VkAttachmentSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    const VkAttachmentSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->attachmentIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkAttachmentSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    VkAttachmentSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkSubpassSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    const VkSubpassSampleLocationsEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->subpassIndex, sizeof(uint32_t));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkSubpassSampleLocationsEXT(
    VulkanStreamGuest* vkStream,
    VkSubpassSampleLocationsEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->subpassIndex, sizeof(uint32_t));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkRenderPassSampleLocationsBeginInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        marshal_VkAttachmentSampleLocationsEXT(vkStream, (const VkAttachmentSampleLocationsEXT*)(forMarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->write((uint32_t*)&forMarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->postSubpassSampleLocationsCount; ++i)
    {
        marshal_VkSubpassSampleLocationsEXT(vkStream, (const VkSubpassSampleLocationsEXT*)(forMarshaling->pPostSubpassSampleLocations + i));
    }
}

void unmarshal_VkRenderPassSampleLocationsBeginInfoEXT(
    VulkanStreamGuest* vkStream,
    VkRenderPassSampleLocationsBeginInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->attachmentInitialSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->attachmentInitialSampleLocationsCount; ++i)
    {
        unmarshal_VkAttachmentSampleLocationsEXT(vkStream, (VkAttachmentSampleLocationsEXT*)(forUnmarshaling->pAttachmentInitialSampleLocations + i));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->postSubpassSampleLocationsCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->postSubpassSampleLocationsCount; ++i)
    {
        unmarshal_VkSubpassSampleLocationsEXT(vkStream, (VkSubpassSampleLocationsEXT*)(forUnmarshaling->pPostSubpassSampleLocations + i));
    }
}

void marshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineSampleLocationsStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->sampleLocationsEnable, sizeof(VkBool32));
    marshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forMarshaling->sampleLocationsInfo));
}

void unmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkPipelineSampleLocationsStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->sampleLocationsEnable, sizeof(VkBool32));
    unmarshal_VkSampleLocationsInfoEXT(vkStream, (VkSampleLocationsInfoEXT*)(&forUnmarshaling->sampleLocationsInfo));
}

void marshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkSampleCountFlags*)&forMarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
    vkStream->write((float*)forMarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->write((uint32_t*)&forMarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->variableSampleLocations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceSampleLocationsPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkSampleCountFlags*)&forUnmarshaling->sampleLocationSampleCounts, sizeof(VkSampleCountFlags));
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
    vkStream->read((float*)forUnmarshaling->sampleLocationCoordinateRange, 2 * sizeof(float));
    vkStream->read((uint32_t*)&forUnmarshaling->sampleLocationSubPixelBits, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->variableSampleLocations, sizeof(VkBool32));
}

void marshal_VkMultisamplePropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkMultisamplePropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    marshal_VkExtent2D(vkStream, (VkExtent2D*)(&forMarshaling->maxSampleLocationGridSize));
}

void unmarshal_VkMultisamplePropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkMultisamplePropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    unmarshal_VkExtent2D(vkStream, (VkExtent2D*)(&forUnmarshaling->maxSampleLocationGridSize));
}

#endif
#ifdef VK_EXT_blend_operation_advanced
void marshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCoherentOperations, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->advancedBlendMaxColorAttachments, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendIndependentBlend, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedSrcColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendNonPremultipliedDstColor, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendCorrelatedOverlap, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->advancedBlendAllOperations, sizeof(VkBool32));
}

void marshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->write((VkBlendOverlapEXT*)&forMarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

void unmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkPipelineColorBlendAdvancedStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->srcPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->dstPremultiplied, sizeof(VkBool32));
    vkStream->read((VkBlendOverlapEXT*)&forUnmarshaling->blendOverlap, sizeof(VkBlendOverlapEXT));
}

#endif
#ifdef VK_NV_fragment_coverage_to_color
void marshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineCoverageToColorStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineCoverageToColorStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageToColorLocation, sizeof(uint32_t));
}

void unmarshal_VkPipelineCoverageToColorStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkPipelineCoverageToColorStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCoverageToColorStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageToColorStateCreateFlagsNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageToColorEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageToColorLocation, sizeof(uint32_t));
}

#endif
#ifdef VK_NV_framebuffer_mixed_samples
void marshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    const VkPipelineCoverageModulationStateCreateInfoNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineCoverageModulationStateCreateFlagsNV*)&forMarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->write((VkCoverageModulationModeNV*)&forMarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->write((VkBool32*)&forMarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->coverageModulationTableCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    uint64_t cgen_var_344 = (uint64_t)(uintptr_t)forMarshaling->pCoverageModulationTable;
    vkStream->putBe64(cgen_var_344);
    if (forMarshaling->pCoverageModulationTable)
    {
        vkStream->write((const float*)forMarshaling->pCoverageModulationTable, forMarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

void unmarshal_VkPipelineCoverageModulationStateCreateInfoNV(
    VulkanStreamGuest* vkStream,
    VkPipelineCoverageModulationStateCreateInfoNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineCoverageModulationStateCreateFlagsNV*)&forUnmarshaling->flags, sizeof(VkPipelineCoverageModulationStateCreateFlagsNV));
    vkStream->read((VkCoverageModulationModeNV*)&forUnmarshaling->coverageModulationMode, sizeof(VkCoverageModulationModeNV));
    vkStream->read((VkBool32*)&forUnmarshaling->coverageModulationTableEnable, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->coverageModulationTableCount, sizeof(uint32_t));
    // WARNING PTR CHECK
    const float* check_pCoverageModulationTable;
    check_pCoverageModulationTable = (const float*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCoverageModulationTable)
    {
        if (!(check_pCoverageModulationTable))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pCoverageModulationTable inconsistent between guest and host\n");
        }
        vkStream->read((float*)forUnmarshaling->pCoverageModulationTable, forUnmarshaling->coverageModulationTableCount * sizeof(const float));
    }
}

#endif
#ifdef VK_NV_fill_rectangle
#endif
#ifdef VK_EXT_post_depth_coverage
#endif
#ifdef VK_EXT_validation_cache
void marshal_VkValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkValidationCacheCreateFlagsEXT*)&forMarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    uint64_t cgen_var_346 = (uint64_t)forMarshaling->initialDataSize;
    vkStream->putBe64(cgen_var_346);
    vkStream->write((const void*)forMarshaling->pInitialData, forMarshaling->initialDataSize * sizeof(const uint8_t));
}

void unmarshal_VkValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkValidationCacheCreateFlagsEXT*)&forUnmarshaling->flags, sizeof(VkValidationCacheCreateFlagsEXT));
    forUnmarshaling->initialDataSize = (size_t)vkStream->getBe64();
    vkStream->read((void*)forUnmarshaling->pInitialData, forUnmarshaling->initialDataSize * sizeof(const uint8_t));
}

void marshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkShaderModuleValidationCacheCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    uint64_t cgen_var_348;
    vkStream->handleMapping()->mapHandles_VkValidationCacheEXT_u64(&forMarshaling->validationCache, &cgen_var_348, 1);
    vkStream->write((uint64_t*)&cgen_var_348, 1 * 8);
}

void unmarshal_VkShaderModuleValidationCacheCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkShaderModuleValidationCacheCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    uint64_t cgen_var_349;
    vkStream->read((uint64_t*)&cgen_var_349, 1 * 8);
    vkStream->handleMapping()->mapHandles_u64_VkValidationCacheEXT(&cgen_var_349, (VkValidationCacheEXT*)&forUnmarshaling->validationCache, 1);
}

#endif
#ifdef VK_EXT_descriptor_indexing
void marshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->bindingCount, sizeof(uint32_t));
    vkStream->write((const VkDescriptorBindingFlagsEXT*)forMarshaling->pBindingFlags, forMarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
}

void unmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->bindingCount, sizeof(uint32_t));
    vkStream->read((VkDescriptorBindingFlagsEXT*)forUnmarshaling->pBindingFlags, forUnmarshaling->bindingCount * sizeof(const VkDescriptorBindingFlagsEXT));
}

void marshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayDynamicIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageTexelBufferArrayNonUniformIndexing, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingSampledImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageImageUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUniformTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingStorageTexelBufferUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingUpdateUnusedWhilePending, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingPartiallyBound, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->descriptorBindingVariableDescriptorCount, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->runtimeDescriptorArray, sizeof(VkBool32));
}

void marshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->write((VkBool32*)&forMarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->write((VkBool32*)&forMarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxUpdateAfterBindDescriptorsInAllPools, sizeof(uint32_t));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderUniformBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderSampledImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageBufferArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderStorageImageArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->shaderInputAttachmentArrayNonUniformIndexingNative, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->robustBufferAccessUpdateAfterBind, sizeof(VkBool32));
    vkStream->read((VkBool32*)&forUnmarshaling->quadDivergentImplicitLod, sizeof(VkBool32));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageDescriptorUpdateAfterBindInputAttachments, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxPerStageUpdateAfterBindResources, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSamplers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffers, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindSampledImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindStorageImages, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxDescriptorSetUpdateAfterBindInputAttachments, sizeof(uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->write((const uint32_t*)forMarshaling->pDescriptorCounts, forMarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->descriptorSetCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)forUnmarshaling->pDescriptorCounts, forUnmarshaling->descriptorSetCount * sizeof(const uint32_t));
}

void marshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStreamGuest* vkStream,
    const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

void unmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(
    VulkanStreamGuest* vkStream,
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxVariableDescriptorCount, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_shader_viewport_index_layer
#endif
#ifdef VK_EXT_global_priority
void marshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkDeviceQueueGlobalPriorityCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkQueueGlobalPriorityEXT*)&forMarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

void unmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkDeviceQueueGlobalPriorityCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkQueueGlobalPriorityEXT*)&forUnmarshaling->globalPriority, sizeof(VkQueueGlobalPriorityEXT));
}

#endif
#ifdef VK_EXT_external_memory_host
void marshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkImportMemoryHostPointerInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkExternalMemoryHandleTypeFlagBits*)&forMarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_350 = (uint64_t)(uintptr_t)forMarshaling->pHostPointer;
    vkStream->putBe64(cgen_var_350);
    if (forMarshaling->pHostPointer)
    {
        vkStream->write((void*)forMarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void unmarshal_VkImportMemoryHostPointerInfoEXT(
    VulkanStreamGuest* vkStream,
    VkImportMemoryHostPointerInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkExternalMemoryHandleTypeFlagBits*)&forUnmarshaling->handleType, sizeof(VkExternalMemoryHandleTypeFlagBits));
    // WARNING PTR CHECK
    void* check_pHostPointer;
    check_pHostPointer = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pHostPointer)
    {
        if (!(check_pHostPointer))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pHostPointer inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pHostPointer, sizeof(uint8_t));
    }
}

void marshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkMemoryHostPointerPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->memoryTypeBits, sizeof(uint32_t));
}

void unmarshal_VkMemoryHostPointerPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkMemoryHostPointerPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->memoryTypeBits, sizeof(uint32_t));
}

void marshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkDeviceSize*)&forMarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

void unmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkDeviceSize*)&forUnmarshaling->minImportedHostPointerAlignment, sizeof(VkDeviceSize));
}

#endif
#ifdef VK_AMD_buffer_marker
#endif
#ifdef VK_AMD_shader_core_properties
void marshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceShaderCorePropertiesAMD* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceShaderCorePropertiesAMD* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->shaderEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->shaderArraysPerEngineCount, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->computeUnitsPerShaderArray, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->simdPerComputeUnit, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->wavefrontSize, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxSgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->sgprAllocationGranularity, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprsPerSimd, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->minVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->maxVgprAllocation, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->vgprAllocationGranularity, sizeof(uint32_t));
}

#endif
#ifdef VK_EXT_vertex_attribute_divisor
void marshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStreamGuest* vkStream,
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void unmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(
    VulkanStreamGuest* vkStream,
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->maxVertexAttribDivisor, sizeof(uint32_t));
}

void marshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStreamGuest* vkStream,
    const VkVertexInputBindingDivisorDescriptionEXT* forMarshaling)
{
    vkStream->write((uint32_t*)&forMarshaling->binding, sizeof(uint32_t));
    vkStream->write((uint32_t*)&forMarshaling->divisor, sizeof(uint32_t));
}

void unmarshal_VkVertexInputBindingDivisorDescriptionEXT(
    VulkanStreamGuest* vkStream,
    VkVertexInputBindingDivisorDescriptionEXT* forUnmarshaling)
{
    vkStream->read((uint32_t*)&forUnmarshaling->binding, sizeof(uint32_t));
    vkStream->read((uint32_t*)&forUnmarshaling->divisor, sizeof(uint32_t));
}

void marshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    const VkPipelineVertexInputDivisorStateCreateInfoEXT* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((const void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forMarshaling->vertexBindingDivisorCount; ++i)
    {
        marshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (const VkVertexInputBindingDivisorDescriptionEXT*)(forMarshaling->pVertexBindingDivisors + i));
    }
}

void unmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(
    VulkanStreamGuest* vkStream,
    VkPipelineVertexInputDivisorStateCreateInfoEXT* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->vertexBindingDivisorCount, sizeof(uint32_t));
    for (uint32_t i = 0; i < (uint32_t)forUnmarshaling->vertexBindingDivisorCount; ++i)
    {
        unmarshal_VkVertexInputBindingDivisorDescriptionEXT(vkStream, (VkVertexInputBindingDivisorDescriptionEXT*)(forUnmarshaling->pVertexBindingDivisors + i));
    }
}

#endif
#ifdef VK_NV_shader_subgroup_partitioned
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
void marshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStreamGuest* vkStream,
    const VkQueueFamilyCheckpointPropertiesNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineStageFlags*)&forMarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void unmarshal_VkQueueFamilyCheckpointPropertiesNV(
    VulkanStreamGuest* vkStream,
    VkQueueFamilyCheckpointPropertiesNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineStageFlags*)&forUnmarshaling->checkpointExecutionStageMask, sizeof(VkPipelineStageFlags));
}

void marshal_VkCheckpointDataNV(
    VulkanStreamGuest* vkStream,
    const VkCheckpointDataNV* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((VkPipelineStageFlagBits*)&forMarshaling->stage, sizeof(VkPipelineStageFlagBits));
    // WARNING PTR CHECK
    uint64_t cgen_var_352 = (uint64_t)(uintptr_t)forMarshaling->pCheckpointMarker;
    vkStream->putBe64(cgen_var_352);
    if (forMarshaling->pCheckpointMarker)
    {
        vkStream->write((void*)forMarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

void unmarshal_VkCheckpointDataNV(
    VulkanStreamGuest* vkStream,
    VkCheckpointDataNV* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((VkPipelineStageFlagBits*)&forUnmarshaling->stage, sizeof(VkPipelineStageFlagBits));
    // WARNING PTR CHECK
    void* check_pCheckpointMarker;
    check_pCheckpointMarker = (void*)(uintptr_t)vkStream->getBe64();
    if (forUnmarshaling->pCheckpointMarker)
    {
        if (!(check_pCheckpointMarker))
        {
            fprintf(stderr, "fatal: forUnmarshaling->pCheckpointMarker inconsistent between guest and host\n");
        }
        vkStream->read((void*)forUnmarshaling->pCheckpointMarker, sizeof(uint8_t));
    }
}

#endif
#ifdef VK_GOOGLE_address_space
#endif
#ifdef VK_GOOGLE_color_buffer
void marshal_VkImportColorBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkImportColorBufferGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint32_t*)&forMarshaling->colorBuffer, sizeof(uint32_t));
}

void unmarshal_VkImportColorBufferGOOGLE(
    VulkanStreamGuest* vkStream,
    VkImportColorBufferGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint32_t*)&forUnmarshaling->colorBuffer, sizeof(uint32_t));
}

void marshal_VkImportPhysicalAddressGOOGLE(
    VulkanStreamGuest* vkStream,
    const VkImportPhysicalAddressGOOGLE* forMarshaling)
{
    vkStream->write((VkStructureType*)&forMarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size = goldfish_vk_extension_struct_size(forMarshaling->pNext);
    vkStream->putBe32(pNext_size);
    if (pNext_size)
    {
        vkStream->write((void*)forMarshaling->pNext, sizeof(VkStructureType));
        marshal_extension_struct(vkStream, forMarshaling->pNext);
    }
    vkStream->write((uint64_t*)&forMarshaling->physicalAddress, sizeof(uint64_t));
    vkStream->write((VkDeviceSize*)&forMarshaling->size, sizeof(VkDeviceSize));
    vkStream->write((VkFormat*)&forMarshaling->format, sizeof(VkFormat));
    vkStream->write((VkImageTiling*)&forMarshaling->tiling, sizeof(VkImageTiling));
    vkStream->write((uint32_t*)&forMarshaling->tilingParameter, sizeof(uint32_t));
}

void unmarshal_VkImportPhysicalAddressGOOGLE(
    VulkanStreamGuest* vkStream,
    VkImportPhysicalAddressGOOGLE* forUnmarshaling)
{
    vkStream->read((VkStructureType*)&forUnmarshaling->sType, sizeof(VkStructureType));
    size_t pNext_size;
    pNext_size = vkStream->getBe32();
    if (pNext_size)
    {
        uint64_t pNext_placeholder;
        vkStream->read((void*)(&pNext_placeholder), sizeof(VkStructureType));
        unmarshal_extension_struct(vkStream, (void*)(forUnmarshaling->pNext));
    }
    vkStream->read((uint64_t*)&forUnmarshaling->physicalAddress, sizeof(uint64_t));
    vkStream->read((VkDeviceSize*)&forUnmarshaling->size, sizeof(VkDeviceSize));
    vkStream->read((VkFormat*)&forUnmarshaling->format, sizeof(VkFormat));
    vkStream->read((VkImageTiling*)&forUnmarshaling->tiling, sizeof(VkImageTiling));
    vkStream->read((uint32_t*)&forUnmarshaling->tilingParameter, sizeof(uint32_t));
}

#endif
#ifdef VK_GOOGLE_sized_descriptor_update_template
#endif
#ifdef VK_GOOGLE_async_command_buffers
#endif
void marshal_extension_struct(
    VulkanStreamGuest* vkStream,
    const void* structExtension)
{
    if (!structExtension)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            marshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceSubgroupProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            marshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            marshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<const VkMemoryDedicatedRequirements*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            marshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<const VkMemoryDedicatedAllocateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            marshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<const VkMemoryAllocateFlagsInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            marshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupRenderPassBeginInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            marshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<const VkDeviceGroupCommandBufferBeginInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            marshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<const VkDeviceGroupSubmitInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            marshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<const VkDeviceGroupBindSparseInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            marshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindBufferMemoryDeviceGroupInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            marshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<const VkBindImageMemoryDeviceGroupInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            marshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<const VkDeviceGroupDeviceCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            marshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<const VkPhysicalDeviceFeatures2*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            marshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<const VkPhysicalDevicePointClippingProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            marshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            marshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<const VkImageViewUsageCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            marshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            marshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<const VkRenderPassMultiviewCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            marshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            marshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            marshal_VkPhysicalDeviceVariablePointerFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceVariablePointerFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            marshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            marshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            marshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<const VkProtectedSubmitInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            marshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            marshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<const VkBindImagePlaneMemoryInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            marshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<const VkImagePlaneMemoryRequirementsInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            marshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            marshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            marshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            marshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<const VkExternalImageFormatProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            marshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<const VkPhysicalDeviceIDProperties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            marshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            marshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<const VkExternalMemoryBufferCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            marshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            marshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<const VkExportFenceCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            marshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<const VkExportSemaphoreCreateInfo*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            marshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<const VkPhysicalDeviceMaintenance3Properties*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            marshal_VkPhysicalDeviceShaderDrawParameterFeatures(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            marshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkImageSwapchainCreateInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            marshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<const VkBindImageMemorySwapchainInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            marshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupPresentInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            marshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            marshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<const VkDisplayPresentInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            marshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<const VkImportMemoryFdInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            marshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            marshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<const VkD3D12FenceSubmitInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            marshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            marshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<const VkPresentRegionsKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            marshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            marshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<const VkExportFenceWin32HandleInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            marshal_VkImageFormatListCreateInfoKHR(vkStream, reinterpret_cast<const VkImageFormatListCreateInfoKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            marshal_VkPhysicalDevice8BitStorageFeaturesKHR(vkStream, reinterpret_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            marshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<const VkNativeBufferANDROID*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            marshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugReportCallbackCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            marshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationImageCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            marshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            marshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<const VkTextureLODGatherFormatPropertiesAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            marshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<const VkExternalMemoryImageCreateInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            marshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<const VkExportMemoryAllocateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            marshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkImportMemoryWin32HandleInfoNV*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            marshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<const VkExportMemoryWin32HandleInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            marshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            marshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<const VkValidationFlagsEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            marshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            marshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<const VkSwapchainCounterCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            marshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<const VkPresentTimesInfoGOOGLE*>(structExtension));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            marshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            marshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            marshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferUsageANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            marshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            marshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            marshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<const VkExternalFormatANDROID*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            marshal_VkSamplerReductionModeCreateInfoEXT(vkStream, reinterpret_cast<const VkSamplerReductionModeCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            marshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<const VkSampleLocationsInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            marshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            marshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            marshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            marshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(vkStream, reinterpret_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            marshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            marshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            marshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(vkStream, reinterpret_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            marshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            marshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<const VkImportMemoryHostPointerInfoEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            marshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            marshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            marshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            marshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<const VkQueueFamilyCheckpointPropertiesNV*>(structExtension));
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            marshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<const VkImportColorBufferGOOGLE*>(structExtension));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            marshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<const VkImportPhysicalAddressGOOGLE*>(structExtension));
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}

void unmarshal_extension_struct(
    VulkanStreamGuest* vkStream,
    void* structExtension_out)
{
    if (!structExtension_out)
    {
        return;
    }
    uint32_t structType = (uint32_t)goldfish_vk_struct_type(structExtension_out);
    switch(structType)
    {
#ifdef VK_VERSION_1_1
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceSubgroupProperties(vkStream, reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            unmarshal_VkPhysicalDevice16BitStorageFeatures(vkStream, reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            unmarshal_VkMemoryDedicatedRequirements(vkStream, reinterpret_cast<VkMemoryDedicatedRequirements*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            unmarshal_VkMemoryDedicatedAllocateInfo(vkStream, reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            unmarshal_VkMemoryAllocateFlagsInfo(vkStream, reinterpret_cast<VkMemoryAllocateFlagsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            unmarshal_VkDeviceGroupRenderPassBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            unmarshal_VkDeviceGroupCommandBufferBeginInfo(vkStream, reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            unmarshal_VkDeviceGroupSubmitInfo(vkStream, reinterpret_cast<VkDeviceGroupSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            unmarshal_VkDeviceGroupBindSparseInfo(vkStream, reinterpret_cast<VkDeviceGroupBindSparseInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            unmarshal_VkBindBufferMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            unmarshal_VkBindImageMemoryDeviceGroupInfo(vkStream, reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            unmarshal_VkDeviceGroupDeviceCreateInfo(vkStream, reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            unmarshal_VkPhysicalDeviceFeatures2(vkStream, reinterpret_cast<VkPhysicalDeviceFeatures2*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            unmarshal_VkPhysicalDevicePointClippingProperties(vkStream, reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            unmarshal_VkRenderPassInputAttachmentAspectCreateInfo(vkStream, reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            unmarshal_VkImageViewUsageCreateInfo(vkStream, reinterpret_cast<VkImageViewUsageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            unmarshal_VkPipelineTessellationDomainOriginStateCreateInfo(vkStream, reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            unmarshal_VkRenderPassMultiviewCreateInfo(vkStream, reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            unmarshal_VkPhysicalDeviceMultiviewFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceMultiviewProperties(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
        {
            unmarshal_VkPhysicalDeviceVariablePointerFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceVariablePointerFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            unmarshal_VkPhysicalDeviceProtectedMemoryFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceProtectedMemoryProperties(vkStream, reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            unmarshal_VkProtectedSubmitInfo(vkStream, reinterpret_cast<VkProtectedSubmitInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            unmarshal_VkSamplerYcbcrConversionInfo(vkStream, reinterpret_cast<VkSamplerYcbcrConversionInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            unmarshal_VkBindImagePlaneMemoryInfo(vkStream, reinterpret_cast<VkBindImagePlaneMemoryInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            unmarshal_VkImagePlaneMemoryRequirementsInfo(vkStream, reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            unmarshal_VkPhysicalDeviceSamplerYcbcrConversionFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            unmarshal_VkSamplerYcbcrConversionImageFormatProperties(vkStream, reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            unmarshal_VkPhysicalDeviceExternalImageFormatInfo(vkStream, reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            unmarshal_VkExternalImageFormatProperties(vkStream, reinterpret_cast<VkExternalImageFormatProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceIDProperties(vkStream, reinterpret_cast<VkPhysicalDeviceIDProperties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            unmarshal_VkExternalMemoryImageCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            unmarshal_VkExternalMemoryBufferCreateInfo(vkStream, reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            unmarshal_VkExportMemoryAllocateInfo(vkStream, reinterpret_cast<VkExportMemoryAllocateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            unmarshal_VkExportFenceCreateInfo(vkStream, reinterpret_cast<VkExportFenceCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            unmarshal_VkExportSemaphoreCreateInfo(vkStream, reinterpret_cast<VkExportSemaphoreCreateInfo*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            unmarshal_VkPhysicalDeviceMaintenance3Properties(vkStream, reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        {
            unmarshal_VkPhysicalDeviceShaderDrawParameterFeatures(vkStream, reinterpret_cast<VkPhysicalDeviceShaderDrawParameterFeatures*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_swapchain
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            unmarshal_VkImageSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            unmarshal_VkBindImageMemorySwapchainInfoKHR(vkStream, reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            unmarshal_VkDeviceGroupPresentInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            unmarshal_VkDeviceGroupSwapchainCreateInfoKHR(vkStream, reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_display_swapchain
        case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
            unmarshal_VkDisplayPresentInfoKHR(vkStream, reinterpret_cast<VkDisplayPresentInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkImportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportMemoryWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_memory_fd
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
            unmarshal_VkImportMemoryFdInfoKHR(vkStream, reinterpret_cast<VkImportMemoryFdInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            unmarshal_VkWin32KeyedMutexAcquireReleaseInfoKHR(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_semaphore_win32
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportSemaphoreWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            unmarshal_VkD3D12FenceSubmitInfoKHR(vkStream, reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_push_descriptor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
            unmarshal_VkPhysicalDevicePushDescriptorPropertiesKHR(vkStream, reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_incremental_present
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            unmarshal_VkPresentRegionsKHR(vkStream, reinterpret_cast<VkPresentRegionsKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_shared_presentable_image
        case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
            unmarshal_VkSharedPresentSurfaceCapabilitiesKHR(vkStream, reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_external_fence_win32
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            unmarshal_VkExportFenceWin32HandleInfoKHR(vkStream, reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_image_format_list
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {
            unmarshal_VkImageFormatListCreateInfoKHR(vkStream, reinterpret_cast<VkImageFormatListCreateInfoKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_KHR_8bit_storage
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {
            unmarshal_VkPhysicalDevice8BitStorageFeaturesKHR(vkStream, reinterpret_cast<VkPhysicalDevice8BitStorageFeaturesKHR*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_native_buffer
        case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {
            unmarshal_VkNativeBufferANDROID(vkStream, reinterpret_cast<VkNativeBufferANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_report
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            unmarshal_VkDebugReportCallbackCreateInfoEXT(vkStream, reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_rasterization_order
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            unmarshal_VkPipelineRasterizationStateRasterizationOrderAMD(vkStream, reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_dedicated_allocation
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationImageCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationBufferCreateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            unmarshal_VkDedicatedAllocationMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_texture_gather_bias_lod
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            unmarshal_VkTextureLODGatherFormatPropertiesAMD(vkStream, reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
            unmarshal_VkExternalMemoryImageCreateInfoNV(vkStream, reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
            unmarshal_VkExportMemoryAllocateInfoNV(vkStream, reinterpret_cast<VkExportMemoryAllocateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_external_memory_win32
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            unmarshal_VkImportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {
            unmarshal_VkExportMemoryWin32HandleInfoNV(vkStream, reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_win32_keyed_mutex
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {
            unmarshal_VkWin32KeyedMutexAcquireReleaseInfoNV(vkStream, reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_flags
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            unmarshal_VkValidationFlagsEXT(vkStream, reinterpret_cast<VkValidationFlagsEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conditional_rendering
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceConditionalRenderingFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            unmarshal_VkCommandBufferInheritanceConditionalRenderingInfoEXT(vkStream, reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_clip_space_w_scaling
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportWScalingStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_display_control
        case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
            unmarshal_VkSwapchainCounterCreateInfoEXT(vkStream, reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_display_timing
        case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
            unmarshal_VkPresentTimesInfoGOOGLE(vkStream, reinterpret_cast<VkPresentTimesInfoGOOGLE*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NVX_multiview_per_view_attributes
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
            unmarshal_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(vkStream, reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_viewport_swizzle
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineViewportSwizzleStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_discard_rectangles
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceDiscardRectanglePropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineDiscardRectangleStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_conservative_rasterization
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineRasterizationConservativeStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_debug_utils
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            unmarshal_VkDebugUtilsMessengerCreateInfoEXT(vkStream, reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_ANDROID_external_memory_android_hardware_buffer
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {
            unmarshal_VkAndroidHardwareBufferUsageANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {
            unmarshal_VkAndroidHardwareBufferFormatPropertiesANDROID(vkStream, reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {
            unmarshal_VkImportAndroidHardwareBufferInfoANDROID(vkStream, reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {
            unmarshal_VkExternalFormatANDROID(vkStream, reinterpret_cast<VkExternalFormatANDROID*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sampler_filter_minmax
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {
            unmarshal_VkSamplerReductionModeCreateInfoEXT(vkStream, reinterpret_cast<VkSamplerReductionModeCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_sample_locations
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            unmarshal_VkSampleLocationsInfoEXT(vkStream, reinterpret_cast<VkSampleLocationsInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            unmarshal_VkRenderPassSampleLocationsBeginInfoEXT(vkStream, reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineSampleLocationsStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceSampleLocationsPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_blend_operation_advanced
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineColorBlendAdvancedStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_fragment_coverage_to_color
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineCoverageToColorStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_framebuffer_mixed_samples
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            unmarshal_VkPipelineCoverageModulationStateCreateInfoNV(vkStream, reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_validation_cache
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            unmarshal_VkShaderModuleValidationCacheCreateInfoEXT(vkStream, reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_descriptor_indexing
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {
            unmarshal_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(vkStream, reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {
            unmarshal_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {
            unmarshal_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {
            unmarshal_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(vkStream, reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_global_priority
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {
            unmarshal_VkDeviceQueueGlobalPriorityCreateInfoEXT(vkStream, reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_external_memory_host
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            unmarshal_VkImportMemoryHostPointerInfoEXT(vkStream, reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_AMD_shader_core_properties
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            unmarshal_VkPhysicalDeviceShaderCorePropertiesAMD(vkStream, reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_EXT_vertex_attribute_divisor
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            unmarshal_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(vkStream, reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
            unmarshal_VkPipelineVertexInputDivisorStateCreateInfoEXT(vkStream, reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_NV_device_diagnostic_checkpoints
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            unmarshal_VkQueueFamilyCheckpointPropertiesNV(vkStream, reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(structExtension_out));
            break;
        }
#endif
#ifdef VK_GOOGLE_color_buffer
        case VK_STRUCTURE_TYPE_IMPORT_COLOR_BUFFER_GOOGLE:
        {
            unmarshal_VkImportColorBufferGOOGLE(vkStream, reinterpret_cast<VkImportColorBufferGOOGLE*>(structExtension_out));
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_PHYSICAL_ADDRESS_GOOGLE:
        {
            unmarshal_VkImportPhysicalAddressGOOGLE(vkStream, reinterpret_cast<VkImportPhysicalAddressGOOGLE*>(structExtension_out));
            break;
        }
#endif
        default:
        {
            return;
        }
    }
}


} // namespace goldfish_vk
