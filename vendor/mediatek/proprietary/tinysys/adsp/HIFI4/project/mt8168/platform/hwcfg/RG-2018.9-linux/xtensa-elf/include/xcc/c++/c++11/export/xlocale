// xlocale internal header (from <locale>)
#ifndef _XLOCALE_
#define _XLOCALE_
#include <climits>
#include <cstring>
#include <stdexcept>
#include <typeinfo>
#include <xdebug>
#include <xlocinfo>

 #ifndef _DEPRECATED
  #define _DEPRECATED
 #endif /* _DEPRECATED */

_STD_BEGIN

		// TEMPLATE CLASS _Locbase
template<class _Dummy>
	class _Locbase
	{	// define templatized category constants, instantiate on demand
public:
	static const int collate = _M_COLLATE;
	static const int ctype = _M_CTYPE;
	static const int monetary = _M_MONETARY;
	static const int numeric = _M_NUMERIC;
	static const int time = _M_TIME;
	static const int messages = _M_MESSAGES;
	static const int all = _M_ALL;
	static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		// CLASS locale
class locale;
template<class _Facet>
	const _Facet& use_facet(const locale&);

class locale
	: public _Locbase<int>
	{	// nonmutable collection of facets that describe a locale
public:
	typedef int category;

			// CLASS id
	class id
		{	// identifier stamp, unique for each distinct kind of facet
	public:
		id(size_t _Val = 0)
			: _Id(_Val)
			{	// construct with specified stamp value
			}

		operator size_t()
			{	// get stamp, with lazy allocation
			if (_Id == 0)
				{	// still zero, allocate stamp
				_Lockit _Lock(_LOCK_LOCALE);
				if (_Id == 0)
					_Id = ++_Id_cnt;
				}
			return (_Id);
			}

	private:
		id(const id&);	// not defined
		id& operator=(const id&);	// not defined

		size_t _Id;	// the identifier stamp
		static int _Id_cnt;	// static source of unique stamps
		};

	class _Locimp;

			// class facet
	class facet
		{	// base class for all locale facets, performs reference counting
		friend class locale;
		friend class _Locimp;

	public:
		static size_t _Getcat(const facet ** = 0,
			const locale * = 0)
			{	// get category value, or -1 if no corresponding C category
			return ((size_t)(-1));
			}

		void _Incref()
			{	// safely increment the reference count
			_Lockit _Lock(_LOCK_LOCALE);

			if (_Refs < (size_t)(-1))
				++_Refs;
			}

		facet *_Decref()
			{	// safely decrement the reference count, return this when dead
			_Lockit _Lock(_LOCK_LOCALE);

			if (0 < _Refs && _Refs < (size_t)(-1))
				--_Refs;
			return (_Refs == 0 ? this : 0);
			}

		void _Register();	// queue up lazy facet for destruction

	_PROTECTED:
		virtual ~facet()
			{	// destroy the object
			}

	protected:
		explicit facet(size_t _Initrefs = 0)
			: _Refs(_Initrefs)
			{	// construct with initial reference count
			}

	private:
		facet(const facet&);	// not defined
		facet& operator=(const facet&);	// not defined

		size_t _Refs;	// the reference count
		};

			// CLASS _Locimp
	class _Locimp
		: public facet
		{	// reference-counted actual implementation of a locale
	_PROTECTED:
		~_Locimp();	// destroy the object

	private:
		friend class locale;

		_Locimp(bool _Transparent = false);	// construct from current locale

		_Locimp(const _Locimp&);	// copy a _Locimp

		void _Addfac(facet *, size_t);	// add a facet

		static _Locimp *_Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make essential facets

		static void _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make wchar_t facets

		static void _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make remaining facets

		facet **_Facetvec;	// pointer to vector of facets
		size_t _Facetcount;	// size of vector of facets
		category _Catmask;	// mask describing implemented categories
		bool _Xparent;	// true if locale is transparent
		_STRING_CRT _Name;	// locale name, or "*" if not known
		static _Locimp *_Clocptr;	// pointer to "C" locale object
		};

	_DEPRECATED locale& _Addfac(facet *, size_t,
		size_t);	// add a facet, copying on write

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>&,
			const basic_string<_Elem, _Traits, _Alloc>&)
				const;	// compare strings

export
	template<class _Facet>
		locale combine(const locale& _Loc) const;

export
	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr);

	locale() _THROW0();	// construct from current locale

	locale(_Uninitialized)
		{	// defer construction
		}

	locale(const locale& _Right) _THROW0()
		: _Ptr(_Right._Ptr)
		{	// construct by copying
		_Ptr->_Incref();
		}

	locale(const locale&, const locale&,
		category);	// construct from locale and category in another locale

	explicit locale(const char *,
		category = all);	// construct from named locale for category

	locale(const locale&, const char *,
		category);	// construct from locale and category in named locale

	~locale() _THROW0()
		{	// destroy the object
		if (_Ptr != 0)
			_DELETE_CRT(_Ptr->_Decref());
		}

	locale& operator=(const locale& _Right) _THROW0()
		{	// assign a locale
		if (_Ptr != _Right._Ptr)
			{	// different implementation, point at new one
			_DELETE_CRT(_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string name() const
		{	// return locale name
		return (_Ptr->_Name);
		}

	const facet *_Getfacet(size_t) const;	// get facet by id

	bool operator==(const locale&) const;	// test for locale equality

	bool operator!=(const locale& _Right) const
		{	// test for locale inequality
		return (!(*this == _Right));
		}

	static const locale& classic();	// return classic "C" locale

	static locale global(const locale&);	// return current locale

	static locale empty();	// return empty (transparent) locale

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	// construct from _Locimp pointer
		}

	static _Locimp *_Init();	// initialize locale

	_Locimp *_Ptr;	// pointer to locale implementation object
	};

		// SUPPORT TEMPLATES
template<class _Facet>
	struct _Facetptr
	{	// store pointer to lazy facet for use_facet
	static const locale::facet *_Psave;
	};

template<class _Facet>
	const locale::facet *_Facetptr<_Facet>::_Psave = 0;

 #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */

 #define _USE(loc, fac)	\
	use_facet<fac >(loc)	/* get facet reference from locale */

export
template<class _Facet>
	const _Facet& use_facet(const locale& _Loc);

		// TEMPLATE FUNCTION _Getloctxt
export
template<class _Elem,
	class _InIt>
	int _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr);

		// TEMPLATE FUNCTION _Maklocbyte
#define _MAKLOCBYTE(Elem, chr, cvt) \
	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */

template<class _Elem> inline
	char _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	// convert _Elem to char using _Cvtvec
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert wchar_t to char using _Cvtvec
	char _Byte = '\0';
	_Mbstinit(_Mbst1);
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

		// TEMPLATE FUNCTION _Maklocchr
#define _MAKLOCCHR(Elem, chr, cvt) \
	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */

template<class _Elem> inline
	_Elem _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert char to _Elem using _Cvtvec
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert char to wchar_t using _Cvtvec
	wchar_t _Wc = L'\0';
	_Mbstinit(_Mbst1);
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

		// TEMPLATE FUNCTION _Maklocstr
#define _MAKLOCSTR(Elem, str, cvt)	\
	_Maklocstr(str, (Elem *)0, cvt)	/* convert C string to Elem sequence */

export
template<class _Elem>
	_Elem *_Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&);

template<> inline
	wchar_t *_Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert C string to wchar_t sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	_Mbstinit(_Mbst1);

	_Count1 = _CSTD strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	_Mbstinit(_Mbst2);
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return (_Ptrdest);
	}

		// STRUCT codecvt_base
class codecvt_base
	: public locale::facet
	{	// base class for codecvt
public:
	enum
		{	// constants for different parse states
		ok, partial, error, noconv};
	typedef int result;

	codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	bool always_noconv() const _THROW0()
		{	// return true if conversions never change input (from codecvt)
		return (do_always_noconv());
		}

	int max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (do_max_length());
		}

	int encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (do_encoding());
		}

	~codecvt_base()
		{	// destroy the object
		}

protected:
	virtual bool do_always_noconv() const _THROW0()
		{	// return true if conversions never change input (from codecvt)
		return (true);
		}

	virtual int do_max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (1);
		}

	virtual int do_encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (1);	// -1 ==> state dependent, 0 ==> varying length
		}
	};

		// TEMPLATE CLASS codecvt
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	// facet for converting between _Elem and char (_Byte) sequences
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static locale::id id;	// unique facet id

	explicit codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->name()));
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual ~codecvt()
		{	// destroy the object
		}

protected:
	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual result do_in(_Statype&,
		const _Byte *_First1, const _Byte *, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual result do_out(_Statype&,
		const _Elem *_First1, const _Elem *, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual result do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual int do_length(const _Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
		}
	};

		// STATIC codecvt::id OBJECT
template<class _Elem,
	class _Byte,
	class _Statype>
	locale::id codecvt<_Elem, _Byte, _Statype>::id;

		// CLASS codecvt<wchar_t, char, _Mbstatet>
template<> class codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between wchar_t and char (_Byte) sequences
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static locale::id id;	// unique facet id

	explicit codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->name()));
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual ~codecvt()
		{	// destroy the object
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	// failed conversion
				return (error);

			case 0:	// may have converted null character
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	// destination too small, convert into buffer
				_Byte _Buf[MB_LEN_MAX];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	// copy converted bytes from buffer
					_CSTD memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_DEBUG_RANGE(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[MB_LEN_MAX];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			_CSTD memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int do_length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))

 #if _HAS_STRICT_CONFORMANCE
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

 #else /* _HAS_STRICT_CONFORMANCE */
		_DEBUG_RANGE(_First1, _Last1);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	// convert another wchar_t
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				return (_Wchars);

			case -1:	// failed conversion
				return (_Wchars);

			case 0:	// may have converted null character
				if (_Ch == (_Elem)0)
					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
 #endif /* _HAS_STRICT_CONFORMANCE */

		}

	virtual bool do_always_noconv() const _THROW0()
		{	// return true if conversions never change input
		return (false);
		}

	virtual int do_max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (MB_LEN_MAX);
		}

	virtual int do_encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (0);
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};

		// TEMPLATE CLASS codecvt_byname
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	// codecvt for named locale
public:
	explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

_PROTECTED:
	virtual ~codecvt_byname()
		{	// destroy the object
		}
	};

		// STRUCT ctype_base
struct ctype_base
	: public locale::facet
	{	// base for ctype
	enum
		{	// constants for character classifications
		alnum = _DI|_LO|_UP|_XA, alpha = _LO|_UP|_XA,
		cntrl = _BB, digit = _DI, graph = _DI|_LO|_PU|_UP|_XA,
		lower = _LO, print = _DI|_LO|_PU|_SP|_UP|_XA|_XD,
		punct = _PU, space = _CN|_SP|_XS, upper = _UP,
		xdigit = _XD};
	typedef short mask;	// to match <ctype.h>

	ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	~ctype_base()
		{	// destroy the object
		}
	};

		// TEMPLATE CLASS ctype
export
template<class _Elem>
	class ctype
		: public ctype_base
	{	// facet for classifying elements, converting cases
public:
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;	// unique facet id

	explicit ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>(
				_Locinfo(_Ploc->name()));
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual ~ctype()
		{	// destroy the object
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		}

	virtual bool do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem *do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem *do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const;

	virtual const _Elem *do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const;

	virtual _Elem do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem *do_tolower(_Elem *_First, const _Elem *_Last) const;

	virtual _Elem do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem *do_toupper(_Elem *_First, const _Elem *_Last) const;

	virtual _Elem do_widen(char _Byte) const
		{	// widen char
		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
		}

	virtual const char *do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const;

	char _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem *do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const;

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// STATIC ctype::id OBJECT
template<class _Elem>
	locale::id ctype<_Elem>::id;

		// CLASS ctype<char>
template<> class ctype<char>
	: public ctype_base
	{	// facet for classifying char elements, converting cases
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem *is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem *scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem *scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const _Elem *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;	// unique facet id

	explicit ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct with specified table and delete flag for table
		_Init(_Locinfo());
		if (_Table != 0)
			{	// replace existing char to mask table
			_Tidy();
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>(
				_Locinfo(_Ploc->name()));
		return (_X_CTYPE);
		}

	static const size_t table_size;	// size of _Ctype._Table (char to mask)

_PROTECTED:
	virtual ~ctype()
		{	// destroy the object
		_Tidy();
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj

 #if __BORLANDC__	/* compiler test */
		*(size_t *)&table_size = 1 << CHAR_BIT;	// force space reservation
 #endif /* __BORLANDC__ */

		_Ctype = _Lobj._Getctype();
		}

	void _Tidy()
		{	// free any allocated storage
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] _Ctype._Table;
		}

	virtual _Elem do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem do_widen(char _Byte) const
		{	// widen char
		return (_Byte);
		}

	virtual const _Elem *do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_CSTD memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem do_narrow(_Elem _Ch, char) const
		{	// narrow char
		return (_Ch);
		}

	virtual const _Elem *do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_CSTD memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	const mask *table() const _THROW0()
		{	// return address of char to mask table
		return (_Ctype._Table);
		}

	static const mask *classic_table() _THROW0()
		{	// return address of char to mask table for "C" locale
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// information
	};

		// CLASS ctype<wchar_t>
template<> class ctype<wchar_t>
	: public ctype_base
	{	// facet for classifying wchar_t elements, converting cases
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char *widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem *narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	static locale::id id;	// unique facet id

	explicit ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>(
				_Locinfo(_Ploc->name()));
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual ~ctype()
		{	// destroy the object
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem *do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem *do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem *do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to lower case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem *do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to upper case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	_Elem _Dowiden(char _Byte) const
		{	// widen char
		_Mbstinit(_Mbst);
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)WEOF : _Wc);
		}

	virtual _Elem do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	virtual const char *do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[MB_LEN_MAX];
		_Mbstinit(_Mbst);
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem *do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// TEMPLATE CLASS ctype_byname
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	// ctype for named locale
public:
	explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	// construct from named locale
		}

_PROTECTED:
	virtual ~ctype_byname()
		{	// destroy the object
		}
	};

		// TEMPLATE CLASS ctype_byname<char>
template<> class ctype_byname<char>
	: public ctype<char>
	{	// ctype_byname<char> for named locale
public:
	explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	// construct from named locale
		}

_PROTECTED:
	virtual ~ctype_byname()
		{	// destroy the object
		}
	};

_STD_END
#endif /* _XLOCALE_ */

/*
 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.01:1611 */
