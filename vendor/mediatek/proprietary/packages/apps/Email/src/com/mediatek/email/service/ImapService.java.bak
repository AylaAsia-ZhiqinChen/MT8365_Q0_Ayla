package com.mediatek.email.service;

import android.app.Service;
import android.content.ContentProviderOperation;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.OperationApplicationException;
import android.database.Cursor;
import android.net.TrafficStats;
import android.net.Uri;
import android.os.IBinder;
import android.os.RemoteException;
import android.os.SystemClock;
import android.text.TextUtils;
import android.text.format.DateUtils;

import com.android.email.LegacyConversions;
import com.android.email.NotificationController;
import com.android.email.mail.Store;
import com.android.email.mail.store.ImapFolder;
import com.android.email.provider.Utilities;
import com.android.email.service.EmailServiceStub;
import com.android.email.service.EmailServiceUtils;
import com.android.email2.ui.MailActivityEmail;
import com.android.emailcommon.Logging;
import com.android.emailcommon.TrafficFlags;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.FetchProfile;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.Folder.FolderType;
import com.android.emailcommon.mail.Folder.MessageRetrievalListener;
import com.android.emailcommon.mail.Folder.MessageUpdateCallbacks;
import com.android.emailcommon.mail.Folder.OpenMode;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.mail.Part;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.EmailContent.SyncColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.service.EmailServiceStatus;
import com.android.emailcommon.service.SearchParams;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.mail.providers.UIProvider;
import com.android.mail.providers.UIProvider.AccountCapabilities;
import com.android.mail.utils.LogUtils;
import com.android.mail.utils.StorageLowState;
import com.mediatek.email.util.ImapMailDownloader;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * This service implementation is an improvement on Google default one.
 * Briefly speaking, methods called within processPendingActionsSynchronous
 * are all changed to corresponding "batch" version that can process array of mails in
 * a folder by one IMAP command for a certain operation. For example, set 10
 * Inbox mails from unread to read status only demand for calling UID.STORE once.
 * With KK SyncManager mechanism, user has more possibility to upsync multiple
 * mails at a time. Hence we can take advantage of the existed ImapFolder batch
 * implementation, to save the battery power and network data.
 */
public class ImapService extends Service {
    // TODO get these from configurations or settings.
    private static final long QUICK_SYNC_WINDOW_MILLIS = DateUtils.DAY_IN_MILLIS;
    private static final long FULL_SYNC_WINDOW_MILLIS = 7 * DateUtils.DAY_IN_MILLIS;
    private static final long FULL_SYNC_INTERVAL_MILLIS = 4 * DateUtils.HOUR_IN_MILLIS;

    private static final int MINIMUM_MESSAGES_TO_SYNC = 10;
    private static final int LOAD_MORE_MIN_INCREMENT = 10;
    private static final int LOAD_MORE_MAX_INCREMENT = 20;
    private static final long INITIAL_WINDOW_SIZE_INCREASE = 24 * 60 * 60 * 1000;

    private static final Flag[] FLAG_LIST_SEEN = new Flag[] { Flag.SEEN };
    private static final Flag[] FLAG_LIST_FLAGGED = new Flag[] { Flag.FLAGGED };
    private static final Flag[] FLAG_LIST_ANSWERED = new Flag[] { Flag.ANSWERED };

    /**
     * Simple cache for last search result mailbox by account and serverId, since the most common
     * case will be repeated use of the same mailbox
     */
    private static long mLastSearchAccountKey = Account.NO_ACCOUNT;
    private static String mLastSearchServerId = null;
    private static Mailbox mLastSearchRemoteMailbox = null;

    /**
     * Cache search results by account; this allows for "load more" support without having to
     * redo the search (which can be quite slow).  SortableMessage is a smallish class, so memory
     * shouldn't be an issue
     */
    private static final HashMap<Long, SortableMessage[]> sSearchResults =
            new HashMap<Long, SortableMessage[]>();

    /**
     * We write this into the serverId field of messages that will never be upsynced.
     */
    private static final String LOCAL_SERVERID_PREFIX = "Local-";

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return Service.START_STICKY;
    }

    /**
     * Create our EmailService implementation here.
     */
    private final EmailServiceStub mBinder = new EmailServiceStub() {

        @Override
        public int searchMessages(long accountId, SearchParams searchParams, long destMailboxId) {
            try {
                return searchMailboxImpl(getApplicationContext(), accountId, searchParams,
                        destMailboxId);
            } catch (MessagingException e) {
                /// M: add log output.
                LogUtils.e(Logging.LOG_TAG, e, "ImapService : searchMessages catch a MessagingException : " + e.getMessage());
            }
            return 0;
        }

        /**
         * M: IMAP partial download fetch an entire message.
         */
        @Override
        public void fetchMessage(long messageId) throws RemoteException {
            if (StorageLowState.checkIfStorageLow(mContext)) {
                LogUtils.e(Logging.LOG_TAG, "Can't create account due to low storage");
                return;
            }

            boolean success = false;

            // 1. Resample the message, in case it disappeared or synced
            // while this command was in queue
            EmailContent.Message message = EmailContent.Message
                    .restoreMessageWithId(mContext, messageId);
            Folder remoteFolder = null;
            // Indicated message body content was truncated or not.
            boolean bodyTruncated = false;

            try {
                if (message == null) {
                    LogUtils.d(Logging.LOG_TAG, "Message is null!");
                    return;
                }
                if (message.mFlagLoaded == EmailContent.Message.FLAG_LOADED_COMPLETE) {
                    throw new MessagingException("Message's flagLoaded is FLAG_LOADED_COMPLETE!");
                }

                // 2. Open the remote folder.
                Account account = Account.restoreAccountWithId(mContext,
                        message.mAccountKey);
                Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext,
                        message.mMailboxKey);
                if (account == null || mailbox == null) {
                    LogUtils.d(Logging.LOG_TAG, "Account or Mailbox is null!");
                    return;
                }

                TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(
                        mContext, account));

                Store remoteStore = Store.getInstance(account, mContext);
                String remoteServerId = mailbox.mServerId;
                // If this is a search result, use the protocolSearchInfo field
                // to get the correct remote location
                if (!TextUtils.isEmpty(message.mProtocolSearchInfo)) {
                    remoteServerId = message.mProtocolSearchInfo;
                }
                remoteFolder = remoteStore.getFolder(remoteServerId);
                remoteFolder.open(OpenMode.READ_WRITE);

                // 3. Set up to download the entire message
                Message remoteMessage = remoteFolder
                        .getMessage(message.mServerId);
                /// M: message on server may deleted, if that just stop UI process and return. @{
                if (remoteMessage == null) {
                    ContentValues cv = new ContentValues(1);
                    cv.put(EmailContent.MessageColumns.FLAGS,
                            message.changeMessageStateFlags(EmailContent.Message.FLAG_LOAD_STATUS_FAILED));
                    message.update(mContext, cv);
                    LogUtils.d(Logging.LOG_TAG, "Message may has deleted on server!");
                    return;
                }
                /// @}
                FetchProfile fp = new FetchProfile();

                fp.add(FetchProfile.Item.ENVELOPE);
                fp.add(FetchProfile.Item.STRUCTURE);
                remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(remoteMessage, viewables, attachments);
                for (Part part : viewables) {
                    fp.clear();
                    fp.add(part);
                    // For IMAP, we should fetch limited message body to avoid OOM.
                    LogUtils.d(Logging.LOG_TAG,
                            " MessagingController : loadMessageForView : IMAP fetch body size = "
                                    + part.getSize());
                    if (part.getSize() > MimeUtility.FETCH_BODY_SIZE_LIMIT) {
                        bodyTruncated = true;
                        remoteFolder.fetch(new Message[] { remoteMessage }, fp,
                                null, MimeUtility.FETCH_BODY_SIZE_LIMIT);
                    } else {
                        remoteFolder.fetch(new Message[] { remoteMessage }, fp,
                                null);
                    }
                }

                // 4. Write to provider
                Utilities.copyOneMessageToProvider(mContext, remoteMessage,
                        account, mailbox,
                        EmailContent.Message.FLAG_LOADED_COMPLETE);
                success = true;
                LogUtils.d(Logging.LOG_TAG, "IMAP fetch message success");
            } catch (MessagingException me) {
                LogUtils.d(Logging.LOG_TAG, "IMAP fetch message failed, " + me.getMessage());
            } finally {
                if (remoteFolder != null) {
                    remoteFolder.close(false);
                }
            }

            /** M: Message may be updated. restore it again @{ */
            message = EmailContent.Message
                    .restoreMessageWithId(mContext, messageId);
            if (message == null) {
                LogUtils.d(Logging.LOG_TAG, "Message is null!!");
                return;
            }
            /** @} */
            int resultStatus = success ? message
                    .changeMessageStateFlags(EmailContent.Message.FLAG_LOAD_STATUS_SUCCESS)
                    : message.changeMessageStateFlags(EmailContent.Message.FLAG_LOAD_STATUS_FAILED);
            // Update FLAG_BODY_TOO_LARGE into this message.
            if (bodyTruncated) {
                LogUtils.d(Logging.LOG_TAG, "IMAP messageId: %d set too large flag", message.mId);
                resultStatus |= EmailContent.Message.FLAG_BODY_TOO_LARGE;
            }
            ContentValues cv = new ContentValues();
            cv.put(EmailContent.MessageColumns.FLAGS, resultStatus);
            message.update(mContext, cv);
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        mBinder.init(this);
        return mBinder;
    }

    /**
     * Start foreground synchronization of the specified folder. This is called by
     * synchronizeMailbox or checkMail.
     * TODO this should use ID's instead of fully-restored objects
     * @return The status code for whether this operation succeeded.
     * @throws MessagingException
     */
    public static synchronized int synchronizeMailboxSynchronous(Context context,
            final Account account, final Mailbox folder, final boolean loadMore,
            final boolean uiRefresh) throws MessagingException {
        TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(context, account));
        NotificationController nc = NotificationController.getInstance(context);
        try {
            processPendingActionsSynchronous(context, account);
            synchronizeMailboxGeneric(context, account, folder, loadMore, uiRefresh);
            // Clear authentication notification for this account
            nc.cancelLoginFailedNotification(account.mId);
        } catch (MessagingException e) {
            if (Logging.LOGD) {
                LogUtils.d(Logging.LOG_TAG, "synchronizeMailboxSynchronous", e);
            }
            if (e instanceof AuthenticationFailedException) {
                // Generate authentication notification
                nc.showLoginFailedNotification(account.mId);
            }
            throw e;
        }
        // TODO: Rather than use exceptions as logic above, return the status and handle it
        // correctly in caller.
        return EmailServiceStatus.SUCCESS;
    }

    /**
     * Lightweight record for the first pass of message sync, where I'm just seeing if
     * the local message requires sync.  Later (for messages that need syncing) we'll do a full
     * readout from the DB.
     */
    private static class LocalMessageInfo {
        private static final int COLUMN_ID = 0;
        private static final int COLUMN_FLAG_READ = 1;
        private static final int COLUMN_FLAG_FAVORITE = 2;
        private static final int COLUMN_FLAG_LOADED = 3;
        private static final int COLUMN_SERVER_ID = 4;
        private static final int COLUMN_FLAGS =  5;
        private static final int COLUMN_TIMESTAMP =  6;
        private static final String[] PROJECTION = new String[] {
            EmailContent.RECORD_ID, MessageColumns.FLAG_READ, MessageColumns.FLAG_FAVORITE,
            MessageColumns.FLAG_LOADED, SyncColumns.SERVER_ID, MessageColumns.FLAGS,
            MessageColumns.TIMESTAMP
        };

        final long mId;
        final boolean mFlagRead;
        final boolean mFlagFavorite;
        final int mFlagLoaded;
        final String mServerId;
        final int mFlags;
        final long mTimestamp;

        public LocalMessageInfo(Cursor c) {
            mId = c.getLong(COLUMN_ID);
            mFlagRead = c.getInt(COLUMN_FLAG_READ) != 0;
            mFlagFavorite = c.getInt(COLUMN_FLAG_FAVORITE) != 0;
            mFlagLoaded = c.getInt(COLUMN_FLAG_LOADED);
            mServerId = c.getString(COLUMN_SERVER_ID);
            mFlags = c.getInt(COLUMN_FLAGS);
            mTimestamp = c.getLong(COLUMN_TIMESTAMP);
            // Note: mailbox key and account key not needed - they are projected for the SELECT
        }
    }

    private static class OldestTimestampInfo {
        private static final int COLUMN_OLDEST_TIMESTAMP = 0;
        private static final String[] PROJECTION = new String[] {
            /// M: TIMESTAMP may not accurate, use SERVER_TIMESTAMP.
            "MIN(" + SyncColumns.SERVER_TIMESTAMP + ")"
        };
    }

    /**
     * Load the structure and body of messages not yet synced
     * @param account the account we're syncing
     * @param remoteFolder the (open) Folder we're working on
     * @param messages an array of Messages we've got headers for
     * @param toMailbox the destination mailbox we're syncing
     * @throws MessagingException
     */
    static void loadUnsyncedMessages(final Context context, final Account account,
            Folder remoteFolder, ArrayList<Message> messages, final Mailbox toMailbox)
            throws MessagingException {

        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.STRUCTURE);
        remoteFolder.fetch(messages.toArray(new Message[messages.size()]), fp, null);
        Message [] oneMessageArray = new Message[1];
        for (Message message : messages) {
            // Build a list of parts we are interested in. Text parts will be downloaded
            // right now, attachments will be left for later.
            ArrayList<Part> viewables = new ArrayList<Part>();
            ArrayList<Part> attachments = new ArrayList<Part>();
            MimeUtility.collectParts(message, viewables, attachments);
            // Download the viewables immediately
            oneMessageArray[0] = message;
            for (Part part : viewables) {
                fp.clear();
                fp.add(part);
                remoteFolder.fetch(oneMessageArray, fp, null);
            }
            // Store the updated message locally and mark it fully loaded
            Utilities.copyOneMessageToProvider(context, message, account, toMailbox,
                    EmailContent.Message.FLAG_LOADED_COMPLETE);
        }
    }

    public static void downloadFlagAndEnvelope(final Context context, final Account account,
            final Mailbox mailbox, Folder remoteFolder, ArrayList<Message> unsyncedMessages,
            HashMap<String, LocalMessageInfo> localMessageMap, final ArrayList<Long> unseenMessages)
            throws MessagingException {
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.FLAGS);
        fp.add(FetchProfile.Item.ENVELOPE);

        final HashMap<String, LocalMessageInfo> localMapCopy;
        if (localMessageMap != null)
            localMapCopy = new HashMap<String, LocalMessageInfo>(localMessageMap);
        else {
            localMapCopy = new HashMap<String, LocalMessageInfo>();
        }

        remoteFolder.fetch(unsyncedMessages.toArray(new Message[unsyncedMessages.size()]), fp,
                new MessageRetrievalListener() {
                    @Override
                    public void messageRetrieved(Message message) {
                        try {
                            // Determine if the new message was already known (e.g. partial)
                            // And create or reload the full message info
                            LocalMessageInfo localMessageInfo =
                                localMapCopy.get(message.getUid());
                            EmailContent.Message localMessage;
                            if (localMessageInfo == null) {
                                localMessage = new EmailContent.Message();
                            } else {
                                localMessage = EmailContent.Message.restoreMessageWithId(
                                        context, localMessageInfo.mId);
                            }

                            if (localMessage != null) {
                                try {
                                    // Copy the fields that are available into the message
                                    LegacyConversions.updateMessageFields(localMessage,
                                            message, account.mId, mailbox.mId);
                                    /// M: Add this flag for IMAP partial download.
                                    if (localMessage.mFlagLoaded == EmailContent.Message.FLAG_LOADED_PARTIAL) {
                                        localMessage.mFlagLoaded = EmailContent.Message.FLAG_LOADED_ENVELOPE;
                                    }
                                    // Commit the message to the local store
                                    Utilities.saveOrUpdate(localMessage, context);
                                    // Track the "new" ness of the downloaded message
                                    if (!message.isSet(Flag.SEEN) && unseenMessages != null) {
                                        unseenMessages.add(localMessage.mId);
                                    }
                                } catch (MessagingException me) {
                                    LogUtils.e(Logging.LOG_TAG,
                                            "Error while copying downloaded message." + me);
                                }
                            }
                        }
                        catch (Exception e) {
                            LogUtils.e(Logging.LOG_TAG,
                                    "Error while storing downloaded message." + e.toString());
                        }
                    }

                    @Override
                    public void loadAttachmentProgress(int progress) {
                    }
                });

    }

    /**
     * Synchronizer for IMAP.
     *
     * TODO Break this method up into smaller chunks.
     *
     * @param account the account to sync
     * @param mailbox the mailbox to sync
     * @param loadMore whether we should be loading more older messages
     * @param uiRefresh whether this request is in response to a user action
     * @throws MessagingException
     */
    private synchronized static void synchronizeMailboxGeneric(final Context context,
            final Account account, final Mailbox mailbox, final boolean loadMore,
            final boolean uiRefresh)
            throws MessagingException {

        LogUtils.d(Logging.LOG_TAG, "synchronizeMailboxGeneric " + account + " " + mailbox + " "
                + loadMore + " " + uiRefresh);

        final ArrayList<Long> unseenMessages = new ArrayList<Long>();

        ContentResolver resolver = context.getContentResolver();

        // 0. We do not ever sync DRAFTS or OUTBOX (down or up)
        if (mailbox.mType == Mailbox.TYPE_DRAFTS || mailbox.mType == Mailbox.TYPE_OUTBOX) {
            return;
        }

        // 1. Figure out what our sync window should be.
        long endDate;

        // We will do a full sync if the user has actively requested a sync, or if it has been
        // too long since the last full sync.
        // If we have rebooted since the last full sync, then we may get a negative
        // timeSinceLastFullSync. In this case, we don't know how long it's been since the last
        // full sync so we should perform the full sync.
        final long timeSinceLastFullSync = SystemClock.elapsedRealtime() -
                mailbox.mLastFullSyncTime;
        final boolean fullSync = (uiRefresh || loadMore ||
                timeSinceLastFullSync >= FULL_SYNC_INTERVAL_MILLIS || timeSinceLastFullSync < 0);

        if (fullSync) {
            // Find the oldest message in the local store. We need our time window to include
            // all messages that are currently present locally.
            endDate = System.currentTimeMillis() - FULL_SYNC_WINDOW_MILLIS;
            Cursor localOldestCursor = null;
            try {
                // b/11520812 Ignore message with timestamp = 0 (which includes NULL)
                localOldestCursor = resolver.query(EmailContent.Message.CONTENT_URI,
                        OldestTimestampInfo.PROJECTION,
                        EmailContent.MessageColumns.ACCOUNT_KEY + "=?" + " AND " +
                                MessageColumns.MAILBOX_KEY + "=? AND " +
                                MessageColumns.TIMESTAMP + "!=0",
                        new String[] {String.valueOf(account.mId), String.valueOf(mailbox.mId)},
                        null);
                if (localOldestCursor != null && localOldestCursor.moveToFirst()) {
                    long oldestLocalMessageDate = localOldestCursor.getLong(
                            OldestTimestampInfo.COLUMN_OLDEST_TIMESTAMP);
                    if (oldestLocalMessageDate > 0) {
                        endDate = Math.min(endDate, oldestLocalMessageDate);
                        LogUtils.d(
                                Logging.LOG_TAG, "oldest local message " + oldestLocalMessageDate);
                    }
                }
            } finally {
                if (localOldestCursor != null) {
                    localOldestCursor.close();
                }
            }
            LogUtils.d(Logging.LOG_TAG, "full sync: original window: now - " + endDate);
        } else {
            // We are doing a frequent, quick sync. This only syncs a small time window, so that
            // we wil get any new messages, but not spend a lot of bandwidth downloading
            // messageIds that we most likely already have.
            endDate = System.currentTimeMillis() - QUICK_SYNC_WINDOW_MILLIS;
            LogUtils.d(Logging.LOG_TAG, "quick sync: original window: now - " + endDate);
        }

        // 2. Open the remote folder and create the remote folder if necessary
        Store remoteStore = Store.getInstance(account, context);
        // The account might have been deleted
        if (remoteStore == null) {
            LogUtils.d(Logging.LOG_TAG, "account is apparently deleted");
            return;
        }
        final Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);

        // If the folder is a "special" folder we need to see if it exists
        // on the remote server. It if does not exist we'll try to create it. If we
        // can't create we'll abort. This will happen on every single Pop3 folder as
        // designed and on Imap folders during error conditions. This allows us
        // to treat Pop3 and Imap the same in this code.
        if (mailbox.mType == Mailbox.TYPE_TRASH || mailbox.mType == Mailbox.TYPE_SENT) {
            if (!remoteFolder.exists()) {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
                    LogUtils.w(Logging.LOG_TAG, "could not create remote folder type %d",
                        mailbox.mType);
                    return;
                }
            }
        }
        remoteFolder.open(OpenMode.READ_WRITE);

        // 3. Trash any remote messages that are marked as trashed locally.
        // TODO - this comment was here, but no code was here.

        // 4. Get the number of messages on the server.
        final int remoteMessageCount = remoteFolder.getMessageCount();

        // 5. Save folder message count locally.
        mailbox.updateMessageCount(context, remoteMessageCount);

        // 6. Get all message Ids in our sync window:
        Message[] remoteMessages;
        remoteMessages = remoteFolder.getMessages(0, endDate, null);
        LogUtils.d(Logging.LOG_TAG, "received " + remoteMessages.length + " messages");

        // 7. See if we need any additional messages beyond our date query range results.
        // If we do, keep increasing the size of our query window until we have
        // enough, or until we have all messages in the mailbox.
        int totalCountNeeded;
        if (loadMore) {
            totalCountNeeded = remoteMessages.length + LOAD_MORE_MIN_INCREMENT;
        } else {
            totalCountNeeded = remoteMessages.length;
            if (fullSync && totalCountNeeded < MINIMUM_MESSAGES_TO_SYNC) {
                totalCountNeeded = MINIMUM_MESSAGES_TO_SYNC;
            }
        }
        LogUtils.d(Logging.LOG_TAG, "need " + totalCountNeeded + " total");

        final int additionalMessagesNeeded = totalCountNeeded - remoteMessages.length;
        if (additionalMessagesNeeded > 0) {
            LogUtils.d(Logging.LOG_TAG, "trying to get " + additionalMessagesNeeded + " more");
            long startDate = endDate - 1;
            Message[] additionalMessages = new Message[0];
            long windowIncreaseSize = INITIAL_WINDOW_SIZE_INCREASE;
            while (additionalMessages.length < additionalMessagesNeeded && endDate > 0) {
                endDate = endDate - windowIncreaseSize;
                if (endDate < 0) {
                    LogUtils.d(Logging.LOG_TAG, "window size too large, this is the last attempt");
                    endDate = 0;
                }
                LogUtils.d(Logging.LOG_TAG,
                        "requesting additional messages from range " + startDate + " - " + endDate);
                additionalMessages = remoteFolder.getMessages(startDate, endDate, null);

                // If don't get enough messages with the first window size expansion,
                // we need to accelerate rate at which the window expands. Otherwise,
                // if there were no messages for several weeks, we'd always end up
                // performing dozens of queries.
                windowIncreaseSize *= 2;
            }

            LogUtils.d(Logging.LOG_TAG, "additionalMessages " + additionalMessages.length);
            if (additionalMessages.length < additionalMessagesNeeded) {
                // We have attempted to load a window that goes all the way back to time zero,
                // but we still don't have as many messages as the server says are in the inbox.
                // This is not expected to happen.
                LogUtils.e(Logging.LOG_TAG, "expected to find " + additionalMessagesNeeded
                        + " more messages, only got " + additionalMessages.length);
            }
            int additionalToKeep = additionalMessages.length;
            if (additionalMessages.length > LOAD_MORE_MAX_INCREMENT) {
                // We have way more additional messages than intended, drop some of them.
                // The last messages are the most recent, so those are the ones we need to keep.
                additionalToKeep = LOAD_MORE_MAX_INCREMENT;
            }

            // Copy the messages into one array.
            Message[] allMessages = new Message[remoteMessages.length + additionalToKeep];
            System.arraycopy(remoteMessages, 0, allMessages, 0, remoteMessages.length);
            // additionalMessages may have more than we need, only copy the last
            // several. These are the most recent messages in that set because
            // of the way IMAP server returns messages.
            System.arraycopy(additionalMessages, additionalMessages.length - additionalToKeep,
                    allMessages, remoteMessages.length, additionalToKeep);
            remoteMessages = allMessages;
        }

        // 8. Get the all of the local messages within the sync window, and create
        // an index of the uids.
        // The IMAP query for messages ignores time, and only looks at the date part of the endDate.
        // So if we query for messages since Aug 11 at 3:00 PM, we can get messages from any time
        // on Aug 11. Our IMAP query results can include messages up to 24 hours older than endDate,
        // or up to 25 hours older at a daylight savings transition.
        // It is important that we have the Id of any local message that could potentially be
        // returned by the IMAP query, or we will create duplicate copies of the same messages.
        // So we will increase our local query range by this much.
        // Note that this complicates deletion: It's not okay to delete anything that is in the
        // localMessageMap but not in the remote result, because we know that we may be getting
        // Ids of local messages that are outside the IMAP query window.
        Cursor localUidCursor = null;
        HashMap<String, LocalMessageInfo> localMessageMap = new HashMap<String, LocalMessageInfo>();
        try {
            // FLAG: There is a problem that causes us to store the wrong date on some messages,
            // so messages get a date of zero. If we filter these messages out and don't put them
            // in our localMessageMap, then we'll end up loading the same message again.
            // See b/10508861
//            final long queryEndDate = endDate - DateUtils.DAY_IN_MILLIS - DateUtils.HOUR_IN_MILLIS;
            final long queryEndDate = 0;
            localUidCursor = resolver.query(
                    EmailContent.Message.CONTENT_URI,
                    LocalMessageInfo.PROJECTION,
                    EmailContent.MessageColumns.ACCOUNT_KEY + "=?"
                            + " AND " + MessageColumns.MAILBOX_KEY + "=?"
                            + " AND " + MessageColumns.TIMESTAMP + ">=?",
                    new String[] {
                            String.valueOf(account.mId),
                            String.valueOf(mailbox.mId),
                            String.valueOf(queryEndDate) },
                    null);
            while (localUidCursor.moveToNext()) {
                LocalMessageInfo info = new LocalMessageInfo(localUidCursor);
                // If the message has no server id, it's local only. This should only happen for
                // mail created on the client that has failed to upsync. We want to ignore such
                // mail during synchronization (i.e. leave it as-is and let the next sync try again
                // to upsync).
                if (!TextUtils.isEmpty(info.mServerId)) {
                    localMessageMap.put(info.mServerId, info);
                }
            }
        } finally {
            if (localUidCursor != null) {
                localUidCursor.close();
            }
        }

        // 9. Get a list of the messages that are in the remote list but not on the
        // local store, or messages that are in the local store but failed to download
        // on the last sync. These are the new messages that we will download.
        // Note, we also skip syncing messages which are flagged as "deleted message" sentinels,
        // because they are locally deleted and we don't need or want the old message from
        // the server.
        final ArrayList<Message> unsyncedMessages = new ArrayList<Message>();
        final HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();
        // Process the messages in the reverse order we received them in. This means that
        // we load the most recent one first, which gives a better user experience.
        for (int i = remoteMessages.length - 1; i >= 0; i--) {
            Message message = remoteMessages[i];
            LogUtils.d(Logging.LOG_TAG, "remote message " + message.getUid());
            remoteUidMap.put(message.getUid(), message);

            LocalMessageInfo localMessage = localMessageMap.get(message.getUid());

            // localMessage == null -> message has never been created (not even headers)
            // mFlagLoaded = UNLOADED -> message created, but none of body loaded
            // mFlagLoaded = PARTIAL -> message created, a "sane" amt of body has been loaded
            // mFlagLoaded = COMPLETE -> message body has been completely loaded
            // mFlagLoaded = DELETED -> message has been deleted
            // Only the first two of these are "unsynced", so let's retrieve them
            if (localMessage == null ||
                    /// M: Do not try to load partial loaded mails here, it will be handled
                     // by "download remaining"
                    (localMessage.mFlagLoaded == EmailContent.Message.FLAG_LOADED_UNLOADED)) {
                unsyncedMessages.add(message);
            }
        }

        // 10. Download basic info about the new/unloaded messages (if any)
        /*
         * Fetch the flags and envelope only of the new messages. This is intended to get us
         * critical data as fast as possible, and then we'll fill in the details.
         */
        if (unsyncedMessages.size() > 0) {
            downloadFlagAndEnvelope(context, account, mailbox, remoteFolder, unsyncedMessages,
                    localMessageMap, unseenMessages);
        }

        // 11. Refresh the flags for any messages in the local store that we didn't just download.
        // TODO This is a bit wasteful because we're also updating any messages we already did get
        // the flags and envelope for previously.
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.FLAGS);
        remoteFolder.fetch(remoteMessages, fp, null);
        boolean remoteSupportsSeen = false;
        boolean remoteSupportsFlagged = false;
        boolean remoteSupportsAnswered = false;
        for (Flag flag : remoteFolder.getPermanentFlags()) {
            if (flag == Flag.SEEN) {
                remoteSupportsSeen = true;
            }
            if (flag == Flag.FLAGGED) {
                remoteSupportsFlagged = true;
            }
            if (flag == Flag.ANSWERED) {
                remoteSupportsAnswered = true;
            }
        }

        // 12. Update SEEN/FLAGGED/ANSWERED (star) flags (if supported remotely - e.g. not for POP3)
        if (remoteSupportsSeen || remoteSupportsFlagged || remoteSupportsAnswered) {
            for (Message remoteMessage : remoteMessages) {
                LocalMessageInfo localMessageInfo = localMessageMap.get(remoteMessage.getUid());
                if (localMessageInfo == null) {
                    continue;
                }
                boolean localSeen = localMessageInfo.mFlagRead;
                boolean remoteSeen = remoteMessage.isSet(Flag.SEEN);
                boolean newSeen = (remoteSupportsSeen && (remoteSeen != localSeen));
                boolean localFlagged = localMessageInfo.mFlagFavorite;
                boolean remoteFlagged = remoteMessage.isSet(Flag.FLAGGED);
                boolean newFlagged = (remoteSupportsFlagged && (localFlagged != remoteFlagged));
                int localFlags = localMessageInfo.mFlags;
                boolean localAnswered = (localFlags & EmailContent.Message.FLAG_REPLIED_TO) != 0;
                boolean remoteAnswered = remoteMessage.isSet(Flag.ANSWERED);
                boolean newAnswered = (remoteSupportsAnswered && (localAnswered != remoteAnswered));
                if (newSeen || newFlagged || newAnswered) {
                    Uri uri = ContentUris.withAppendedId(
                            EmailContent.Message.CONTENT_URI, localMessageInfo.mId);
                    ContentValues updateValues = new ContentValues();
                    updateValues.put(MessageColumns.FLAG_READ, remoteSeen);
                    updateValues.put(MessageColumns.FLAG_FAVORITE, remoteFlagged);
                    if (remoteAnswered) {
                        localFlags |= EmailContent.Message.FLAG_REPLIED_TO;
                    } else {
                        localFlags &= ~EmailContent.Message.FLAG_REPLIED_TO;
                    }
                    updateValues.put(MessageColumns.FLAGS, localFlags);
                    resolver.update(uri, updateValues, null, null);
                }
            }
        }

        // 13. Remove messages that are in the local store and in the current sync window,
        // but no longer on the remote store. Note that localMessageMap can contain messages
        // that are not actually in our sync window. We need to check the timestamp to ensure
        // that it is before deleting.
        for (final LocalMessageInfo info : localMessageMap.values()) {
            // If this message is inside our sync window, and we cannot find it in our list
            // of remote messages, then we know it's been deleted from the server.
            if (info.mTimestamp >= endDate && !remoteUidMap.containsKey(info.mServerId)) {
                // Delete associated data (attachment files)
                // Attachment & Body records are auto-deleted when we delete the Message record
                AttachmentUtilities.deleteAllAttachmentFiles(context, account.mId, info.mId);

                // Delete the message itself
                Uri uriToDelete = ContentUris.withAppendedId(
                        EmailContent.Message.CONTENT_URI, info.mId);
                resolver.delete(uriToDelete, null, null);

                // Delete extra rows (e.g. synced or deleted)
                Uri syncRowToDelete = ContentUris.withAppendedId(
                        EmailContent.Message.UPDATED_CONTENT_URI, info.mId);
                resolver.delete(syncRowToDelete, null, null);
                Uri deletERowToDelete = ContentUris.withAppendedId(
                        EmailContent.Message.UPDATED_CONTENT_URI, info.mId);
                resolver.delete(deletERowToDelete, null, null);
            }
        }

        /** M: Download the mail body in multithread. @{ */
        ImapMailDownloader mailLoader = new ImapMailDownloader();
        mailLoader.loadUnsyncedMessagesInMultiThread(context, account, remoteStore, unsyncedMessages, mailbox);
        /** @} */

        if (fullSync) {
            mailbox.updateLastFullSyncTime(context, SystemClock.elapsedRealtime());
        }

        // 14. Clean up and report results
        remoteFolder.close(false);
    }

    /**
     * Find messages in the updated table that need to be written back to server.
     *
     * Handles:
     *   Read/Unread
     *   Flagged
     *   Append (upload)
     *   Move To Trash
     *   Empty trash
     * TODO:
     *   Move
     *
     * @param account the account to scan for pending actions
     * @throws MessagingException
     */
    private static void processPendingActionsSynchronous(Context context, Account account)
            throws MessagingException {
        TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(context, account));
        String[] accountIdArgs = new String[] { Long.toString(account.mId) };

        // Handle deletes first, it's always better to get rid of things first
        processPendingDeletesSynchronous(context, account, accountIdArgs);

        // Handle uploads (currently, only to sent messages)
        processPendingUploadsSynchronous(context, account, accountIdArgs);

        // Now handle updates / upsyncs
        processPendingUpdatesSynchronous(context, account, accountIdArgs);
    }

    /**
     * Get the mailbox corresponding to the remote location of a message; this will normally be
     * the mailbox whose _id is mailboxKey, except for search results, where we must look it up
     * by serverId.
     *
     * @param message the message in question
     * @return the mailbox in which the message resides on the server
     */
    private static Mailbox getRemoteMailboxForMessage(
            Context context, EmailContent.Message message) {
        // If this is a search result, use the protocolSearchInfo field to get the server info
        if (!TextUtils.isEmpty(message.mProtocolSearchInfo)) {
            long accountKey = message.mAccountKey;
            String protocolSearchInfo = message.mProtocolSearchInfo;
            if (accountKey == mLastSearchAccountKey &&
                    protocolSearchInfo.equals(mLastSearchServerId)) {
                return mLastSearchRemoteMailbox;
            }
            Cursor c = context.getContentResolver().query(Mailbox.CONTENT_URI,
                    Mailbox.CONTENT_PROJECTION, Mailbox.PATH_AND_ACCOUNT_SELECTION,
                    new String[] {protocolSearchInfo, Long.toString(accountKey) },
                    null);
            try {
                if (c.moveToNext()) {
                    Mailbox mailbox = new Mailbox();
                    mailbox.restore(c);
                    mLastSearchAccountKey = accountKey;
                    mLastSearchServerId = protocolSearchInfo;
                    mLastSearchRemoteMailbox = mailbox;
                    return mailbox;
                } else {
                    return null;
                }
            } finally {
                c.close();
            }
        } else {
            return Mailbox.restoreMailboxWithId(context, message.mMailboxKey);
        }
    }

    /**
     * M: Scan for messages that are in the Message_Deletes table, look for differences that
     * we can deal with, and do the work. This "batch" version is substitute for Android
     * default implementation
     */
    private static void processPendingDeletesSynchronous(Context context, Account account,
            String[] accountIdArgs) {
        // Only removed from trash box can update DELETED_CONTENT_URI. So no need to judge
        // if the mailbox type is trash.
        Cursor deletes = context.getContentResolver().query(
                EmailContent.Message.DELETED_CONTENT_URI,
                EmailContent.Message.CONTENT_PROJECTION,
                EmailContent.MessageColumns.ACCOUNT_KEY + "=?", accountIdArgs,
                EmailContent.MessageColumns.MAILBOX_KEY);
        if (deletes == null) {
            return;
        }
        // The set of deleted messages which need to upsync
        List<EmailContent.Message> messageSet = new ArrayList<EmailContent.Message>();

        try {
            // If no deletion, return early
            if (deletes.getCount() == 0) {
                return;
            }
            LogUtils.d(Logging.LOG_TAG, "There are " + deletes.getCount() + " local deleted mails need to upsync");
            // loop through messages marked as deleted
            while (deletes.moveToNext()) {
                EmailContent.Message oldMessage =
                        EmailContent.getContent(context, deletes, EmailContent.Message.class);
                if (oldMessage != null) {
                    messageSet.add(oldMessage);
                }
            }
        } finally {
            deletes.close();
        }

        try {
            if (messageSet.isEmpty()) {
                return;
            }
            Mailbox remoteTrashBox = getRemoteMailboxForMessage(context, messageSet.get(0));
            if (remoteTrashBox == null) {
                return;
            }
            Store remoteStore = Store.getInstance(account, context);
            processPendingDeleteFromTrash(context, remoteStore, remoteTrashBox.mServerId, messageSet);

            // Finally, delete the update
            try {
                ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
                for (EmailContent.Message oldMessage : messageSet) {
                    Uri uri = ContentUris.withAppendedId(EmailContent.Message.DELETED_CONTENT_URI,
                          oldMessage.mId);
                    ops.add(ContentProviderOperation.newDelete(uri).build());
                }
                context.getContentResolver().applyBatch(EmailContent.AUTHORITY, ops);
            } catch (RemoteException re) {
                LogUtils.e(Logging.LOG_TAG, "Error in deleting the deletion updates" + re);
            } catch (OperationApplicationException e) {
                LogUtils.e(Logging.LOG_TAG, "Error in deleting the deletion updates" + e);
            }
        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (MailActivityEmail.DEBUG) {
                LogUtils.d(Logging.LOG_TAG, "Unable to process pending delete: " + me);
            }
        }
    }

    /**
     * Scan for messages that are in Sent, and are in need of upload,
     * and send them to the server. "In need of upload" is defined as:
     *  serverId == null (no UID has been assigned)
     * or
     *  message is in the updated list
     *
     * Note we also look for messages that are moving from drafts->outbox->sent. They never
     * go through "drafts" or "outbox" on the server, so we hang onto these until they can be
     * uploaded directly to the Sent folder.
     */
    private static void processPendingUploadsSynchronous(Context context, Account account,
            String[] accountIdArgs) {
        ContentResolver resolver = context.getContentResolver();
        // Find the Sent folder (since that's all we're uploading for now
        // TODO: Upsync for all folders? (In case a user moves mail from Sent before it is
        // handled. Also, this would generically solve allowing drafts to upload.)
        Cursor mailboxes = resolver.query(Mailbox.CONTENT_URI, Mailbox.ID_PROJECTION,
                MailboxColumns.ACCOUNT_KEY + "=?"
                + " and " + MailboxColumns.TYPE + "=" + Mailbox.TYPE_SENT,
                accountIdArgs, null);
        long lastMessageId = -1;
        try {
            // Defer setting up the store until we know we need to access it
            Store remoteStore = null;
            while (mailboxes.moveToNext()) {
                long mailboxId = mailboxes.getLong(Mailbox.ID_PROJECTION_COLUMN);
                String[] mailboxKeyArgs = new String[] { Long.toString(mailboxId) };
                // Demand load mailbox
                Mailbox mailbox = null;

                // First handle the "new" messages (serverId == null)
                Cursor upsyncs1 = resolver.query(EmailContent.Message.CONTENT_URI,
                        EmailContent.Message.ID_PROJECTION,
                        EmailContent.MessageColumns.MAILBOX_KEY + "=?"
                        + " and (" + EmailContent.MessageColumns.SERVER_ID + " is null"
                        + " or " + EmailContent.MessageColumns.SERVER_ID + "=''" + ")",
                        mailboxKeyArgs,
                        null);
                try {
                    while (upsyncs1.moveToNext()) {
                        // Load the remote store if it will be needed
                        if (remoteStore == null) {
                            remoteStore = Store.getInstance(account, context);
                        }
                        // Load the mailbox if it will be needed
                        if (mailbox == null) {
                            mailbox = Mailbox.restoreMailboxWithId(context, mailboxId);
                            if (mailbox == null) {
                                continue; // Mailbox removed. Move to the next message.
                            }
                        }
                        // upsync the message
                        long id = upsyncs1.getLong(EmailContent.Message.ID_PROJECTION_COLUMN);
                        lastMessageId = id;
                        processUploadMessage(context, remoteStore, mailbox, id);
                    }
                } finally {
                    if (upsyncs1 != null) {
                        upsyncs1.close();
                    }
                }
            }
        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (MailActivityEmail.DEBUG) {
                LogUtils.d(Logging.LOG_TAG, "Unable to process pending upsync for id="
                        + lastMessageId + ": " + me);
            }
        } finally {
            if (mailboxes != null) {
                mailboxes.close();
            }
        }
    }

    /**
     * M: An instance of this class embraces all the
     * "change" information of a message
     */
    private static class DataChangeMessage {
        boolean mChangeRead;
        boolean mChangeFlagged;
        boolean mChangeMailbox;
        boolean mChangeAnswered;

        EmailContent.Message mOldMessage;
        EmailContent.Message mNewMessage;

        Mailbox mMailbox;
    }

    /**
     * M: Scan for messages that are in the Message_Updates table, look for differences that
     * we can deal with, and do the work. This "batch" version is substitute for Android
     * default implementation
     */
    private static void processPendingUpdatesSynchronous(Context context, Account account,
            String[] accountIdArgs) {
        ContentResolver resolver = context.getContentResolver();
        Cursor updates = resolver.query(EmailContent.Message.UPDATED_CONTENT_URI,
                EmailContent.Message.CONTENT_PROJECTION,
                EmailContent.MessageColumns.ACCOUNT_KEY + "=?", accountIdArgs,
                EmailContent.MessageColumns.MAILBOX_KEY);
        if (updates == null) {
            return;
        }

        LogUtils.d(Logging.LOG_TAG, "UpdatesSynchronous update items " + updates.getCount());
        try {
            // Because one IMAP command is merely capable of handling one folder's messages at a time,
            // thus one entry of these Maps is stand for a specific folder's mails' change
            Map<Long, Map<EmailContent.Message, EmailContent.Message>> moveToTrashMessages =
                new HashMap<Long, Map<EmailContent.Message, EmailContent.Message>>();
            Map<Long, List<DataChangeMessage>> dataChangeMessages = new HashMap<Long, List<DataChangeMessage>>();
            List<Long> oldMessageIds = new ArrayList<Long>();

            // Defer setting up the store until we know we need to access it
            Store remoteStore = null;
            // Demand load mailbox (note order-by to reduce thrashing here)
            Mailbox mailbox = null;
            Mailbox oldMailbox = null;
            /// M: For recording the trash serverId
            String trashServerId = null;

            // loop through messages marked as needing updates
            while (updates.moveToNext()) {
                boolean changeMoveToTrash = false;
                boolean changeRead = false;
                boolean changeFlagged = false;
                boolean changeMailbox = false;
                boolean changeAnswered = false;

                EmailContent.Message oldMessage =
                        EmailContent.getContent(context, updates, EmailContent.Message.class);
                EmailContent.Message newMessage =
                        EmailContent.Message.restoreMessageWithId(context, oldMessage.mId);
                if (newMessage != null) {
                    mailbox = Mailbox.restoreMailboxWithId(context, newMessage.mMailboxKey);
                    if (mailbox == null) {
                        continue; // Mailbox removed. Move to the next message.
                    }
                    if (oldMessage.mMailboxKey != newMessage.mMailboxKey) {
                        oldMailbox = Mailbox.restoreMailboxWithId(context, oldMessage.mMailboxKey);
                        LogUtils.d(
                                Logging.LOG_TAG,
                                "UpdatesSynchronous oldMailboxkey %d ServerId %s/ newMailboxKey %d ServerId %s, mailbox type %d",
                                oldMessage.mMailboxKey, oldMailbox.mServerId, newMessage.mMailboxKey,
                                mailbox.mServerId, mailbox.mType);
                        if (mailbox.mType == Mailbox.TYPE_TRASH) {
                            /// M: Record the trash serverId for processPendingMoveToTrash
                            trashServerId = mailbox.mServerId;
                            changeMoveToTrash = true;
                        } else {
                            changeMailbox = true;
                        }
                    }
                    changeRead = oldMessage.mFlagRead != newMessage.mFlagRead;
                    LogUtils.d(Logging.LOG_TAG, "UpdatesSynchronous changeRead from %b to %b", changeRead, newMessage.mFlagRead);
                    changeFlagged = oldMessage.mFlagFavorite != newMessage.mFlagFavorite;
                    changeAnswered = (oldMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO) !=
                            (newMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO);
                }

                // Load the remote store if it will be needed
                if (remoteStore == null &&
                        (changeMoveToTrash || changeRead || changeFlagged || changeMailbox ||
                                changeAnswered)) {
                    remoteStore = Store.getInstance(account, context);
                }

                // Dispatch here for specific change types
                if (changeMoveToTrash) {
                    // Move message to trash
                    if (!moveToTrashMessages.containsKey(oldMessage.mMailboxKey)) {
                        moveToTrashMessages.put(oldMessage.mMailboxKey,
                            new HashMap<EmailContent.Message, EmailContent.Message>());
                    }
                    moveToTrashMessages.get(oldMessage.mMailboxKey).put(oldMessage, newMessage);
                    oldMessageIds.add(oldMessage.mId);
                } else if (changeRead || changeFlagged || changeMailbox || changeAnswered) {
                    DataChangeMessage message = new DataChangeMessage();
                    message.mChangeAnswered = changeAnswered;
                    message.mChangeRead = changeRead;
                    message.mChangeFlagged = changeFlagged;
                    message.mChangeMailbox = changeMailbox;
                    message.mOldMessage = oldMessage;
                    message.mNewMessage = newMessage;
                    message.mMailbox = mailbox;
                    if (!dataChangeMessages.containsKey(oldMessage.mMailboxKey)) {
                        dataChangeMessages.put(oldMessage.mMailboxKey, new ArrayList<DataChangeMessage>());
                    }
                    dataChangeMessages.get(oldMessage.mMailboxKey).add(message);
                    oldMessageIds.add(oldMessage.mId);
                }
            }
            LogUtils.d(Logging.LOG_TAG, "UpdatesSynchronous trashServerId : %s", trashServerId);
            /// M: Use the trashServerId to get remote trash folder for processPendingMoveToTrash
            if (!moveToTrashMessages.isEmpty() && trashServerId != null) {
                processPendingMoveToTrash(context, remoteStore, trashServerId, moveToTrashMessages);
            }

            if (!dataChangeMessages.isEmpty()) {
                processPendingDataChange(context, remoteStore, dataChangeMessages);
            }

            // Finally, delete the update
            // Suppose the update command thrown exception in halfway, this DB deletion would be passed over.
            // The whole update process would execute again later. But don't worried because UID COPY and STORE
            // command would not report error for uid inexistence(as some mails may moved to other folder in
            // the previous upsync)
            try {
                ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
                for (Long id : oldMessageIds) {
                    Uri uri = ContentUris.withAppendedId(EmailContent.Message.UPDATED_CONTENT_URI, id);
                    ops.add(ContentProviderOperation.newDelete(uri).build());
                }
                context.getContentResolver().applyBatch(EmailContent.AUTHORITY, ops);
            } catch (RemoteException re) {
                LogUtils.e(Logging.LOG_TAG, "Error in deleting the updates" + re);
            } catch (OperationApplicationException e) {
                LogUtils.e(Logging.LOG_TAG, "Error in deleting the updates" + e);
            }
        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (MailActivityEmail.DEBUG) {
                LogUtils.d(Logging.LOG_TAG, "Unable to process pending update: " + me);
            }
        } finally {
            updates.close();
        }
    }

    /**
     * Upsync an entire message. This must also unwind whatever triggered it (either by
     * updating the serverId, or by deleting the update record, or it's going to keep happening
     * over and over again.
     *
     * Note: If the message is being uploaded into an unexpected mailbox, we *do not* upload.
     * This is to avoid unnecessary uploads into the trash. Although the caller attempts to select
     * only the Drafts and Sent folders, this can happen when the update record and the current
     * record mismatch. In this case, we let the update record remain, because the filters
     * in processPendingUpdatesSynchronous() will pick it up as a move and handle it (or drop it)
     * appropriately.
     *
     * @param mailbox the actual mailbox
     */
    private static void processUploadMessage(Context context, Store remoteStore, Mailbox mailbox,
            long messageId)
            throws MessagingException {
        EmailContent.Message newMessage =
                EmailContent.Message.restoreMessageWithId(context, messageId);
        final boolean deleteUpdate;
        if (newMessage == null) {
            deleteUpdate = true;
            LogUtils.d(Logging.LOG_TAG, "Upsync failed for null message, id=" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_DRAFTS) {
            deleteUpdate = false;
            LogUtils.d(Logging.LOG_TAG, "Upsync skipped for mailbox=drafts, id=" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_OUTBOX) {
            deleteUpdate = false;
            LogUtils.d(Logging.LOG_TAG, "Upsync skipped for mailbox=outbox, id=" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_TRASH) {
            deleteUpdate = false;
            LogUtils.d(Logging.LOG_TAG, "Upsync skipped for mailbox=trash, id=" + messageId);
        } else if (newMessage.mMailboxKey != mailbox.mId) {
            deleteUpdate = false;
            LogUtils.d(Logging.LOG_TAG, "Upsync skipped; mailbox changed, id=" + messageId);
        } else {
            LogUtils.d(Logging.LOG_TAG, "Upsyc triggered for message id=" + messageId);
            deleteUpdate = processPendingAppend(context, remoteStore, mailbox, newMessage);
        }
        if (deleteUpdate) {
            // Finally, delete the update (if any)
            Uri uri = ContentUris.withAppendedId(
                    EmailContent.Message.UPDATED_CONTENT_URI, messageId);
            context.getContentResolver().delete(uri, null, null);
        }
    }

    /**
     * M: Upsync changes to read, flagged, or mailbox
     *
     * @param context
     * @param remoteStore the remote store for this mailbox
     * @param dataChangeMessages The changes meta-data of messages
     */
    private static void processPendingDataChange(final Context context, Store remoteStore,
            Map<Long, List<DataChangeMessage>> dataChangeMessages) throws MessagingException {
        List<Message> readMessages = new ArrayList<Message>();
        List<Message> unreadMessages = new ArrayList<Message>();
        List<Message> flaggedMessages = new ArrayList<Message>();
        List<Message> unflaggedMessages = new ArrayList<Message>();
        List<Message> answeredMessages = new ArrayList<Message>();
        Map<String, Map<Message, EmailContent.Message>> changeMailboxMessages =
                new HashMap<String, Map<Message, EmailContent.Message>>();

        // Respectively process each source mailbox due to an IMAP command is only for a specific folder at a time
        for (Entry<Long, List<DataChangeMessage>> entry1 : dataChangeMessages.entrySet()) {
            List<DataChangeMessage> messageList = entry1.getValue();

            Mailbox mailbox = getRemoteMailboxForMessage(context, messageList.get(0).mOldMessage);
            // never sync "draft" and "outbox"
            if (mailbox == null || mailbox.mType == Mailbox.TYPE_DRAFTS ||
                    mailbox.mType == Mailbox.TYPE_OUTBOX) {
                continue;
            }

            Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
            if (!openFolder(context, remoteFolder, OpenMode.READ_WRITE, false)) {
                // if open folder failed, continue to handle next folder
                continue;
            }

            for (DataChangeMessage changedMessage : messageList) {
                if (changedMessage.mNewMessage == null || changedMessage.mNewMessage.mServerId == null
                        || changedMessage.mNewMessage.mServerId.equals("")
                        || changedMessage.mNewMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {
                    continue;
                }
                Message remoteMessage = remoteFolder.getMessage(changedMessage.mNewMessage.mServerId);
                if (remoteMessage == null) {
                    // if remote message not found, continue to handle next message
                    continue;
                }
                if (changedMessage.mChangeAnswered) {
                    answeredMessages.add(remoteMessage);
                }
                if (changedMessage.mChangeRead) {
                    if (changedMessage.mNewMessage.mFlagRead) {
                        readMessages.add(remoteMessage);
                    } else {
                        unreadMessages.add(remoteMessage);
                    }
                }
                if (changedMessage.mChangeFlagged) {
                    if (changedMessage.mNewMessage.mFlagFavorite) {
                        flaggedMessages.add(remoteMessage);
                    } else {
                        unflaggedMessages.add(remoteMessage);
                    }
                }
                if (changedMessage.mChangeMailbox) {
                    if (!changeMailboxMessages.containsKey(changedMessage.mMailbox.mServerId)) {
                        changeMailboxMessages.put(changedMessage.mMailbox.mServerId,
                            new HashMap<Message, EmailContent.Message>());
                    }
                    remoteMessage.setMessageId(changedMessage.mNewMessage.mMessageId);
                    changeMailboxMessages.get(changedMessage.mMailbox.mServerId).put(remoteMessage,
                            changedMessage.mNewMessage);
                }
            }

            // Upsync each kind of change
            if (!answeredMessages.isEmpty()) {
                remoteFolder.setFlags(answeredMessages.toArray(new Message[0]), FLAG_LIST_ANSWERED, true);
            }
            if (!readMessages.isEmpty()) {
                remoteFolder.setFlags(readMessages.toArray(new Message[0]), FLAG_LIST_SEEN, true);
            }
            if (!unreadMessages.isEmpty()) {
                remoteFolder.setFlags(unreadMessages.toArray(new Message[0]), FLAG_LIST_SEEN, false);
            }
            if (!flaggedMessages.isEmpty()) {
                remoteFolder.setFlags(flaggedMessages.toArray(new Message[0]), FLAG_LIST_FLAGGED, true);
            }
            if (!unflaggedMessages.isEmpty()) {
                remoteFolder.setFlags(unflaggedMessages.toArray(new Message[0]), FLAG_LIST_FLAGGED, false);
            }

            // It is possible that messages from one folder are moved to different destination folders.
            // Hence, should handle each destination respectively
            if (!changeMailboxMessages.isEmpty()) {
                for (final Entry<String, Map<Message, EmailContent.Message>> move : changeMailboxMessages.entrySet()) {
                    Set<Message> remoteMessages = move.getValue().keySet();
                    Folder toFolder = remoteStore.getFolder(move.getKey());
                    if (!toFolder.exists()) {
                        continue;
                    }
                    remoteFolder.copyMessages(remoteMessages.toArray(new Message[0]), toFolder,
                            new MessageUpdateCallbacks() {
                        @Override
                        public void onMessageUidChange(Message message, String newUid) {
                            ContentValues cv = new ContentValues();
                            cv.put(EmailContent.MessageColumns.SERVER_ID, newUid);
                            // We only have one message, so, any updates _must_ be for it. Otherwise,
                            // we'd have to cycle through to find the one with the same server ID.
                            /// M: TODO: This update would cause delete related record from Message_Update table
                             // (See EmailProvider.update()). This may cause 2 possible side effects: a)Suppose 
                             // network cut off in the mid of coping, the server is just received the copy command
                             // but throw MessagingException before call this callback, then server done the copy on its side.
                             // In this case, Message_Update records would not be removed and the copy will be triggered again
                             // by the client, so server copy again and duplicate mails come out. b) The whole copy process is
                             // over but throw MessagingException before expunge, Message_Update records has been removed and
                             // the source mails would not be deleted on the server. Need to find a practical solution for these
                             // 2 cases in the future.
                            context.getContentResolver().update(ContentUris.withAppendedId(
                                    EmailContent.Message.CONTENT_URI, move.getValue().get(message).mId), cv, null, null);
                        }

                        @Override
                        public void onMessageNotFound(Message message) {
                        }
                    });
                    remoteFolder.setFlags(remoteMessages.toArray(new Message[0]), new Flag[]{Flag.DELETED}, true);
                    remoteFolder.expunge();
                }
            }

            remoteFolder.close(false);
            readMessages.clear();
            unreadMessages.clear();
            flaggedMessages.clear();
            unflaggedMessages.clear();
            answeredMessages.clear();
        }
    }

    /**
     * M: Process the pending move mails to trash
     *
     * @param context
     * @param remoteStore the remote store we're working in
     * @param trashBoxServerId The trash mailbox serverId
     * @param mailboxMessageMap Mapping mailbox folder to the pending mails inside it
     */
    private static void processPendingMoveToTrash(final Context context, Store remoteStore,
            String trashBoxServerId, Map<Long, Map<EmailContent.Message, EmailContent.Message>> mailboxMessageMap)
                throws MessagingException {
        boolean openTrashSuccess = true;
        Folder remoteTrashFolder = remoteStore.getFolder(trashBoxServerId);
        if (!openFolder(context, remoteTrashFolder, OpenMode.READ_WRITE, true)) {
            // Even if open trash folder failed, we are still able to set "DELETE" flag for
            // the mails on the remote source folder and expunge them
            openTrashSuccess = false;
        }

        final Map<Message, EmailContent.Message> remoteMsgToNewMsgMap = new HashMap<Message, EmailContent.Message>();

        // Respectively process each source mailbox due to an IMAP command is only for a specific folder at a time
        for (Entry<Long, Map<EmailContent.Message, EmailContent.Message>> entry1 : mailboxMessageMap.entrySet()) {
            Mailbox oldMailbox = null;
            Folder remoteFolder = null;
            // Process mails in this folder one by one
            for (Entry<EmailContent.Message, EmailContent.Message> entry2 : entry1.getValue().entrySet()) {
                EmailContent.Message oldMessage = entry2.getKey();
                EmailContent.Message newMessage = entry2.getValue();

                // No remote move if the message is local-only
                if (newMessage.mServerId == null || newMessage.mServerId.equals("")
                        || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {
                    continue;
                }
                // Escape early if we can't find the local mailbox
                // TODO smaller projection here
                if (oldMailbox == null) {
                    oldMailbox = getRemoteMailboxForMessage(context, oldMessage);
                    // We don't support delete-from-trash here
                    if (oldMailbox == null || oldMailbox.mType == Mailbox.TYPE_TRASH) {
                        // can't find old mailbox, it may have been deleted.  just to handle next mailbox's messages.
                        break;
                    }
                }
                // The rest of this method handles server-side deletion
                // Find the remote mailbox (that we deleted from), and open it
                if (remoteFolder == null) {
                    remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);
                    if (!openFolder(context, remoteFolder, OpenMode.READ_WRITE, false)) {
                        break;
                    }
                }
                // Find the remote original message
                Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);
                if (remoteMessage == null) {
                    continue;
                }
                remoteMsgToNewMsgMap.put(remoteMessage, newMessage);
            }
            if (openTrashSuccess) {
                // Try to copy the message into the remote trash folder
                // Note, this entire section will be skipped for POP3 because there's no remote trash
                remoteFolder.copyMessages(remoteMsgToNewMsgMap.keySet().toArray(new Message[0]), remoteTrashFolder,
                        new Folder.MessageUpdateCallbacks() {
                    @Override
                    public void onMessageUidChange(Message message, String newUid) {
                        // update the UID in the local trash folder, because some stores will
                        // have to change it when copying to remoteTrashFolder
                        ContentValues cv = new ContentValues();
                        cv.put(EmailContent.MessageColumns.SERVER_ID, newUid);
                        context.getContentResolver().update(remoteMsgToNewMsgMap.get(message).getUri(), cv, null, null);
                    }

                    /**
                     * This will be called if the deleted message doesn't exist and can't be
                     * deleted (e.g. it was already deleted from the server.)  In this case,
                     * attempt to delete the local copy as well.
                     */
                    @Override
                    public void onMessageNotFound(Message message) {
                        context.getContentResolver().delete(remoteMsgToNewMsgMap.get(message).getUri(), null, null);
                    }
                });
            }
            // Delete the message from the remote source folder
            remoteFolder.setFlags(remoteMsgToNewMsgMap.keySet().toArray(new Message[0]), new Flag[]{Flag.DELETED}, true);
            remoteFolder.expunge();
            remoteFolder.close(false);

            remoteMsgToNewMsgMap.clear();
        }

        if (openTrashSuccess) {
            remoteTrashFolder.close(false);
        }
    }

    /**
     * M: Upsync the deleting from trash for mails. This "batch" version is substitute for Android
     * default implementation
     * @param context
     * @param remoteStore the remote store we're working in
     * @param trashBoxServerId Trash mailbox serverId
     * @param messagesToDelete The list of messages that was deleted from the trash
     */
    private static void processPendingDeleteFromTrash(Context context, Store remoteStore, String trashBoxServerId,
            List<EmailContent.Message> messagesToDelete)
            throws MessagingException {
        Folder remoteTrashFolder = remoteStore.getFolder(trashBoxServerId);

        if (!openFolder(context, remoteTrashFolder, OpenMode.READ_WRITE, false)) {
            return;
        }

        List<Message> remoteMessages = new ArrayList<Message>();
        for (EmailContent.Message msg : messagesToDelete) {
            if (TextUtils.isEmpty(msg.mServerId)) {
                continue;
            }
            // Since "UID STORE" ignore the non-exist uids without report error(refer to RFC3501 UID command),
            // so no need to do the getMessage()'s uid search operation to ensure the mail is still on the server.
            remoteMessages.add(remoteTrashFolder.createMessage(msg.mServerId));
        }

        if (!remoteMessages.isEmpty()) {
            remoteTrashFolder.setFlags(remoteMessages.toArray(new Message[0]), new Flag[]{Flag.DELETED}, true);
            remoteTrashFolder.expunge();
        }

        remoteTrashFolder.close(false);
    }

    /**
     * M: Process pending append messages command.
     * In fact, now only "Sent" mailbox goes here. This is just a refactor version
     * of Android default. For message in sent box, only get its internal date from server.
     * It really redundant to upload the local one if server already had its own copy
     *
     * @param context
     * @param remoteStore the remote store we're working in
     * @param mailbox The mailbox we're appending to
     * @param message The message we're appending
     * @return true if successfully uploaded
     */
    private static boolean processPendingAppend(Context context, Store remoteStore, Mailbox mailbox,
            EmailContent.Message message)
            throws MessagingException {
        Date remoteDate = null;
        boolean updateInternalDate = false;

        // 1. Find the remote folder that we're appending to and create and/or open it
        Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
        if (!openFolder(context, remoteFolder, OpenMode.READ_WRITE, true)) {
            return false;
        }

        // 2. If possible, load a remote message with the matching UID
        Message remoteMessage = null;
        boolean sentMessage = false;
        if (message.mServerId != null && message.mServerId.length() > 0) {
            remoteMessage = remoteFolder.getMessage(message.mServerId);
        /**
         * M: Get remote message from server according to messageId. To avoid
         * duplicate mail in sent box. @{
         */
        } else {
            // 2b. Load a remote message with the matching MessageId.
            remoteMessage = ((ImapFolder) remoteFolder).getRemoteMessage(message.mMessageId);
            if (remoteMessage != null) {
                message.mServerId = remoteMessage.getUid();
                sentMessage = true;
                updateInternalDate = true;
            }
        }
        /** @} */

        // 3. If a remote message could not be found, upload our local message
        if (remoteMessage == null) {
            // TODO:
            // if we have a serverId and remoteMessage is still null, then probably the message
            // has been deleted and we should delete locally.
            // 3a. Create a legacy message to upload
            Message localMessage = LegacyConversions.makeMessage(context, message);
            // 3b. Upload it
            //FetchProfile fp = new FetchProfile();
            //fp.add(FetchProfile.Item.BODY);
            // Note that this operation will assign the Uid to localMessage
            remoteFolder.appendMessages(new Message[] { localMessage });

            // 3b. And record the UID from the server
            message.mServerId = localMessage.getUid();

            updateInternalDate = true;
        } else if (!sentMessage) {
            // 4. If the remote message exists we need to determine which copy to keep.
            // TODO:
            // I don't see a good reason we should be here. If the message already has a serverId,
            // then we should be handling it in processPendingUpdates(),
            // not processPendingUploads()
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.ENVELOPE);
            remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
            Date localDate = new Date(message.mServerTimeStamp);
            remoteDate = remoteMessage.getInternalDate();
            if (remoteDate != null) {
                message.mServerTimeStamp = remoteDate.getTime();
            }

            // 4a. M: If the remote message is newer than ours we'll just
            // update the SERVER_TIMESTAMP of the message.
            if (remoteDate == null || remoteDate.compareTo(localDate) < 0) {
                // 4b. Otherwise we'll upload our message and then delete the remote message.

                // Create a legacy message to upload
                // TODO: This strategy has a problem: This will create a second message,
                // so that at least temporarily, we will have two messages for what the
                // user would think of as one.
                Message localMessage = LegacyConversions.makeMessage(context, message);

                // 4c. Upload it
                remoteFolder.appendMessages(new Message[] { localMessage });

                // 4d. Record the UID and new internalDate from the server
                message.mServerId = localMessage.getUid();

                // 4e. And delete the old copy of the message from the server.
                remoteMessage.setFlag(Flag.DELETED, true);

                // due to update the server side copy, need to requery internal date
                updateInternalDate = true;
            }
        }

        // 5. If requested, Best-effort to capture new "internaldate" from the server
        if (updateInternalDate && message.mServerId != null) {
            try {
                Message remoteMessage2 = remoteFolder.getMessage(message.mServerId);
                if (remoteMessage2 != null) {
                    FetchProfile fp2 = new FetchProfile();
                    fp2.add(FetchProfile.Item.ENVELOPE);
                    remoteFolder.fetch(new Message[] { remoteMessage2 }, fp2, null);
                    message.mServerTimeStamp = remoteMessage2.getInternalDate().getTime();
                }
            } catch (MessagingException me) {
                 LogUtils.e(Logging.LOG_TAG, "Error in update internal date" + me);
            }
        }

        // 6. Perform required edits to local copy of message
        Uri uri = ContentUris.withAppendedId(EmailContent.Message.CONTENT_URI, message.mId);
        ContentResolver resolver = context.getContentResolver();
        ContentValues cv = new ContentValues();
        cv.put(EmailContent.MessageColumns.SERVER_ID, message.mServerId);
        cv.put(EmailContent.MessageColumns.SERVER_TIMESTAMP, message.mServerTimeStamp);
        resolver.update(uri, cv, null, null);
        return true;
    }

    /**
     * A message and numeric uid that's easily sortable
     */
    private static class SortableMessage {
        private final Message mMessage;
        private final long mUid;

        SortableMessage(Message message, long uid) {
            mMessage = message;
            mUid = uid;
        }
    }

    private static int searchMailboxImpl(final Context context, final long accountId,
            final SearchParams searchParams, final long destMailboxId) throws MessagingException {
        final Account account = Account.restoreAccountWithId(context, accountId);
        final Mailbox mailbox = Mailbox.restoreMailboxWithId(context, searchParams.mMailboxId);
        final Mailbox destMailbox = Mailbox.restoreMailboxWithId(context, destMailboxId);
        if (account == null || mailbox == null || destMailbox == null) {
            LogUtils.d(Logging.LOG_TAG, "Attempted search for " + searchParams
                    + " but account or mailbox information was missing");
            return 0;
        }

        // Tell UI that we're loading messages
        final ContentValues statusValues = new ContentValues(2);
        statusValues.put(Mailbox.UI_SYNC_STATUS, UIProvider.SyncStatus.LIVE_QUERY);
        destMailbox.update(context, statusValues);

        try {
            final Store remoteStore = Store.getInstance(account, context);
            final Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
            remoteFolder.open(OpenMode.READ_WRITE);

            SortableMessage[] sortableMessages = new SortableMessage[0];
            if (searchParams.mOffset == 0) {
                // Get the "bare" messages (basically uid)
                final Message[] remoteMessages = remoteFolder.getMessages(searchParams, null);
                final int remoteCount = remoteMessages.length;
                if (remoteCount > 0) {
                    sortableMessages = new SortableMessage[remoteCount];
                    int i = 0;
                    for (Message msg : remoteMessages) {
                        sortableMessages[i++] = new SortableMessage(msg, Long.parseLong(msg.getUid()));
                    }
                    // Sort the uid's, most recent first
                    // Note: Not all servers will be nice and return results in the order of request;
                    // those that do will see messages arrive from newest to oldest
                    Arrays.sort(sortableMessages, new Comparator<SortableMessage>() {
                        @Override
                        public int compare(SortableMessage lhs, SortableMessage rhs) {
                            return lhs.mUid > rhs.mUid ? -1 : lhs.mUid < rhs.mUid ? 1 : 0;
                        }
                    });
                    sSearchResults.put(accountId, sortableMessages);
                }
            } else {
                // It seems odd for this to happen, but if the previous query returned zero results,
                // but the UI somehow still attempted to load more, then sSearchResults will have
                // a null value for this account. We need to handle this below.
                sortableMessages = sSearchResults.get(accountId);
            }

            final int numSearchResults = (sortableMessages != null ? sortableMessages.length : 0);
            final int numToLoad =
                    Math.min(numSearchResults - searchParams.mOffset, searchParams.mLimit);
            destMailbox.updateMessageCount(context, numSearchResults);
            if (numToLoad <= 0) {
                return 0;
            }

            final ArrayList<Message> messageList = new ArrayList<Message>();
            for (int i = searchParams.mOffset; i < numToLoad + searchParams.mOffset; i++) {
                messageList.add(sortableMessages[i].mMessage);
            }
            // First fetch FLAGS and ENVELOPE. In a second pass, we'll fetch STRUCTURE and
            // the first body part.
            final FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.FLAGS);
            fp.add(FetchProfile.Item.ENVELOPE);

            Message[] messageArray = messageList.toArray(new Message[messageList.size()]);

            // TODO: Why should we do this with a messageRetrievalListener? It updates the messages
            // directly in the messageArray. After making this call, we could simply walk it
            // and do all of these operations ourselves.
            remoteFolder.fetch(messageArray, fp, new MessageRetrievalListener() {
                @Override
                public void messageRetrieved(Message message) {
                    // TODO: Why do we have two separate try/catch blocks here?
                    // After MR1, we should consolidate this.
                    try {
                        EmailContent.Message localMessage = new EmailContent.Message();

                        try {
                            // Copy the fields that are available into the message
                            LegacyConversions.updateMessageFields(localMessage,
                                    message, account.mId, mailbox.mId);
                            // Save off the mailbox that this message *really* belongs in.
                            // We need this information if we need to do more lookups
                            // (like loading attachments) for this message. See b/11294681
                            localMessage.mMainMailboxKey = localMessage.mMailboxKey;
                            localMessage.mMailboxKey = destMailboxId;
                            // We load 50k or so; maybe it's complete, maybe not...
                            // We store the serverId of the source mailbox into protocolSearchInfo
                            // This will be used by loadMessageForView, etc. to use the proper remote
                            // folder
                            localMessage.mProtocolSearchInfo = mailbox.mServerId;
                            // Commit the message to the local store
                            Utilities.saveOrUpdate(localMessage, context);
                        } catch (MessagingException me) {
                            LogUtils.e(Logging.LOG_TAG,
                                    "Error while copying downloaded message." + me);
                        }
                    } catch (Exception e) {
                        LogUtils.e(Logging.LOG_TAG,
                                "Error while storing downloaded message." + e.toString());
                    }
                }

                @Override
                public void loadAttachmentProgress(int progress) {
                }
            });

            // Now load the structure for all of the messages:
            fp.clear();
            fp.add(FetchProfile.Item.STRUCTURE);
            remoteFolder.fetch(messageArray, fp, null);

            // Finally, load the first body part (i.e. message text).
            // This means attachment contents are not yet loaded, but that's okay,
            // we'll load them as needed, same as in synced messages.
            Message [] oneMessageArray = new Message[1];
            for (Message message : messageArray) {
                // Build a list of parts we are interested in. Text parts will be downloaded
                // right now, attachments will be left for later.
                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);
                // Download the viewables immediately
                oneMessageArray[0] = message;
                for (Part part : viewables) {
                    fp.clear();
                    fp.add(part);
                    remoteFolder.fetch(oneMessageArray, fp, null);
                }
                // Store the updated message locally and mark it fully loaded
                Utilities.copyOneMessageToProvider(context, message, account, destMailbox,
                        EmailContent.Message.FLAG_LOADED_COMPLETE);
            }
            /** M: Set and update mailbox flag. @{ */
            int currentCount = searchParams.mOffset + messageArray.length;
            boolean allMessagesLoaded = false;
            if (currentCount >= numSearchResults) {
                allMessagesLoaded = true;
            }
            destMailbox.updateAllMessageDownloadFlag(context, allMessagesLoaded);
            /** @} */
            return numSearchResults;
        } finally { /// M: move the UI update code to finally block to avoid this operation lost.
            // Tell UI that we're done loading messages
            statusValues.put(Mailbox.SYNC_TIME, System.currentTimeMillis());
            statusValues.put(Mailbox.UI_SYNC_STATUS, UIProvider.SyncStatus.NO_SYNC);
            destMailbox.update(context, statusValues);
        }
    }

    /**
     * M: Open a specific remote folder. Open may throw ImapException as the remote folder
     * had been deleted(by other client)server will response "NO" in this case.(do not always
     * call exists(), for saving power and bandwidth).
     * @param context
     * @param folder
     * @param mode
     * @param forceCreate if true, try to create the folder on the server side.
     * @return
     * @throws MessagingException
     */
    private static boolean openFolder(Context context, Folder folder, OpenMode mode, boolean forceCreate)
            throws MessagingException {
        try {
            folder.open(mode);
        } catch (MessagingException e) {
            if (!folder.exists()) {
                if (forceCreate) {
                    // Create it on the server side and try to open again.
                    // This may imply the server "should" has this folder
                    folder.create(FolderType.HOLDS_MESSAGES);
                    folder.open(mode);
                } else {
                    // Update folder list. It will delete the folder that had been deleted
                    // at server side
                    long acctId = Mailbox.getAccountIdForMailbox(context,
                            String.valueOf(((ImapFolder)folder).getMailboxId()));
                    final EmailServiceProxy service =
                        EmailServiceUtils.getServiceForAccount(context, acctId);
                    try {
                        service.updateFolderList(acctId);
                    } catch (RemoteException re) {
                        LogUtils.e(Logging.LOG_TAG, "Error in updateFolderList:" + re);
                    }
                    return false;
                }
            } else {
                // The folder exist on the server but open failed, throw the exception
                throw e;
            }
        }

        // Check if it was correctly opened in the "openMode"
        if (folder.getMode() != mode) {
            folder.close(false);
            return false;
        }

        return true;
    }
}
