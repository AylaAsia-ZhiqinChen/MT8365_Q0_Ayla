/*
 * Copyright (c) 2019, MediaTek Inc. All rights reserved.
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws.
 * The information contained herein is confidential and proprietary to
 * MediaTek Inc. and/or its licensors.
 * Except as otherwise provided in the applicable licensing terms with
 * MediaTek Inc. and/or its licensors, any reproduction, modification, use or
 * disclosure of MediaTek Software, and information contained herein, in whole
 * or in part, shall be strictly prohibited.
*/

#include <assert.h>
#include <err.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <trusty_std.h>

#include <openssl/engine.h>
#include <openssl/digest.h>
#include <openssl/cipher.h>
#include <openssl/bn.h>
#include <openssl/rsa.h>
#include <openssl/ec_key.h>
#include <openssl/ecdsa.h>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <openssl/mem.h>

#define LOG_TAG "KM_SETKEY_TEST"
#define TLOGE(fmt, ...) \
	fprintf(stderr, "%s: %s: %d: " fmt, LOG_TAG, __FUNCTION__, __LINE__,  ## __VA_ARGS__)

#define TLOGP(fmt, ...) \
	fprintf(stderr, fmt,  ## __VA_ARGS__)

#define RSA_PKCS_15 1


#define data_size 0x100
#define hash_size 32
#define aes_128_size 16
#define aes_256_size 32
#define log_size 16

static uint8_t out[data_size];
static uint32_t out_len;

static RSA *rsakey = NULL;
static EC_KEY *ecckey = NULL;

static const char n_str[] = "93e9d24366cc82f973ea4b7277e1ab95eeb20376c2a15d6463d1573db85f768a382167f041d6fe1ff93b1b45eccfe10e51e67afbc9754d300f32ddc4aa18bc614f0fc4ce1e19dcc734cf792d72a075e538e8d22c72cea9342b7bb07b28a322e199d04d567bf281dc7e99c2068c3e8ef26e5888b97a789927c74184a2ce02a266bceab0216f54d0b000c18e017d8d63d08bfd5a56448292faa0bf742ca272ef4135b5920227faf2619985fc83044bca8a1176b7dc167655e0846ff1e3f82b06884fe7fc768aea2208fbdb3199a59da4532b764b8b951aa122a2d0571d19fec8292390d95101adc626f50cee5572bc826f6d585294d65e67cec60c7193416eea67";
static const char e_str[] = "010001";
static const char d_str[] = "14ad05a8485164298c8b7eba6489961ba23f1dfed6dc099b03dcfa6df53cdaec1d468629ee7a2811be1c0606f34067bc41b48f126d29c97d63527fef82bb6c71c9c47185426de90fab9128e63274bda62a1b596dbf2aa63a55adb790afb0862ab4fe8a2101b87770a3fdc842740e369b2ad3936121fe83a22cd73abc2b41f1036710fa3b10a05611c14001b50609f2993d4660c6e39b5d53d136ae36595211e5637875319e2079749cba27309ed68aec27d32b00c45ce022ec020047eb446848efca275cb00713ea7ededb541d63bbe2cb919befb799da996f46bfc77f9c93c71b1c1080fe3b1a30278fc5ef47fa494b466db093da2d78a881072b0784ad93f9";
static const char p_str[] = "c6b7cdfe5d2470959dec7f57901c2a38ea89d1414af6910dcccb57ad1d1862c6a4d2c5410c37b38a86b33d84937cfb8ffe5b3e9f4813d66b032bf7f511df4b44ef2f4234af98f8977019278e0eba47cd0fee14c89fea27b48484f51b17b46bd7b7c034d2ee44ab67cfb4d4cf1b6975351b569e73623a6e08f18d78866ec6e4b3";
static const char q_str[] = "be8cf0b90dadbe3ee691cbc380fd8448695247af297e1ef45474e555b373545a728ade223c1789b37eb9435152ca74b24acab0d230014af4f4bc0bc39921be4cae67a7fc67536626a9170356e140b769a5b4e21498c2c22967faa644fb299946227bd77633ef733d680597f1c32cad1c5f1d16d0d0035e7529b5447b2f1f457d";
static const char dmp1_str[] = "1e0a1d0ead9fdb91127d74c694d75d1e9b7dd7ef29d8da169ef5c23c3e20b895d4c6b3e0e06aef2e2aac9fc911ce9beca983bb94b27da5352a1694762c8c77c164f2dcec3ffb3ce10fa60dcfb0b44234628b180338015a9d34473112366424c54856bae583f5477ffaeb181c72c55f5d76d3824268fff23051eb93e3a68d5477";
static const char dmq1_str[] = "9a0fa3d54a9cedd337622b87eef38a0f6db00bab3075fb1afa69e4bdecafd344a9956351f499e7488badc822a9386d2f75cef9358780941507063ed0af2f9c07ad7ebb50144e56a9ed4e60f1ce7f1f8bb8614de4ef398ff8204c8440037db7a1ffe176ebe7c3b2bdb42bc994bb839496fac3af1db700f24ef220cfb474fde895";
static const char iqmp_str[] = "54275eb19374802785d7d4b6dfc62d3da7ffec20d903b16b480dce5aa47a7a1fee0ee99efcd4a665bdbba680f32e38bc5cf857cc59a7346728941067baf6ec6eeaea24f8d9fedc771249b2c6c476f5bbdb6c0cddf58c84958ce94c71cd0d7ce15b2cc02c930ada28eb93ed4351af7bd8f10084a1cfaff6258dc0d53ed5a8ad26";

static const uint8_t rsa_sig[] = {
	0x11, 0x23, 0x27, 0x44, 0x0A, 0xBC, 0x87, 0x48, 0xDE, 0x77, 0xA1, 0x3C, 0x1F, 0xB2, 0x16, 0x18,
	0x0A, 0x83, 0xF0, 0x8A, 0xCB, 0x15, 0x7C, 0xCD, 0x50, 0x8A, 0x44, 0x5F, 0x10, 0x87, 0x3D, 0x22,
	0xC8, 0x99, 0x73, 0xC2, 0xD4, 0x8F, 0x45, 0x5A, 0xC5, 0x68, 0x65, 0xE8, 0x60, 0xC8, 0x75, 0x4F,
	0xB9, 0x5F, 0x9A, 0x11, 0xF0, 0x00, 0x24, 0x51, 0x97, 0xB0, 0x5D, 0xAF, 0x02, 0x37, 0xF3, 0x73,
	0x98, 0x27, 0x98, 0xBE, 0x0A, 0x24, 0x32, 0x38, 0x7E, 0x28, 0x83, 0x50, 0x3E, 0xF7, 0xB1, 0xBE,
	0x79, 0x34, 0x02, 0x3A, 0x96, 0x1E, 0x5C, 0x39, 0xC6, 0x7C, 0xB8, 0x18, 0xB0, 0x5F, 0x0E, 0x2F,
	0xA6, 0xDD, 0x01, 0x13, 0x17, 0xD3, 0x6A, 0x00, 0x4A, 0x57, 0xF0, 0x2B, 0x54, 0x02, 0xC2, 0x8A,
	0x69, 0x6F, 0xD3, 0x8D, 0xDF, 0x6A, 0x49, 0xCB, 0x96, 0x70, 0x15, 0x8A, 0xD3, 0x4E, 0x9A, 0xFF,
	0x91, 0x0D, 0xFB, 0x9B, 0xB7, 0x41, 0xAF, 0x3E, 0x14, 0xCB, 0xB9, 0x64, 0x48, 0x02, 0x09, 0x30,
	0x43, 0xF6, 0xE0, 0x63, 0x1F, 0xA0, 0x06, 0x9E, 0x59, 0xA9, 0x68, 0xAD, 0x1D, 0x0D, 0x05, 0x6C,
	0x95, 0x1B, 0x27, 0xC6, 0x4D, 0x14, 0xEC, 0x82, 0x0D, 0x22, 0xE1, 0xA3, 0x8A, 0x1D, 0x7B, 0xA7,
	0xF1, 0x6C, 0xCE, 0xA3, 0xB0, 0x11, 0xCA, 0x6C, 0x7D, 0x39, 0x77, 0xB8, 0x04, 0xA8, 0xCB, 0x5A,
	0xC3, 0x41, 0x9F, 0xBA, 0xE3, 0xDB, 0x2C, 0x37, 0x60, 0x4F, 0x56, 0xB3, 0xAB, 0x8F, 0x40, 0x4F,
	0x5E, 0x06, 0xC1, 0x16, 0x81, 0xBB, 0x86, 0xDB, 0x5F, 0x88, 0x01, 0x96, 0x64, 0x1A, 0x58, 0xB5,
	0x4A, 0x2C, 0xB3, 0x66, 0x77, 0xC6, 0x92, 0xE2, 0x1E, 0xAB, 0xE1, 0x8B, 0x99, 0xE5, 0xCD, 0x97,
	0x13, 0xD8, 0xFB, 0xC5, 0xF8, 0x07, 0xAB, 0xA1, 0xA6, 0xF6, 0x02, 0xB8, 0xF4, 0xE6, 0x8E, 0x32};

static const uint8_t rsa_msg[] = {
	0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x00, 0x01, 0x02,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12};

static const int nid = 415;
static const char sk_str[] = "752e8319ccaaae0453901fca5cbf9b4bcb7be8a49752d4a245467e56aebc966c";
static const char x_str[] = "1e8cbe356ea282695da15371434db28dab9a7b10debf0a87262e522252acb0f1";
static const char y_str[] = "321943d907b5b25595eb02e14e4faa793b92c1709e4543a39c2ac720380f780e";
static const uint32_t enc_flag = 0;
static const uint32_t conv_form = 4;

static const uint8_t ecc_sig[] = {
	0x30, 0x45, 0x02, 0x21, 0x00, 0xBA, 0xE9, 0xFB, 0x98, 0xBB, 0x65, 0xB1, 0x67, 0xD6, 0x45, 0xC5,
	0x01, 0xCE, 0xA3, 0xD4, 0x9E, 0x09, 0x26, 0x3F, 0x8E, 0x06, 0x94, 0xBA, 0xDA, 0x1C, 0xFD, 0xDB,
	0x6E, 0xB2, 0xB2, 0x22, 0xDC, 0x02, 0x20, 0x04, 0x0E, 0xB6, 0x00, 0x53, 0x49, 0x3E, 0xF4, 0xB0,
	0xF5, 0x43, 0xC1, 0xF0, 0xA5, 0x0F, 0xE7, 0x11, 0x1A, 0x62, 0xD8, 0x4A, 0x5B, 0xD4, 0x04, 0x2C,
	0x82, 0x20, 0x3D, 0xD5, 0xED, 0x4E, 0xF3};

static const uint8_t ecc_msg[] = {
	0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x00, 0x01, 0x02,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12};

static const uint8_t aes_128_key[] = {
	0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21};

static const uint8_t aes_128_iv[] = {
	0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35};

static const uint8_t aes_128_ctx[] = {
	0x5D, 0xD1, 0x17, 0xB0, 0xCD, 0xD1, 0xD7, 0x85, 0x65, 0xB6, 0x51, 0xAF, 0x92, 0x04, 0x43, 0xB4,
	0x0D, 0x85, 0xB7, 0x9B, 0x7D, 0xA6, 0x98, 0xC1, 0x3E, 0xD0, 0xE0, 0xA1, 0x4B, 0x9D, 0x87, 0xCB,
	0xC2, 0x04, 0x64, 0xC3, 0x78, 0x79, 0xB0, 0x78, 0x77, 0xD7, 0xC5, 0xFF, 0xC9, 0xFF, 0xAF, 0xB0,
	0xFF, 0x07, 0x3D, 0x8A, 0xE6, 0x3D, 0x88, 0xC7, 0xE0, 0x0E, 0x7B, 0xC7, 0x50, 0xAB, 0xD5, 0xFC,
	0xED, 0xF9, 0x9C, 0x22, 0x8D, 0x0C, 0x9D, 0x71, 0x22, 0x15, 0x99, 0x1A, 0xCB, 0xE3, 0x3B, 0x4D,
	0x35, 0x75, 0x14, 0x1D, 0x75, 0xF0, 0x29, 0xAC, 0x87, 0xA8, 0x89, 0xD1, 0x0B, 0xE3, 0x44, 0xE5,
	0xD4, 0x93, 0x23, 0x03, 0x09, 0xE6, 0x9C, 0x78, 0x4F, 0x13, 0xF2, 0x42, 0x23, 0xB1, 0xCD, 0x51,
	0xCF, 0xF0, 0xD1, 0x9D, 0xFB, 0x55, 0x47, 0xCD, 0xD8, 0x29, 0x67, 0x66, 0xD4, 0x82, 0x99, 0x8D,
	0xC0, 0xAD, 0x51, 0x9C, 0x85, 0xB3, 0x10, 0x95, 0x4A, 0x85, 0x38, 0x6C, 0xD2, 0xCE, 0x91, 0xB2,
	0xFD, 0x16, 0x85, 0x0B, 0x55, 0x61, 0x68, 0xED, 0x02, 0x8E, 0x3B, 0xE4, 0x64, 0x51, 0x7B, 0xAF,
	0xEE, 0x8A, 0x93, 0xCB, 0xDE, 0x0E, 0x89, 0x9E, 0x79, 0x90, 0x54, 0x8A, 0x70, 0x30, 0x6F, 0x00,
	0x9F, 0xF8, 0x20, 0x95, 0x4F, 0x3D, 0xC8, 0xED, 0x69, 0x1B, 0x97, 0xA5, 0x7E, 0x56, 0xBE, 0x20,
	0x8B, 0x57, 0x07, 0x52, 0xDA, 0x6B, 0x37, 0x83, 0xE7, 0xBA, 0x71, 0x92, 0x74, 0x67, 0x53, 0x0C,
	0x84, 0x25, 0x07, 0xA4, 0xDA, 0xD3, 0x7A, 0xF5, 0xBF, 0xA7, 0x0F, 0xDD, 0xB5, 0xA7, 0xF2, 0xCE,
	0x6A, 0x93, 0x3D, 0x0A, 0x61, 0x36, 0x8F, 0x40, 0x3A, 0x6D, 0xE9, 0x08, 0x1E, 0x2D, 0xCF, 0xAB,
	0x5F, 0x9E, 0x1E, 0x1D, 0xE4, 0xAE, 0xFF, 0x00, 0x32, 0x85, 0x8E, 0x01, 0x1E, 0x3F, 0x88, 0x95};

static const uint8_t aes_128_ptx[] = {
	0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x00, 0x01, 0x02,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42,
	0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
	0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
	0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82,
	0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92,
	0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2,
	0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2,
	0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
	0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
	0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2,
	0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2};

static const uint8_t aes_256_key[] = {
	0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21,
	0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31};

static const uint8_t aes_256_iv[] = {
	0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
	0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45};

static const uint8_t aes_256_ctx[] = {
	0x82, 0x61, 0x66, 0x1F, 0x74, 0x93, 0x19, 0x22, 0xD6, 0xD5, 0x1F, 0x07, 0xEC, 0xA4, 0xA2, 0x94,
	0x3D, 0xA4, 0x7F, 0xC3, 0x1C, 0x1A, 0x64, 0x61, 0x24, 0xE1, 0x94, 0x4A, 0xA4, 0x84, 0x21, 0x35,
	0x7D, 0xA9, 0xEE, 0xE7, 0x11, 0xE4, 0xC3, 0x6A, 0xF4, 0x70, 0x36, 0xA9, 0xD1, 0x29, 0x06, 0x67,
	0xA8, 0x05, 0xD9, 0x1B, 0xB0, 0x64, 0x2A, 0x7E, 0x46, 0x1A, 0x41, 0x66, 0xAB, 0x68, 0x00, 0x2E,
	0xCB, 0x32, 0x0D, 0x29, 0xB7, 0x7A, 0xF8, 0x6A, 0xBE, 0xF3, 0x1A, 0xD4, 0x7F, 0x2F, 0xFD, 0x85,
	0xA9, 0x33, 0xB5, 0x99, 0x59, 0x1D, 0xB2, 0x18, 0xE4, 0x03, 0x78, 0x26, 0x60, 0xC1, 0x55, 0x97,
	0x8E, 0x6D, 0xD8, 0x5E, 0xB2, 0xB7, 0xBF, 0x6F, 0x15, 0xB2, 0xFB, 0x28, 0xA2, 0xA6, 0xC9, 0x06,
	0x28, 0x12, 0x69, 0x81, 0x2F, 0x60, 0x51, 0x51, 0xE8, 0xD2, 0x6A, 0xF9, 0x72, 0x80, 0xB7, 0x88,
	0xF7, 0x83, 0xB5, 0x3C, 0x4B, 0x13, 0xEB, 0x30, 0x7D, 0xE7, 0x53, 0x10, 0xCA, 0xDF, 0xE7, 0xD3,
	0xC8, 0x55, 0x22, 0x81, 0x16, 0xCD, 0xFC, 0x87, 0xCD, 0x7A, 0x8C, 0xE2, 0x4D, 0x39, 0x9E, 0x74,
	0x25, 0x4E, 0xBD, 0x88, 0xF1, 0xE8, 0x09, 0x8A, 0x86, 0x24, 0x9D, 0x75, 0x10, 0x61, 0x25, 0xAA,
	0xDC, 0x64, 0xDA, 0xCA, 0x47, 0x42, 0xDF, 0xB9, 0xAC, 0x29, 0x6E, 0xB3, 0xC2, 0x85, 0x23, 0xCD,
	0x05, 0x48, 0xCE, 0x03, 0xDD, 0x0F, 0x65, 0xC0, 0x35, 0xAA, 0xA5, 0xFA, 0xE1, 0x69, 0x61, 0x3F,
	0x43, 0x38, 0x45, 0x59, 0xC1, 0xCD, 0xE7, 0x22, 0x5D, 0x8A, 0x07, 0xA2, 0x6D, 0x70, 0x57, 0xCB,
	0x60, 0x72, 0xA3, 0x13, 0xA6, 0x8A, 0xC6, 0x97, 0xEA, 0x05, 0x85, 0xDA, 0x64, 0x8A, 0x0B, 0x31,
	0x2C, 0x43, 0x2D, 0x18, 0x1A, 0xEC, 0x26, 0x43, 0xF2, 0x04, 0xFC, 0xD4, 0xD0, 0xDE, 0xFA, 0xE4};


static const uint8_t aes_256_ptx[] = {
	0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x00, 0x01, 0x02,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42,
	0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
	0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
	0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82,
	0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92,
	0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2,
	0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2,
	0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
	0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
	0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2,
	0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2};

static const uint8_t sha_256_hash[] = {
	0x1F, 0xEB, 0x31, 0x47, 0x39, 0x9B, 0xF7, 0xDD, 0x85, 0x47, 0xD3, 0x81, 0x23, 0xFC, 0xB7, 0x89,
	0x1F, 0xA8, 0xAF, 0x09, 0x7C, 0xA5, 0xF8, 0x33, 0x7D, 0x17, 0x9C, 0x38, 0xA8, 0x5B, 0x4C, 0x84};

static const uint8_t sha_256_msg[] = {
	0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x00, 0x01, 0x02,
	0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42,
	0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,
	0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
	0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82,
	0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92,
	0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2,
	0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2,
	0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2,
	0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2,
	0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2,
	0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2};

int32_t generate_rsa_key_test(void)
{
	int32_t rc = 1;

	if (rsakey)
		RSA_free(rsakey);

	rsakey = RSA_new();
	if (rsakey == NULL) {
		TLOGE("Allocation RSA key failed!\n");
		return -1;
	}

	BIGNUM *n = NULL, *e = NULL, *d = NULL, *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
	rc = BN_hex2bn(&n, n_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(n) failed!\n");
		rc = -2;
		goto exit0;
	}

	rc = BN_hex2bn(&e, e_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(e) failed!\n");
		rc = -3;
		goto exit1;
	}

	rc = BN_hex2bn(&d, d_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(d) failed!\n");
		rc = -4;
		goto exit2;
	}

	rc = BN_hex2bn(&p, p_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(p) failed!\n");
		rc = -5;
		goto exit3;
	}

	rc = BN_hex2bn(&q, q_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(q) failed!\n");
		rc = -6;
		goto exit4;
	}

	rc = BN_hex2bn(&dmp1, dmp1_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(dmp1) failed!\n");
		rc = -7;
		goto exit5;
	}

	rc = BN_hex2bn(&dmq1, dmq1_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(dmq1) failed!\n");
		rc = -8;
		goto exit6;
	}

	rc = BN_hex2bn(&iqmp, iqmp_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(iqmp) failed!\n");
		rc = -9;
		goto exit7;
	}

	BN_clear_free(rsakey->n);
	rsakey->n = BN_dup(n);
	if (rsakey->n == NULL) {
		TLOGE("BN_dup(n) failed!\n");
		rc = -10;
		goto exit8;
	}
	BN_clear_free(rsakey->e);
	rsakey->e = BN_dup(e);
	if (rsakey->e == NULL) {
		TLOGE("BN_dup(e) failed!\n");
		rc = -11;
		goto exit8;
	}
	BN_clear_free(rsakey->d);
	rsakey->d = BN_dup(d);
	if (rsakey->d == NULL) {
		TLOGE("BN_dup(d) failed!\n");
		rc = -12;
		goto exit8;
	}
	BN_clear_free(rsakey->p);
	rsakey->p = BN_dup(p);
	if (rsakey->p == NULL) {
		TLOGE("BN_dup(p) failed!\n");
		rc = -13;
		goto exit8;
	}
	BN_clear_free(rsakey->q);
	rsakey->q = BN_dup(q);
	if (rsakey->q == NULL) {
		TLOGE("BN_dup(q) failed!\n");
		rc = -14;
		goto exit8;
	}
	BN_clear_free(rsakey->dmp1);
	rsakey->dmp1 = BN_dup(dmp1);
	if (rsakey->dmp1 == NULL) {
		TLOGE("BN_dup(dmp1) failed!\n");
		rc = -15;
		goto exit8;
	}
	BN_clear_free(rsakey->dmq1);
	rsakey->dmq1 = BN_dup(dmq1);
	if (rsakey->dmq1 == NULL) {
		TLOGE("BN_dup(dmq1) failed!\n");
		rc = -16;
		goto exit8;
	}
	BN_clear_free(rsakey->iqmp);
	rsakey->iqmp = BN_dup(iqmp);
	if (rsakey->iqmp == NULL) {
		TLOGE("BN_dup(iqmp) failed!\n");
		rc = -17;
		goto exit8;
	}

	rc = RSA_check_fips(rsakey);
	if (rc != 1) {
		TLOGE("RSA_check_fips failed: %d!\n", rc);
		rc = -18;
		goto exit8;
	}
exit8:
	BN_free(iqmp);
exit7:
	BN_free(dmq1);
exit6:
	BN_free(dmp1);
exit5:
	BN_free(q);
exit4:
	BN_free(p);
exit3:
	BN_free(d);
exit2:
	BN_free(e);
exit1:
	BN_free(n);
exit0:
	return rc < 0 ? rc : 0;
}

int32_t generate_rsa_signature_test(void)
{
	int32_t rc = 1;

	out_len = data_size;
#if RSA_PKCS_15
	rc = RSA_sign(NID_sha256, rsa_msg, hash_size, out, &out_len, rsakey);
	if (rc != 1) {
		TLOGE("RSA_sign failed (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
#else
	rc = RSA_sign_pss_mgf1(rsakey, &out_len, out, data_size, rsa_msg, in_len, EVP_sha256(), NULL, -1);
	if (rc != 1) {
		TLOGE("RSA_sign_pss_mgf1 failed (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
#endif
	rc = CRYPTO_memcmp(out, rsa_sig, out_len);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		rc = -2;
		goto exit;
	}
exit:
	return rc < 0 ? rc : 0;
}

int32_t verify_rsa_signature_test(void)
{
	int32_t rc = 1;
#if RSA_PKCS_15
	rc = RSA_verify(NID_sha256, rsa_msg, hash_size, out, out_len, rsakey);
	if (rc != 1) {
		TLOGE("RSA_verify (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
#else
	rc = RSA_verify_pss_mgf1(rsakey, rsa_msg, in_len, EVP_sha256(), NULL, -1, out, out_len);
	if (rc != 1) {
		TLOGE("RSA_verify_pss_mgf1 (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
#endif
exit:
	return rc < 0 ? rc : 0;
}

int32_t generate_ecc_key_test(void)
{
	int32_t rc = 1;

	if (ecckey)
		EC_KEY_free(ecckey);

	ecckey = EC_KEY_new_by_curve_name(nid);
	if (ecckey == NULL) {
		TLOGE("Allocation ECC key failed!\n");
		return -1;
	}

	BIGNUM *sk = NULL, *x = NULL, *y = NULL;
	rc = BN_hex2bn(&sk, sk_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(sk) failed!\n");
		rc = -2;
		goto exit0;
	}

	rc = BN_hex2bn(&x, x_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(x) failed!\n");
		rc = -3;
		goto exit1;
	}

	rc = BN_hex2bn(&y, y_str);
	if (rc == 0) {
		TLOGE("BN_hex2bn(y) failed!\n");
		rc = -4;
		goto exit2;
	}

	rc = EC_KEY_set_private_key(ecckey, sk);
	if (rc != 1) {
		TLOGE("EC_KEY_set_private_key failed: %d!\n", rc);
		rc = -5;
		goto exit3;
	}

	rc = EC_KEY_set_public_key_affine_coordinates(ecckey, x, y);
	if (rc != 1) {
		TLOGE("EC_KEY_set_public_key_affine_coordinates: %d!\n", rc);
		rc = -6;
		goto exit3;
	}

	rc = EC_KEY_check_fips(ecckey);
	if (rc != 1) {
		TLOGE("EC_KEY_check_fips failed: %d!\n", rc);
		rc = -7;
		goto exit3;
	}
exit3:
	BN_free(y);
exit2:
	BN_free(x);
exit1:
	BN_free(sk);
exit0:
	return rc < 0 ? rc : 0;
}

int32_t generate_ecc_signature_test(void)
{
	int32_t rc = 1;

	out_len = data_size;

	rc = ECDSA_sign(0, ecc_msg, hash_size, out, &out_len, ecckey);
	if (rc != 1) {
		TLOGE("ECDSA_sign failed (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
exit:
	return rc < 0 ? rc : 0;
}

int32_t verify_ecc_signature_test(void)
{
	int32_t rc = 1;

	rc = ECDSA_verify(0, ecc_msg, hash_size, out, out_len, ecckey);
	if (rc != 1) {
		TLOGE("ECDSA_verify failed (%d)!\n", rc);
		rc = -1;
		goto exit;
	}

	rc = ECDSA_verify(0, ecc_msg, hash_size, ecc_sig, sizeof(ecc_sig), ecckey);
	if (rc != 1) {
		TLOGE("ECDSA_verify failed (%d)!\n", rc);
		rc = -1;
		goto exit;
	}
exit:
	return rc < 0 ? rc : 0;
}

int32_t perform_aes_128_enc_test(void)
{
	int32_t rc;

	EVP_CIPHER_CTX *cipher_ctx = EVP_CIPHER_CTX_new();
	if (cipher_ctx == NULL) {
		TLOGE("Allocation cipher context failed!\n");
		return -1;
	}

	rc = EVP_CipherInit_ex(cipher_ctx, EVP_aes_128_cbc(), NULL, aes_128_key, aes_128_iv, 1);
	if (rc != 1) {
		TLOGE("Initialize cipher failed!\n");
		rc = -2;
		goto exit;
	}

	rc = EVP_Cipher(cipher_ctx, out, aes_128_ptx, data_size);
	if (rc != 1) {
		TLOGE("cipher failed!\n");
		rc = -3;
		goto exit;
	}

	rc = CRYPTO_memcmp(out, aes_128_ctx, data_size);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		rc = -4;
		goto exit;
	}
exit:
	EVP_CIPHER_CTX_free(cipher_ctx);
	return rc < 0 ? rc : 0;
}

int32_t perform_aes_128_dec_test(void)
{
	int32_t rc;

	EVP_CIPHER_CTX *cipher_ctx = EVP_CIPHER_CTX_new();
	if (cipher_ctx == NULL) {
		TLOGE("Allocation cipher context failed!\n");
		return -1;
	}

	rc = EVP_CipherInit_ex(cipher_ctx, EVP_aes_128_cbc(), NULL, aes_128_key, aes_128_iv, 0);
	if (rc != 1) {
		TLOGE("Initialize cipher failed!\n");
		rc = -2;
		goto exit;
	}

	rc = EVP_Cipher(cipher_ctx, out, aes_128_ctx, data_size);
	if (rc != 1) {
		TLOGE("cipher failed!\n");
		rc = -3;
		goto exit;
	}

	rc = CRYPTO_memcmp(out, aes_128_ptx, data_size);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		rc = -4;
		goto exit;
	}
exit:
	EVP_CIPHER_CTX_free(cipher_ctx);
	return rc < 0 ? rc : 0;
}

int32_t perform_aes_256_enc_test(void)
{
	int32_t rc;

	EVP_CIPHER_CTX *cipher_ctx = EVP_CIPHER_CTX_new();
	if (cipher_ctx == NULL) {
		TLOGE("Allocation cipher context failed!\n");
		return -1;
	}

	rc = EVP_CipherInit_ex(cipher_ctx, EVP_aes_256_cbc(), NULL, aes_256_key, aes_256_iv, 1);
	if (rc != 1) {
		TLOGE("Initialize cipher failed!\n");
		rc = -2;
		goto exit;
	}

	rc = EVP_Cipher(cipher_ctx, out, aes_256_ptx, data_size);
	if (rc != 1) {
		TLOGE("cipher failed!\n");
		rc = -3;
		goto exit;
	}

	rc = CRYPTO_memcmp(out, aes_256_ctx, data_size);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		rc = -4;
		goto exit;
	}
exit:
	EVP_CIPHER_CTX_free(cipher_ctx);
	return rc < 0 ? rc : 0;
}

int32_t perform_aes_256_dec_test(void)
{
	int32_t rc;

	EVP_CIPHER_CTX *cipher_ctx = EVP_CIPHER_CTX_new();
	if (cipher_ctx == NULL) {
		TLOGE("Allocation cipher context failed!\n");
		return -1;
	}

	rc = EVP_CipherInit_ex(cipher_ctx, EVP_aes_256_cbc(), NULL, aes_256_key, aes_256_iv, 0);
	if (rc != 1) {
		TLOGE("Initialize cipher failed!\n");
		rc = -2;
		goto exit;
	}

	rc = EVP_Cipher(cipher_ctx, out, aes_256_ctx, data_size);
	if (rc != 1) {
		TLOGE("cipher failed!\n");
		rc = -3;
		goto exit;
	}

	rc = CRYPTO_memcmp(out, aes_256_ptx, data_size);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		rc = -4;
		goto exit;
	}
exit:
	EVP_CIPHER_CTX_free(cipher_ctx);
	return rc < 0 ? rc : 0;
}

int32_t perform_sha_hash_test(void)
{
	int32_t rc;

	out_len = data_size;

	rc = EVP_Digest(sha_256_msg, data_size, out, &out_len, EVP_sha256(), NULL);
	if (rc != 1) {
		TLOGE("Digest failed!\n");
		return -1;
	}

	if (out_len != EVP_MD_size(EVP_sha256())) {
		TLOGE("Wrong digest length: %u!\n", out_len);
		return -2;
	}

	rc = CRYPTO_memcmp(out, sha_256_hash, out_len);
	if (rc != 0) {
		TLOGE("CRYPTO_memcmp failed (%d)!\n", rc);
		return -3;
	}

	return rc < 0 ? rc : 0;
}
